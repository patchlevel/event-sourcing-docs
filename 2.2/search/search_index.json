{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Event-Sourcing A lightweight but also all-inclusive event sourcing library with a focus on developer experience. Features Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony Installation composer require patchlevel/event-sourcing Integration Symfony Psalm","title":"Introduction"},{"location":"#event-sourcing","text":"A lightweight but also all-inclusive event sourcing library with a focus on developer experience.","title":"Event-Sourcing"},{"location":"#features","text":"Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony","title":"Features"},{"location":"#installation","text":"composer require patchlevel/event-sourcing","title":"Installation"},{"location":"#integration","text":"Symfony Psalm","title":"Integration"},{"location":"aggregate/","text":"Aggregate Abstract Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. [...] DDD Aggregate - Martin Flower An Aggregate has to inherit from AggregateRoot and need to implement the method aggregateRootId . aggregateRootId is the identifier from AggregateRoot like a primary key for an entity. The events will be added later, but the following is enough to make it executable: To register an aggregate you have to set the Aggregate attribute over the class, otherwise it will not be recognized as an aggregate. There you also have to give the aggregate a name. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; public function aggregateRootId () : string { return $this -> id ; } public static function register ( string $id ) : self { $self = new self (); // todo: record create event return $self ; } } Warning The aggregate is not yet finished and has only been built to the point that you can instantiate the object. Tip An aggregateId can be an uuid , you can find more about this here . We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like import . After the basic structure for an aggregate is in place, it could theoretically be saved: use Patchlevel\\EventSourcing\\Repository\\Repository ; final class CreateProfileHandler { public function __construct ( private readonly Repository $profileRepository ) {} public function __invoke ( CreateProfile $command ) : void { $profile = Profile :: register ( $command -> id ()); $this -> profileRepository -> save ( $profile ); } } Warning If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens. Note A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service. Create a new aggregate In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event ProfileRegistered : use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.registered')] final class ProfileRegistered { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Note You can find out more about events here . After we have defined the event, we have to adapt the creation of the profile: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function register ( string $id , string $name ) : self { $self = new self (); $self -> recordThat ( new ProfileRegistered ( $id , $name )); return $self ; } #[Apply] protected function applyProfileRegistered ( ProfileRegistered $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Tip Prefixing the apply methods with \"apply\" improves readability. In our named constructor register we have now created the event and recorded it with the method recordThat . The aggregate remembers all new recorded events in order to save them later. At the same time, a defined apply method is executed directly so that we can change our state. So that the AggregateRoot also knows which method it should call, we have to mark it with the Apply attributes . We did that in the applyProfileRegistered method. In this method we change the Profile properties id and name with the transferred values. Modify an aggregate In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a NameChanged event: use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name ) { } } Note Events should best be written in the past, as they describe a state that has happened. After we have defined the event, we can define a new public method called changeName to change the profile name. This method then creates the event NameChanged and records it: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function register ( string $id , string $name ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name )); return $self ; } public function changeName ( string $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyProfileRegistered ( ProfileRegistered $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } We have also defined a new apply method named applyNameChanged where we change the name depending on the value in the event. When using it, it can look like this: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Repository\\Repository ; final class ChangeNameHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( ChangeName $command ) : void { $profile = $this -> profileRepository -> load ( $command -> id ()); $profile -> changeName ( $command -> name ()); $this -> profileRepository -> save ( $profile ); } } Note You can read more about Repository here . Here the aggregate is loaded from the repository by fetching all events from the database. These events are then executed again with the apply methods in order to rebuild the current state. All of this happens automatically in the load method. The method changeName is then executed on the aggregate to change the name. In this method the event NameChanged is generated and recorded. The applyNameChanged method was also called again internally to adjust the state. When the save method is called on the repository, all newly recorded events are then fetched and written to the database. In this specific case only the NameChanged changed event. Multiple apply attributes on the same method You can also define several apply attributes with different events using the same method. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] #[Apply(NameChanged::class)] protected function applyProfileCreated ( ProfileCreated | NameChanged $event ) : void { if ( $event instanceof ProfileCreated ) { $this -> id = $event -> profileId ; } $this -> name = $event -> name ; } } Suppress missing apply methods Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future, to listen on it or to create a projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the SuppressMissingApply attribute. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([NameChanged::class])] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Suppress missing apply for all methods You can also completely deactivate the exceptions for missing apply methods. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply(SuppressMissingApply::ALL)] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Warning When all events are suppressed, debugging becomes more difficult if you forget an apply method. Business rules Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group. These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone. A further check in the apply method is also not possible because these events have already happened and were then also saved in the database. In the next example we want to make sure that the name is at least 3 characters long : use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... public function name () : string { return $this -> name ; } public function changeName ( string $name ) : void { if ( strlen ( $name ) < 3 ) { throw new NameIsToShortException ( $name ); } $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name (); } } Danger Disregarding this can break the rebuilding of the state! We have now ensured that this rule takes effect when a name is changed with the method changeName . But when we create a new profile this rule does not currently apply. In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } We can now use the value object Name in our aggregate: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; public static function register ( string $id , Name $name ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name )); return $self ; } // ... public function name () : Name { return $this -> name ; } public function changeName ( Name $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } In order for the whole thing to work, we still have to adapt our NameChanged event, since we only expected a string before but now passed a Name value object. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } Warning The payload must be serializable and unserializable as json. Note You can find out more about event normalizer here . There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the apply methods are always executed immediately. In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event FullyBooked , if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('hotel')] #[SuppressMissingApply([FullyBooked::class])] final class Hotel extends AggregateRoot { private const SIZE = 5 ; private int $people ; // ... public function book ( string $name ) : void { if ( $this -> people === self :: SIZE ) { throw new NoPlaceException ( $name ); } $this -> recordThat ( new RoomBocked ( $name )); if ( $this -> people === self :: SIZE ) { $this -> recordThat ( new FullyBooked ()); } } #[Apply] protected function applyRoomBocked ( RoomBocked $event ) : void { $this -> people ++ ; } } Working with dates An aggregate should always be deterministic. In other words, whenever I execute methods on the aggregate, I always get the same result. This also makes testing much easier. But that often doesn't seem to be possible, e.g. if you want to save a createAt date. But you can pass this information by yourself. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; private DateTimeImmutable $registeredAt ; public static function register ( string $id , string $name , DateTimeImmutable $registeredAt ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name , $registeredAt )); return $self ; } // ... } But if you still want to make sure that the time is \"now\" and not in the past or future, you can pass a clock. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Clock\\Clock ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; private DateTimeImmutable $registeredAt ; public static function register ( string $id , string $name , Clock $clock ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name , $clock -> now ())); return $self ; } // ... } Now you can pass the SystemClock to determine the current time. Or for test purposes the FrozenClock , which always returns the same time. Note You can find out more about clock here . Aggregate Root Registry The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an AggregateRootRegistry for this purpose. The registry is a simple hashmap between aggregate name and aggregate class. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = new AggregateRootRegistry ([ 'profile' => Profile :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeAggregateRootRegistryFactory is used. There, with the help of paths, all classes with the attribute Aggregate are searched for and the AggregateRootRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AttributeAggregateRootRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Aggregate"},{"location":"aggregate/#aggregate","text":"Abstract Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. [...] DDD Aggregate - Martin Flower An Aggregate has to inherit from AggregateRoot and need to implement the method aggregateRootId . aggregateRootId is the identifier from AggregateRoot like a primary key for an entity. The events will be added later, but the following is enough to make it executable: To register an aggregate you have to set the Aggregate attribute over the class, otherwise it will not be recognized as an aggregate. There you also have to give the aggregate a name. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; public function aggregateRootId () : string { return $this -> id ; } public static function register ( string $id ) : self { $self = new self (); // todo: record create event return $self ; } } Warning The aggregate is not yet finished and has only been built to the point that you can instantiate the object. Tip An aggregateId can be an uuid , you can find more about this here . We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like import . After the basic structure for an aggregate is in place, it could theoretically be saved: use Patchlevel\\EventSourcing\\Repository\\Repository ; final class CreateProfileHandler { public function __construct ( private readonly Repository $profileRepository ) {} public function __invoke ( CreateProfile $command ) : void { $profile = Profile :: register ( $command -> id ()); $this -> profileRepository -> save ( $profile ); } } Warning If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens. Note A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service.","title":"Aggregate"},{"location":"aggregate/#create-a-new-aggregate","text":"In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event ProfileRegistered : use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.registered')] final class ProfileRegistered { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Note You can find out more about events here . After we have defined the event, we have to adapt the creation of the profile: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function register ( string $id , string $name ) : self { $self = new self (); $self -> recordThat ( new ProfileRegistered ( $id , $name )); return $self ; } #[Apply] protected function applyProfileRegistered ( ProfileRegistered $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Tip Prefixing the apply methods with \"apply\" improves readability. In our named constructor register we have now created the event and recorded it with the method recordThat . The aggregate remembers all new recorded events in order to save them later. At the same time, a defined apply method is executed directly so that we can change our state. So that the AggregateRoot also knows which method it should call, we have to mark it with the Apply attributes . We did that in the applyProfileRegistered method. In this method we change the Profile properties id and name with the transferred values.","title":"Create a new aggregate"},{"location":"aggregate/#modify-an-aggregate","text":"In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a NameChanged event: use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name ) { } } Note Events should best be written in the past, as they describe a state that has happened. After we have defined the event, we can define a new public method called changeName to change the profile name. This method then creates the event NameChanged and records it: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function register ( string $id , string $name ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name )); return $self ; } public function changeName ( string $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyProfileRegistered ( ProfileRegistered $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } We have also defined a new apply method named applyNameChanged where we change the name depending on the value in the event. When using it, it can look like this: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Repository\\Repository ; final class ChangeNameHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( ChangeName $command ) : void { $profile = $this -> profileRepository -> load ( $command -> id ()); $profile -> changeName ( $command -> name ()); $this -> profileRepository -> save ( $profile ); } } Note You can read more about Repository here . Here the aggregate is loaded from the repository by fetching all events from the database. These events are then executed again with the apply methods in order to rebuild the current state. All of this happens automatically in the load method. The method changeName is then executed on the aggregate to change the name. In this method the event NameChanged is generated and recorded. The applyNameChanged method was also called again internally to adjust the state. When the save method is called on the repository, all newly recorded events are then fetched and written to the database. In this specific case only the NameChanged changed event.","title":"Modify an aggregate"},{"location":"aggregate/#multiple-apply-attributes-on-the-same-method","text":"You can also define several apply attributes with different events using the same method. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] #[Apply(NameChanged::class)] protected function applyProfileCreated ( ProfileCreated | NameChanged $event ) : void { if ( $event instanceof ProfileCreated ) { $this -> id = $event -> profileId ; } $this -> name = $event -> name ; } }","title":"Multiple apply attributes on the same method"},{"location":"aggregate/#suppress-missing-apply-methods","text":"Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future, to listen on it or to create a projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the SuppressMissingApply attribute. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([NameChanged::class])] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } }","title":"Suppress missing apply methods"},{"location":"aggregate/#suppress-missing-apply-for-all-methods","text":"You can also completely deactivate the exceptions for missing apply methods. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply(SuppressMissingApply::ALL)] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Warning When all events are suppressed, debugging becomes more difficult if you forget an apply method.","title":"Suppress missing apply for all methods"},{"location":"aggregate/#business-rules","text":"Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group. These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone. A further check in the apply method is also not possible because these events have already happened and were then also saved in the database. In the next example we want to make sure that the name is at least 3 characters long : use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... public function name () : string { return $this -> name ; } public function changeName ( string $name ) : void { if ( strlen ( $name ) < 3 ) { throw new NameIsToShortException ( $name ); } $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name (); } } Danger Disregarding this can break the rebuilding of the state! We have now ensured that this rule takes effect when a name is changed with the method changeName . But when we create a new profile this rule does not currently apply. In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } We can now use the value object Name in our aggregate: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; public static function register ( string $id , Name $name ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name )); return $self ; } // ... public function name () : Name { return $this -> name ; } public function changeName ( Name $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } In order for the whole thing to work, we still have to adapt our NameChanged event, since we only expected a string before but now passed a Name value object. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } Warning The payload must be serializable and unserializable as json. Note You can find out more about event normalizer here . There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the apply methods are always executed immediately. In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event FullyBooked , if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('hotel')] #[SuppressMissingApply([FullyBooked::class])] final class Hotel extends AggregateRoot { private const SIZE = 5 ; private int $people ; // ... public function book ( string $name ) : void { if ( $this -> people === self :: SIZE ) { throw new NoPlaceException ( $name ); } $this -> recordThat ( new RoomBocked ( $name )); if ( $this -> people === self :: SIZE ) { $this -> recordThat ( new FullyBooked ()); } } #[Apply] protected function applyRoomBocked ( RoomBocked $event ) : void { $this -> people ++ ; } }","title":"Business rules"},{"location":"aggregate/#working-with-dates","text":"An aggregate should always be deterministic. In other words, whenever I execute methods on the aggregate, I always get the same result. This also makes testing much easier. But that often doesn't seem to be possible, e.g. if you want to save a createAt date. But you can pass this information by yourself. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; private DateTimeImmutable $registeredAt ; public static function register ( string $id , string $name , DateTimeImmutable $registeredAt ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name , $registeredAt )); return $self ; } // ... } But if you still want to make sure that the time is \"now\" and not in the past or future, you can pass a clock. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Clock\\Clock ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; private DateTimeImmutable $registeredAt ; public static function register ( string $id , string $name , Clock $clock ) : static { $self = new static (); $self -> recordThat ( new ProfileRegistered ( $id , $name , $clock -> now ())); return $self ; } // ... } Now you can pass the SystemClock to determine the current time. Or for test purposes the FrozenClock , which always returns the same time. Note You can find out more about clock here .","title":"Working with dates"},{"location":"aggregate/#aggregate-root-registry","text":"The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an AggregateRootRegistry for this purpose. The registry is a simple hashmap between aggregate name and aggregate class. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = new AggregateRootRegistry ([ 'profile' => Profile :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeAggregateRootRegistryFactory is used. There, with the help of paths, all classes with the attribute Aggregate are searched for and the AggregateRootRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AttributeAggregateRootRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Aggregate Root Registry"},{"location":"cli/","text":"CLI The library also offers symfony cli commands to create or delete databases . It is also possible to manage the schema and projections . These commands are optional and only wrap existing functionalities that are also available in this way. Database commands There are two commands for creating and deleting a database. DatabaseCreateCommand: event-sourcing:database:create DatabaseDropCommand: event-sourcing:database:drop Schema commands The database schema can also be created, updated and dropped. SchemaCreateCommand: event-sourcing:schema:create SchemaUpdateCommand: event-sourcing:schema:update SchemaDropCommand: event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this. Projection commands The creation, deletion and rebuilding of the projections is also possible via the cli. ProjectionCreateCommand: event-sourcing:projection:create ProjectionDropCommand: event-sourcing:projection:drop ProjectionRebuildCommand: event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection. Projectionist commands To manage your projectors there are the following cli commands. ProjectionistBootCommand: event-sourcing:projectionist:boot ProjectionistReactiveCommand: event-sourcing:projectionist:reactive ProjectionistRemoveCommand: event-sourcing:projectionist:remove ProjectionistRunCommand: event-sourcing:projectionist:run ProjectionistStatusCommand: event-sourcing:projectionist:status ProjectionistTeardownCommand: event-sourcing:projectionist:teardown Note You can find out more about projectionist here . Outbox commands Interacting with the outbox store is also possible via the cli. OutboxInfoCommand: event-sourcing:outbox:info OutboxConsumeCommand: event-sourcing:outbox:consume Note You can find out more about outbox here . CLI example A cli php file can look like this: use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\Console\\DoctrineHelper ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; use Symfony\\Component\\Console\\Application ; $store = /* define your doctrine store */ ; $projectionRepository = /* create a project repository */ ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $doctrineHelper = new DoctrineHelper (); $schemaManager = new DoctrineSchemaManager (); $cli -> addCommands ( array ( new Command\\DatabaseCreateCommand ( $store , $doctrineHelper ), new Command\\DatabaseDropCommand ( $store , $doctrineHelper ), new Command\\ProjectionCreateCommand ( $projectionRepository ), new Command\\ProjectionDropCommand ( $projectionRepository ), new Command\\ProjectionRebuildCommand ( $store , $projectionRepository ), new Command\\SchemaCreateCommand ( $store , $schemaManager ), new Command\\SchemaDropCommand ( $store , $schemaManager ), new Command\\SchemaUpdateCommand ( $store , $schemaManager ), )); $cli -> run (); Note You can also register doctrine migration commands, see the store documentation for this.","title":"CLI"},{"location":"cli/#cli","text":"The library also offers symfony cli commands to create or delete databases . It is also possible to manage the schema and projections . These commands are optional and only wrap existing functionalities that are also available in this way.","title":"CLI"},{"location":"cli/#database-commands","text":"There are two commands for creating and deleting a database. DatabaseCreateCommand: event-sourcing:database:create DatabaseDropCommand: event-sourcing:database:drop","title":"Database commands"},{"location":"cli/#schema-commands","text":"The database schema can also be created, updated and dropped. SchemaCreateCommand: event-sourcing:schema:create SchemaUpdateCommand: event-sourcing:schema:update SchemaDropCommand: event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this.","title":"Schema commands"},{"location":"cli/#projection-commands","text":"The creation, deletion and rebuilding of the projections is also possible via the cli. ProjectionCreateCommand: event-sourcing:projection:create ProjectionDropCommand: event-sourcing:projection:drop ProjectionRebuildCommand: event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection.","title":"Projection commands"},{"location":"cli/#projectionist-commands","text":"To manage your projectors there are the following cli commands. ProjectionistBootCommand: event-sourcing:projectionist:boot ProjectionistReactiveCommand: event-sourcing:projectionist:reactive ProjectionistRemoveCommand: event-sourcing:projectionist:remove ProjectionistRunCommand: event-sourcing:projectionist:run ProjectionistStatusCommand: event-sourcing:projectionist:status ProjectionistTeardownCommand: event-sourcing:projectionist:teardown Note You can find out more about projectionist here .","title":"Projectionist commands"},{"location":"cli/#outbox-commands","text":"Interacting with the outbox store is also possible via the cli. OutboxInfoCommand: event-sourcing:outbox:info OutboxConsumeCommand: event-sourcing:outbox:consume Note You can find out more about outbox here .","title":"Outbox commands"},{"location":"cli/#cli-example","text":"A cli php file can look like this: use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\Console\\DoctrineHelper ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; use Symfony\\Component\\Console\\Application ; $store = /* define your doctrine store */ ; $projectionRepository = /* create a project repository */ ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $doctrineHelper = new DoctrineHelper (); $schemaManager = new DoctrineSchemaManager (); $cli -> addCommands ( array ( new Command\\DatabaseCreateCommand ( $store , $doctrineHelper ), new Command\\DatabaseDropCommand ( $store , $doctrineHelper ), new Command\\ProjectionCreateCommand ( $projectionRepository ), new Command\\ProjectionDropCommand ( $projectionRepository ), new Command\\ProjectionRebuildCommand ( $store , $projectionRepository ), new Command\\SchemaCreateCommand ( $store , $schemaManager ), new Command\\SchemaDropCommand ( $store , $schemaManager ), new Command\\SchemaUpdateCommand ( $store , $schemaManager ), )); $cli -> run (); Note You can also register doctrine migration commands, see the store documentation for this.","title":"CLI example"},{"location":"clock/","text":"Clock We have a Clock interface which enables you to replace the actual clock implementation in your services for testing purposes. We are using this clock to create the recorded_on datetime for the events. Note The Clock interface is PSR-20 compatible. For more information see here . SystemClock This uses the native system clock to return the DateTimeImmutable instance - in this case new DateTimeImmutable() . use Patchlevel\\EventSourcing\\Clock\\SystemClock ; $clock = new SystemClock (); $date = $clock -> now (); // get the actual datetime $date2 = $clock -> now (); $date == $date2 // false $date === $date2 // false FrozenClock This implementation should only be used for the tests. This enables you to freeze the time and with that to have deterministic tests. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $date = new DateTimeImmutable (); $clock = new FrozenClock ( $date ); $frozenDate = $clock -> now (); // gets the date provided before $date == $frozenDate // true $date === $frozenDate // false The FrozenClock can also be updated with a new date, so you can test a jump in time. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $firstDate = new DateTimeImmutable (); $clock = new FrozenClock ( $firstDate ); $secondDate = new DateTimeImmutable (); $clock -> update ( $secondDate ); $frozenDate = $clock -> now (); $firstDate == $frozenDate // false $secondDate == $frozenDate // true Note The instance of the frozen datetime will be cloned internally, so the it's not the same instance but equals.","title":"Time / Clock"},{"location":"clock/#clock","text":"We have a Clock interface which enables you to replace the actual clock implementation in your services for testing purposes. We are using this clock to create the recorded_on datetime for the events. Note The Clock interface is PSR-20 compatible. For more information see here .","title":"Clock"},{"location":"clock/#systemclock","text":"This uses the native system clock to return the DateTimeImmutable instance - in this case new DateTimeImmutable() . use Patchlevel\\EventSourcing\\Clock\\SystemClock ; $clock = new SystemClock (); $date = $clock -> now (); // get the actual datetime $date2 = $clock -> now (); $date == $date2 // false $date === $date2 // false","title":"SystemClock"},{"location":"clock/#frozenclock","text":"This implementation should only be used for the tests. This enables you to freeze the time and with that to have deterministic tests. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $date = new DateTimeImmutable (); $clock = new FrozenClock ( $date ); $frozenDate = $clock -> now (); // gets the date provided before $date == $frozenDate // true $date === $frozenDate // false The FrozenClock can also be updated with a new date, so you can test a jump in time. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $firstDate = new DateTimeImmutable (); $clock = new FrozenClock ( $firstDate ); $secondDate = new DateTimeImmutable (); $clock -> update ( $secondDate ); $frozenDate = $clock -> now (); $firstDate == $frozenDate // false $secondDate == $frozenDate // true Note The instance of the frozen datetime will be cloned internally, so the it's not the same instance but equals.","title":"FrozenClock"},{"location":"event_bus/","text":"Event Bus This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event wrapped in a message will be dispatched to the event bus . All listeners are then called for each event/message. Message A Message contains the event and related meta information such as the aggregate class and id. A message contains the following information: aggregate class aggregate id playhead event recorded on custom headers Each event is packed into a message and dispatched using the event bus. use Patchlevel\\EventSourcing\\Clock\\SystemClock ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $clock = SystemClock (); $message = Message :: create ( new NameChanged ( 'foo' )) -> withAggregateClass ( Profile :: class ) -> withAggregateId ( 'bca7576c-536f-4428-b694-7b1f00c714b7' ) -> withPlayhead ( 2 ) -> withRecordedOn ( $clock -> now ()); $eventBus -> dispatch ( $message ); Note The message object is immutable. You don't have to create the message yourself, it is automatically created, saved and dispatched in the repository . Custom headers You can also enrich your own header or metadata information. This information is then accessible in the message object and is also stored in the database. use Patchlevel\\EventSourcing\\EventBus\\Message ; $message = Message :: create ( new NameChanged ( 'foo' )) // ... -> withCustomHeader ( 'application-id' , 'app' ); Note You can read about how to pass additional headers to the message object in the message decorator docs. You can also access your custom headers. use Patchlevel\\EventSourcing\\EventBus\\Message ; $message -> customHeader ( 'application-id' ); // app $message -> customHeaders (); // ['application-id' => 'app'] Event Bus Default event bus The library also delivers a light-weight event bus. This can only register listener and dispatch events. use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; $eventBus = new DefaultEventBus (); $eventBus -> addListener ( $mailListener ); $eventBus -> addListener ( $projectionListener ); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Symfony event bus You can also use the symfony message bus which is much more powerful. To use the optional symfony messenger you first have to install the packet. composer require symfony/messenger You can either let us build it with the create factory: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $eventBus = SymfonyEventBus :: create ([ $mailListener , $projectionListener ]); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Or plug it together by hand: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $symfonyMessenger = //... $eventBus = new SymfonyEventBus ( $symfonyMessenger ); Warning You can't mix it with a command bus. You should create a new bus for it. Note An event bus can have zero or more listeners on an event. You should allow no handler in the HandleMessageMiddleware . Listener A listener must implement the Listener interface and define the __invoke method. This listener is then called for all saved events / messages. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $listener = new class implements Listener { public function __invoke ( Message $message ) : void { if ( $message -> event () instanceof ProfileCreated ) { echo 'Welcome!' ; } } } Warning If you only want to listen to certain messages, then you have to check it in the __invoke method. Note Basically, listeners can be categorized according to their tasks. We have a processor and projections .","title":"Event Bus"},{"location":"event_bus/#event-bus","text":"This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event wrapped in a message will be dispatched to the event bus . All listeners are then called for each event/message.","title":"Event Bus"},{"location":"event_bus/#message","text":"A Message contains the event and related meta information such as the aggregate class and id. A message contains the following information: aggregate class aggregate id playhead event recorded on custom headers Each event is packed into a message and dispatched using the event bus. use Patchlevel\\EventSourcing\\Clock\\SystemClock ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $clock = SystemClock (); $message = Message :: create ( new NameChanged ( 'foo' )) -> withAggregateClass ( Profile :: class ) -> withAggregateId ( 'bca7576c-536f-4428-b694-7b1f00c714b7' ) -> withPlayhead ( 2 ) -> withRecordedOn ( $clock -> now ()); $eventBus -> dispatch ( $message ); Note The message object is immutable. You don't have to create the message yourself, it is automatically created, saved and dispatched in the repository .","title":"Message"},{"location":"event_bus/#custom-headers","text":"You can also enrich your own header or metadata information. This information is then accessible in the message object and is also stored in the database. use Patchlevel\\EventSourcing\\EventBus\\Message ; $message = Message :: create ( new NameChanged ( 'foo' )) // ... -> withCustomHeader ( 'application-id' , 'app' ); Note You can read about how to pass additional headers to the message object in the message decorator docs. You can also access your custom headers. use Patchlevel\\EventSourcing\\EventBus\\Message ; $message -> customHeader ( 'application-id' ); // app $message -> customHeaders (); // ['application-id' => 'app']","title":"Custom headers"},{"location":"event_bus/#event-bus_1","text":"","title":"Event Bus"},{"location":"event_bus/#default-event-bus","text":"The library also delivers a light-weight event bus. This can only register listener and dispatch events. use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; $eventBus = new DefaultEventBus (); $eventBus -> addListener ( $mailListener ); $eventBus -> addListener ( $projectionListener ); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections .","title":"Default event bus"},{"location":"event_bus/#symfony-event-bus","text":"You can also use the symfony message bus which is much more powerful. To use the optional symfony messenger you first have to install the packet. composer require symfony/messenger You can either let us build it with the create factory: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $eventBus = SymfonyEventBus :: create ([ $mailListener , $projectionListener ]); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Or plug it together by hand: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $symfonyMessenger = //... $eventBus = new SymfonyEventBus ( $symfonyMessenger ); Warning You can't mix it with a command bus. You should create a new bus for it. Note An event bus can have zero or more listeners on an event. You should allow no handler in the HandleMessageMiddleware .","title":"Symfony event bus"},{"location":"event_bus/#listener","text":"A listener must implement the Listener interface and define the __invoke method. This listener is then called for all saved events / messages. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $listener = new class implements Listener { public function __invoke ( Message $message ) : void { if ( $message -> event () instanceof ProfileCreated ) { echo 'Welcome!' ; } } } Warning If you only want to listen to certain messages, then you have to check it in the __invoke method. Note Basically, listeners can be categorized according to their tasks. We have a processor and projections .","title":"Listener"},{"location":"events/","text":"Events Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values. To register an event you have to set the Event attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name. use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event(name: 'profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Warning The payload must be serializable and unserializable as json. Tip An event should be named in the past because it has already happened. Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples: profile.created profile.name_changed hotel.guest_checked_out Serializer So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a DefaultEventSerializer that can be given further instructions using attributes. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain' ]); The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later. Normalizer Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name , #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $changedAt ) {} } Note You can find out more about normalizer here . Event Registry The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = new EventRegistry ([ 'profile.created' => ProfileCreated :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeEventRegistryFactory is used. There, with the help of paths, all classes with the attribute Event are searched for and the EventRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Events"},{"location":"events/#events","text":"Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values. To register an event you have to set the Event attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name. use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event(name: 'profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Warning The payload must be serializable and unserializable as json. Tip An event should be named in the past because it has already happened. Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples: profile.created profile.name_changed hotel.guest_checked_out","title":"Events"},{"location":"events/#serializer","text":"So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a DefaultEventSerializer that can be given further instructions using attributes. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain' ]); The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later.","title":"Serializer"},{"location":"events/#normalizer","text":"Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name , #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $changedAt ) {} } Note You can find out more about normalizer here .","title":"Normalizer"},{"location":"events/#event-registry","text":"The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = new EventRegistry ([ 'profile.created' => ProfileCreated :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeEventRegistryFactory is used. There, with the help of paths, all classes with the attribute Event are searched for and the EventRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Event Registry"},{"location":"getting_started/","text":"Getting Started In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. Define some events First we define the events that happen in our system. A hotel can be created with a name and a id : #[Event('hotel.created')] final class HotelCreated { public function __construct ( public readonly string $hotelId , public readonly string $hotelName ) { } } A guest can check in by name : #[Event('hotel.guest_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: #[Event('hotel.guest_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Note You can find out more about events here . Define aggregates Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('hotel')] final class Hotel extends AggregateRoot { private string $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( string $id , string $hotelName ) : static { $self = new static (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( $guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> hotelId ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id ; } } Note You can find out more about aggregates here . Define projections So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class HotelProjection implements Projector { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } /** * @return list<array{id: string, name: string, guests: int}> */ public function getHotels () : array { return $this -> db -> fetchAllAssociative ( 'SELECT id, name, guests FROM hotel;' ) } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $event = $message -> event (); $this -> db -> insert ( 'hotel' , [ 'id' => $event -> hotelId , 'name' => $event -> hotelName , 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Note You can find out more about projections here . Processor In our example we also want to send an email to the head office as soon as a guest is checked in. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendCheckInEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $this -> mailer -> send ( 'hq@patchlevel.de' , 'Guest is checked in' , sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ) ); } } Note You can find out more about processor here . Configuration After we have defined everything, we still have to plug the whole thing together: use Doctrine\\DBAL\\DriverManager ; use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\Projector\\SyncProjectorListener ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $mailer = /* your own mailer */ ; $hotelProjection = new HotelProjection ( $connection ); $projectorRepository = new ProjectorRepository ([ $hotelProjection , ]); $eventBus = new DefaultEventBus (); $eventBus -> addListener ( new SyncProjectorListener ( $projectorRepository )); $eventBus -> addListener ( new SendCheckInEmailListener ( $mailer )); $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain/Hotel/Event' ]); $aggregateRegistry = ( new AttributeAggregateRootRegistryFactory ) -> create ([ 'src/Domain/Hotel' ]); $store = new SingleTableStore ( $connection , $serializer , $aggregateRegistry ); $repositoryManager = new DefaultRepositoryManager ( $aggregateRegistry , $store , $eventBus ); $hotelRepository = $repositoryManager -> get ( Hotel :: class ); Note You can find out more about stores here . Database setup So that we can actually write the data to a database, we need the associated schema and databases. use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; use Patchlevel\\EventSourcing\\Projector\\ProjectorHelper ; $schemaDirector = new DoctrineSchemaDirector ( $store , $connection ); $schemaDirector -> create (); ( new ProjectorHelper ()) -> createProjection ( ... $projectorRepository -> projectors ()); Note you can use the predefined cli commands for this. Usage We are now ready to use the Event Sourcing System. We can load, change and save aggregates. $hotel1 = Hotel :: create ( '1' , 'HOTEL' ); $hotel1 -> checkIn ( 'David' ); $hotel1 -> checkIn ( 'Daniel' ); $hotel1 -> checkOut ( 'David' ); $hotelRepository -> save ( $hotel1 ); $hotel2 = $hotelRepository -> load ( '2' ); $hotel2 -> checkIn ( 'David' ); $hotelRepository -> save ( $hotel2 ); $hotels = $hotelProjection -> getHotels (); Note An aggregateId can be an uuid , you can find more about this here . Result Success We have successfully implemented and used event sourcing. Feel free to browse further in the documentation for more detailed information. If there are still open questions, create a ticket on Github and we will try to help you.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out.","title":"Getting Started"},{"location":"getting_started/#define-some-events","text":"First we define the events that happen in our system. A hotel can be created with a name and a id : #[Event('hotel.created')] final class HotelCreated { public function __construct ( public readonly string $hotelId , public readonly string $hotelName ) { } } A guest can check in by name : #[Event('hotel.guest_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: #[Event('hotel.guest_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Note You can find out more about events here .","title":"Define some events"},{"location":"getting_started/#define-aggregates","text":"Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('hotel')] final class Hotel extends AggregateRoot { private string $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( string $id , string $hotelName ) : static { $self = new static (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( $guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> hotelId ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id ; } } Note You can find out more about aggregates here .","title":"Define aggregates"},{"location":"getting_started/#define-projections","text":"So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class HotelProjection implements Projector { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } /** * @return list<array{id: string, name: string, guests: int}> */ public function getHotels () : array { return $this -> db -> fetchAllAssociative ( 'SELECT id, name, guests FROM hotel;' ) } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $event = $message -> event (); $this -> db -> insert ( 'hotel' , [ 'id' => $event -> hotelId , 'name' => $event -> hotelName , 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Note You can find out more about projections here .","title":"Define projections"},{"location":"getting_started/#processor","text":"In our example we also want to send an email to the head office as soon as a guest is checked in. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendCheckInEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $this -> mailer -> send ( 'hq@patchlevel.de' , 'Guest is checked in' , sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ) ); } } Note You can find out more about processor here .","title":"Processor"},{"location":"getting_started/#configuration","text":"After we have defined everything, we still have to plug the whole thing together: use Doctrine\\DBAL\\DriverManager ; use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\Projector\\SyncProjectorListener ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $mailer = /* your own mailer */ ; $hotelProjection = new HotelProjection ( $connection ); $projectorRepository = new ProjectorRepository ([ $hotelProjection , ]); $eventBus = new DefaultEventBus (); $eventBus -> addListener ( new SyncProjectorListener ( $projectorRepository )); $eventBus -> addListener ( new SendCheckInEmailListener ( $mailer )); $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain/Hotel/Event' ]); $aggregateRegistry = ( new AttributeAggregateRootRegistryFactory ) -> create ([ 'src/Domain/Hotel' ]); $store = new SingleTableStore ( $connection , $serializer , $aggregateRegistry ); $repositoryManager = new DefaultRepositoryManager ( $aggregateRegistry , $store , $eventBus ); $hotelRepository = $repositoryManager -> get ( Hotel :: class ); Note You can find out more about stores here .","title":"Configuration"},{"location":"getting_started/#database-setup","text":"So that we can actually write the data to a database, we need the associated schema and databases. use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; use Patchlevel\\EventSourcing\\Projector\\ProjectorHelper ; $schemaDirector = new DoctrineSchemaDirector ( $store , $connection ); $schemaDirector -> create (); ( new ProjectorHelper ()) -> createProjection ( ... $projectorRepository -> projectors ()); Note you can use the predefined cli commands for this.","title":"Database setup"},{"location":"getting_started/#usage","text":"We are now ready to use the Event Sourcing System. We can load, change and save aggregates. $hotel1 = Hotel :: create ( '1' , 'HOTEL' ); $hotel1 -> checkIn ( 'David' ); $hotel1 -> checkIn ( 'Daniel' ); $hotel1 -> checkOut ( 'David' ); $hotelRepository -> save ( $hotel1 ); $hotel2 = $hotelRepository -> load ( '2' ); $hotel2 -> checkIn ( 'David' ); $hotelRepository -> save ( $hotel2 ); $hotels = $hotelProjection -> getHotels (); Note An aggregateId can be an uuid , you can find more about this here .","title":"Usage"},{"location":"getting_started/#result","text":"Success We have successfully implemented and used event sourcing. Feel free to browse further in the documentation for more detailed information. If there are still open questions, create a ticket on Github and we will try to help you.","title":"Result"},{"location":"message_decorator/","text":"Message Decorator There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With MessageDecorator we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on. Create own decorator You can also use this feature to add your own metadata to your events. For this the have an extra methods on Message to add data withCustomHeader and to read this data later on customHeader . use Patchlevel\\EventSourcing\\EventBus\\Message ; final class OnSystemRecordedDecorator implements MessageDecorator { public function __invoke ( Message $message ) : Message { return $message -> withCustomHeader ( 'system' , 'accounting_system' ); } } Note The Message is immutable, for more information look up here . Tip You can also set multiple headers with withCustomHeaders which expects an hashmap. Use own decorator To use your own message decorator, you have to pass it to the DefaultRepositoryManager . use Patchlevel\\EventSourcing\\EventBus\\Decorator\\ChainMessageDecorator ; use Patchlevel\\EventSourcing\\EventBus\\Decorator\\RecordedOnDecorator ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $decorator = new ChainMessageDecorator ([ new RecordedOnDecorator ( $clock ), new OnSystemRecordedDecorator () ]); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , null , $decorator ); $repository = $repositoryManager -> get ( Profile :: class ); Warning We also use the decorator to fill in the recordedOn time. If you want to add your own decorator, then you need to make sure to add the RecordedOnDecorator as well. You can e.g. solve with the ChainMessageDecorator . Note You can find out more about repository here .","title":"Message Decorator"},{"location":"message_decorator/#message-decorator","text":"There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With MessageDecorator we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on.","title":"Message Decorator"},{"location":"message_decorator/#create-own-decorator","text":"You can also use this feature to add your own metadata to your events. For this the have an extra methods on Message to add data withCustomHeader and to read this data later on customHeader . use Patchlevel\\EventSourcing\\EventBus\\Message ; final class OnSystemRecordedDecorator implements MessageDecorator { public function __invoke ( Message $message ) : Message { return $message -> withCustomHeader ( 'system' , 'accounting_system' ); } } Note The Message is immutable, for more information look up here . Tip You can also set multiple headers with withCustomHeaders which expects an hashmap.","title":"Create own decorator"},{"location":"message_decorator/#use-own-decorator","text":"To use your own message decorator, you have to pass it to the DefaultRepositoryManager . use Patchlevel\\EventSourcing\\EventBus\\Decorator\\ChainMessageDecorator ; use Patchlevel\\EventSourcing\\EventBus\\Decorator\\RecordedOnDecorator ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $decorator = new ChainMessageDecorator ([ new RecordedOnDecorator ( $clock ), new OnSystemRecordedDecorator () ]); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , null , $decorator ); $repository = $repositoryManager -> get ( Profile :: class ); Warning We also use the decorator to fill in the recordedOn time. If you want to add your own decorator, then you need to make sure to add the RecordedOnDecorator as well. You can e.g. solve with the ChainMessageDecorator . Note You can find out more about repository here .","title":"Use own decorator"},{"location":"migration/","text":"Migration You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. Warning To use the migration CLI commands, you have to configure the CLI beforehand. Installation In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations Configure Migration Schema Provider We have added a schema provider for doctrine migrations so that you just have to plug the whole thing together. use Patchlevel\\EventSourcing\\Schema\\DoctrineMigrationSchemaProvider ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $schemaDirector = new DoctrineSchemaDirector ( $store , $connection ); $schemaProvider = new DoctrineMigrationSchemaProvider ( $schemaDirector ); CLI example You can plug this together, for example, as follows to create CLI applications like cli.php : use Doctrine\\DBAL\\DriverManager ; use Doctrine\\Migrations\\DependencyFactory ; use Doctrine\\Migrations\\Configuration\\Migration\\PhpFile ; use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection ; use Doctrine\\Migrations\\Tools\\Console\\Command ; use Symfony\\Component\\Console\\Application ; use Patchlevel\\EventSourcing\\Schema\\DoctrineMigrationSchemaProvider ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $config = new PhpFile ( 'migrations.php' ); $dependencyFactory = DependencyFactory :: fromConnection ( $config , new ExistingConnection ( $connection ) ); $schemaDirector = new DoctrineSchemaDirector ( $store , $connection ); $dependencyFactory -> setService ( SchemaProvider :: class , new DoctrineMigrationSchemaProvider ( $schemaDirector ) ); $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $cli -> addCommands ([ // other cli commands new Command\\ExecuteCommand ( $dependencyFactory , 'event-sourcing:migrations:execute' ), new Command\\GenerateCommand ( $dependencyFactory , 'event-sourcing:migrations:generate' ), new Command\\LatestCommand ( $dependencyFactory , 'event-sourcing:migrations:latest' ), new Command\\ListCommand ( $dependencyFactory , 'event-sourcing:migrations:list' ), new Command\\MigrateCommand ( $dependencyFactory , 'event-sourcing:migrations:migrate' ), new Command\\DiffCommand ( $dependencyFactory , 'event-sourcing:migrations:diff' ), new Command\\StatusCommand ( $dependencyFactory , 'event-sourcing:migrations:status' ), new Command\\VersionCommand ( $dependencyFactory , 'event-sourcing:migrations:version' ), ]); $cli -> run (); Note Here you can find more information on how to configure doctrine migration . Migration commands There are some commands to use the migration feature. ExecuteCommand: event-sourcing:migrations:execute GenerateCommand: event-sourcing:migrations:generate LatestCommand: event-sourcing:migrations:latest ListCommand: event-sourcing:migrations:list MigrateCommand: event-sourcing:migrations:migrate DiffCommand: event-sourcing:migrations:diff StatusCommand: event-sourcing:migrations:status VersionCommand: event-sourcing:migrations:version","title":"Schema Migration"},{"location":"migration/#migration","text":"You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. Warning To use the migration CLI commands, you have to configure the CLI beforehand.","title":"Migration"},{"location":"migration/#installation","text":"In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations","title":"Installation"},{"location":"migration/#configure-migration-schema-provider","text":"We have added a schema provider for doctrine migrations so that you just have to plug the whole thing together. use Patchlevel\\EventSourcing\\Schema\\DoctrineMigrationSchemaProvider ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $schemaDirector = new DoctrineSchemaDirector ( $store , $connection ); $schemaProvider = new DoctrineMigrationSchemaProvider ( $schemaDirector );","title":"Configure Migration Schema Provider"},{"location":"migration/#cli-example","text":"You can plug this together, for example, as follows to create CLI applications like cli.php : use Doctrine\\DBAL\\DriverManager ; use Doctrine\\Migrations\\DependencyFactory ; use Doctrine\\Migrations\\Configuration\\Migration\\PhpFile ; use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection ; use Doctrine\\Migrations\\Tools\\Console\\Command ; use Symfony\\Component\\Console\\Application ; use Patchlevel\\EventSourcing\\Schema\\DoctrineMigrationSchemaProvider ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $config = new PhpFile ( 'migrations.php' ); $dependencyFactory = DependencyFactory :: fromConnection ( $config , new ExistingConnection ( $connection ) ); $schemaDirector = new DoctrineSchemaDirector ( $store , $connection ); $dependencyFactory -> setService ( SchemaProvider :: class , new DoctrineMigrationSchemaProvider ( $schemaDirector ) ); $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $cli -> addCommands ([ // other cli commands new Command\\ExecuteCommand ( $dependencyFactory , 'event-sourcing:migrations:execute' ), new Command\\GenerateCommand ( $dependencyFactory , 'event-sourcing:migrations:generate' ), new Command\\LatestCommand ( $dependencyFactory , 'event-sourcing:migrations:latest' ), new Command\\ListCommand ( $dependencyFactory , 'event-sourcing:migrations:list' ), new Command\\MigrateCommand ( $dependencyFactory , 'event-sourcing:migrations:migrate' ), new Command\\DiffCommand ( $dependencyFactory , 'event-sourcing:migrations:diff' ), new Command\\StatusCommand ( $dependencyFactory , 'event-sourcing:migrations:status' ), new Command\\VersionCommand ( $dependencyFactory , 'event-sourcing:migrations:version' ), ]); $cli -> run (); Note Here you can find more information on how to configure doctrine migration .","title":"CLI example"},{"location":"migration/#migration-commands","text":"There are some commands to use the migration feature. ExecuteCommand: event-sourcing:migrations:execute GenerateCommand: event-sourcing:migrations:generate LatestCommand: event-sourcing:migrations:latest ListCommand: event-sourcing:migrations:list MigrateCommand: event-sourcing:migrations:migrate DiffCommand: event-sourcing:migrations:diff StatusCommand: event-sourcing:migrations:status VersionCommand: event-sourcing:migrations:version","title":"Migration commands"},{"location":"normalizer/","text":"Normalizer Sometimes you also want to add more complex data in events as payload or in aggregates for the snapshots. For example DateTime, enums or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. Usage You have to set the normalizer to the properties using the normalize attribute. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer())] public DateTimeImmutable $date ; } The whole thing also works with property promotion. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { public function __construct ( #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $date ) {} } Event For the event, the properties are normalized to a payload and saved in the DB at the end. The whole thing is then loaded again from the DB and denormalized in the properties. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Event('hotel.create')] final class CreateHotel { public function __construct ( public readonly string $name , #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $createAt ) {} } Aggregate For the aggregates it is very similar to the events. However, the normalizer is only used for the snapshots. Here you can determine how the aggregate is saved in the snapshot store at the end. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Aggregate('hotel')] #[Snapshot('default')] final class Hotel extends AggregateRoot { private string $name , #[Normalize(new DateTimeImmutableNormalizer())] private DateTimeImmutable $createAt // ... } Note You can learn more about snapshots here . Built-in Normalizer For some the standard cases we already offer built-in normalizers. Array If you have a list of objects that you want to normalize, then you must normalize each object individually. That's what the ArrayNormalizer does for you. In order to use the ArrayNormaliser , you still have to specify which normaliser should be applied to the individual objects. Internally, it basically does an array_map and then runs the specified normalizer on each element. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\ArrayNormalizer ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new ArrayNormalizer(new DateTimeImmutableNormalizer()))] public array $dates ; } Note The keys from the arrays are taken over here. To save yourself this nesting, you can set the flag list on the Normalize attribute. In the background, your defined normalizer is then wrapped with the ArrayNormalizer . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer(), list: true)] public array $dates ; } DateTimeImmutable With the DateTimeImmutable Normalizer, as the name suggests, you can convert DateTimeImmutable objects to a String and back again. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer())] public DateTimeImmutable $date ; } You can also define the format. Either describe it yourself as a string or use one of the existing constants. The default is DateTimeImmutable::ATOM . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer(format: DateTimeImmutable::RFC3339_EXTENDED))] public DateTimeImmutable $date ; } Note You can read about how the format is structured in the php docs . DateTime The DateTime Normalizer works exactly like the DateTimeNormalizer. Only for DateTime objects. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeNormalizer ; final class DTO { #[Normalize(new DateTimeNormalizer())] public DateTime $date ; } You can also specify the format here. The default is DateTime::ATOM . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeNormalizer ; final class DTO { #[Normalize(new DateTimeNormalizer(format: DateTime::RFC3339_EXTENDED))] public DateTime $date ; } Warning It is highly recommended to only ever use DateTimeImmutable objects and the DateTimeImmutableNormalizer. This prevents you from accidentally changing the state of the DateTime and thereby causing bugs. Note You can read about how the format is structured in the php docs . DateTimeZone To normalize a DateTimeZone one can use the DateTimeZoneNormalizer . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeZoneNormalizer ; final class DTO { #[Normalize(new DateTimeZoneNormalizer())] public DateTimeZone $timeZone ; } Enum Backed enums can also be normalized. For this, the enum FQCN must also be pass so that the EnumNormalizer knows which enum it is. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\EnumNormalizer ; final class DTO { #[Normalize(new EnumNormalizer(Status::class))] public Status $status ; } Custom Normalizer Since we only offer normalizers for PHP native things, you have to write your own normalizers for your own structures, such as value objects. In our example we have built a value object that should hold a name. final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } For this we now need a custom normalizer. This normalizer must implement the Normalizer interface. You also need to implement a normalize and denormalize method. The important thing is that the result of Normalize is serializable. use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\Normalizer ; class NameNormalizer implements Normalizer { public function normalize ( mixed $value ) : string { if ( ! $value instanceof Name ) { throw new InvalidArgumentException (); } return $value -> toString (); } public function denormalize ( mixed $value ) : ? Name { if ( $value === null ) { return null ; } if ( ! is_string ( $value )) { throw new InvalidArgumentException (); } return new Name ( $value ); } } Now we can also use the normalizer directly by passing it to the Normalize attribute. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; final class DTO { #[Normalize(new NameNormalizer())] public Name $name } Tip Every normalizer, including the custom normalizer, can be used both for the events and for the snapshots. Normalized Name By default, the property name is used to name the field in the normalized result. This can be customized with the NormalizedName attribute. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\NormalizedName ; final class DTO { #[NormalizedName('profile_name')] public string $name } The whole thing looks like this [ 'profile_name' : 'David' ] Tip You can also rename properties to events without having a backwards compatibility break by keeping the serialized name. Note NormalizedName also works for snapshots. But since a snapshot is just a cache, you can also just invalidate it, if you have backwards compatibility break in the property name","title":"Normalizer"},{"location":"normalizer/#normalizer","text":"Sometimes you also want to add more complex data in events as payload or in aggregates for the snapshots. For example DateTime, enums or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again.","title":"Normalizer"},{"location":"normalizer/#usage","text":"You have to set the normalizer to the properties using the normalize attribute. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer())] public DateTimeImmutable $date ; } The whole thing also works with property promotion. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { public function __construct ( #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $date ) {} }","title":"Usage"},{"location":"normalizer/#event","text":"For the event, the properties are normalized to a payload and saved in the DB at the end. The whole thing is then loaded again from the DB and denormalized in the properties. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Event('hotel.create')] final class CreateHotel { public function __construct ( public readonly string $name , #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $createAt ) {} }","title":"Event"},{"location":"normalizer/#aggregate","text":"For the aggregates it is very similar to the events. However, the normalizer is only used for the snapshots. Here you can determine how the aggregate is saved in the snapshot store at the end. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Aggregate('hotel')] #[Snapshot('default')] final class Hotel extends AggregateRoot { private string $name , #[Normalize(new DateTimeImmutableNormalizer())] private DateTimeImmutable $createAt // ... } Note You can learn more about snapshots here .","title":"Aggregate"},{"location":"normalizer/#built-in-normalizer","text":"For some the standard cases we already offer built-in normalizers.","title":"Built-in Normalizer"},{"location":"normalizer/#array","text":"If you have a list of objects that you want to normalize, then you must normalize each object individually. That's what the ArrayNormalizer does for you. In order to use the ArrayNormaliser , you still have to specify which normaliser should be applied to the individual objects. Internally, it basically does an array_map and then runs the specified normalizer on each element. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\ArrayNormalizer ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new ArrayNormalizer(new DateTimeImmutableNormalizer()))] public array $dates ; } Note The keys from the arrays are taken over here. To save yourself this nesting, you can set the flag list on the Normalize attribute. In the background, your defined normalizer is then wrapped with the ArrayNormalizer . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer(), list: true)] public array $dates ; }","title":"Array"},{"location":"normalizer/#datetimeimmutable","text":"With the DateTimeImmutable Normalizer, as the name suggests, you can convert DateTimeImmutable objects to a String and back again. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer())] public DateTimeImmutable $date ; } You can also define the format. Either describe it yourself as a string or use one of the existing constants. The default is DateTimeImmutable::ATOM . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; final class DTO { #[Normalize(new DateTimeImmutableNormalizer(format: DateTimeImmutable::RFC3339_EXTENDED))] public DateTimeImmutable $date ; } Note You can read about how the format is structured in the php docs .","title":"DateTimeImmutable"},{"location":"normalizer/#datetime","text":"The DateTime Normalizer works exactly like the DateTimeNormalizer. Only for DateTime objects. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeNormalizer ; final class DTO { #[Normalize(new DateTimeNormalizer())] public DateTime $date ; } You can also specify the format here. The default is DateTime::ATOM . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeNormalizer ; final class DTO { #[Normalize(new DateTimeNormalizer(format: DateTime::RFC3339_EXTENDED))] public DateTime $date ; } Warning It is highly recommended to only ever use DateTimeImmutable objects and the DateTimeImmutableNormalizer. This prevents you from accidentally changing the state of the DateTime and thereby causing bugs. Note You can read about how the format is structured in the php docs .","title":"DateTime"},{"location":"normalizer/#datetimezone","text":"To normalize a DateTimeZone one can use the DateTimeZoneNormalizer . use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeZoneNormalizer ; final class DTO { #[Normalize(new DateTimeZoneNormalizer())] public DateTimeZone $timeZone ; }","title":"DateTimeZone"},{"location":"normalizer/#enum","text":"Backed enums can also be normalized. For this, the enum FQCN must also be pass so that the EnumNormalizer knows which enum it is. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\EnumNormalizer ; final class DTO { #[Normalize(new EnumNormalizer(Status::class))] public Status $status ; }","title":"Enum"},{"location":"normalizer/#custom-normalizer","text":"Since we only offer normalizers for PHP native things, you have to write your own normalizers for your own structures, such as value objects. In our example we have built a value object that should hold a name. final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } For this we now need a custom normalizer. This normalizer must implement the Normalizer interface. You also need to implement a normalize and denormalize method. The important thing is that the result of Normalize is serializable. use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\Normalizer ; class NameNormalizer implements Normalizer { public function normalize ( mixed $value ) : string { if ( ! $value instanceof Name ) { throw new InvalidArgumentException (); } return $value -> toString (); } public function denormalize ( mixed $value ) : ? Name { if ( $value === null ) { return null ; } if ( ! is_string ( $value )) { throw new InvalidArgumentException (); } return new Name ( $value ); } } Now we can also use the normalizer directly by passing it to the Normalize attribute. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; final class DTO { #[Normalize(new NameNormalizer())] public Name $name } Tip Every normalizer, including the custom normalizer, can be used both for the events and for the snapshots.","title":"Custom Normalizer"},{"location":"normalizer/#normalized-name","text":"By default, the property name is used to name the field in the normalized result. This can be customized with the NormalizedName attribute. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\NormalizedName ; final class DTO { #[NormalizedName('profile_name')] public string $name } The whole thing looks like this [ 'profile_name' : 'David' ] Tip You can also rename properties to events without having a backwards compatibility break by keeping the serialized name. Note NormalizedName also works for snapshots. But since a snapshot is just a cache, you can also just invalidate it, if you have backwards compatibility break in the property name","title":"Normalized Name"},{"location":"outbox/","text":"Outbox There is the problem that errors can occur when saving an aggregate or in the individual event listeners. This means that you either saved an aggregate, but an error occurred in the email listener, so that no email went out. Or that an email was sent but the aggregate could not be saved. Both cases are very bad and can only be solved if both the saving of an aggregate and the dispatching of the events are in a transaction. The best way to ensure this is to store the events to be dispatched together with the aggregate in a transaction in the same database. After the transaction becomes successful, the events can be loaded from the outbox table with a worker and then dispatched into the correct event bus. As soon as the events have been dispatched, they are deleted from the outbox table. If an error occurs when dispatching, the whole thing will be retrieved later. Configuration First you have to replace the correct event bus with an outbox event bus. This stores the events to be dispatched in the database. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Outbox\\OutboxEventBus ; $outboxEventBus = new OutboxEventBus ( $store ); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $outboxEventBus ); And then you have to define the consumer. This gets the right event bus. It is used to load the events to be dispatched from the database, dispatch the events and then empty the outbox table. $consumer = new StoreOutboxConsumer ( $store , $realEventBus ); $consumer -> consume (); Using outbox So that this is also executed in a transaction, you have to make sure that a transaction has also been started. $store -> transactional ( function () use ( $command , $profileRepository ) { $profile = Profile :: register ( $command -> id (), $command -> email () ); $profileRepository -> save ( $profile ); }); Note You can find out more about transaction here . You can also interact directly with the outbox store. $store -> saveOutboxMessage ( $message ); $store -> markOutboxMessageConsumed ( $message ); $store -> retrieveOutboxMessages (); $store -> countOutboxMessages () Note Both single table store and multi table store implement the outbox store. Tip Interacting with the outbox store is also possible via the cli .","title":"Outbox"},{"location":"outbox/#outbox","text":"There is the problem that errors can occur when saving an aggregate or in the individual event listeners. This means that you either saved an aggregate, but an error occurred in the email listener, so that no email went out. Or that an email was sent but the aggregate could not be saved. Both cases are very bad and can only be solved if both the saving of an aggregate and the dispatching of the events are in a transaction. The best way to ensure this is to store the events to be dispatched together with the aggregate in a transaction in the same database. After the transaction becomes successful, the events can be loaded from the outbox table with a worker and then dispatched into the correct event bus. As soon as the events have been dispatched, they are deleted from the outbox table. If an error occurs when dispatching, the whole thing will be retrieved later.","title":"Outbox"},{"location":"outbox/#configuration","text":"First you have to replace the correct event bus with an outbox event bus. This stores the events to be dispatched in the database. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Outbox\\OutboxEventBus ; $outboxEventBus = new OutboxEventBus ( $store ); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $outboxEventBus ); And then you have to define the consumer. This gets the right event bus. It is used to load the events to be dispatched from the database, dispatch the events and then empty the outbox table. $consumer = new StoreOutboxConsumer ( $store , $realEventBus ); $consumer -> consume ();","title":"Configuration"},{"location":"outbox/#using-outbox","text":"So that this is also executed in a transaction, you have to make sure that a transaction has also been started. $store -> transactional ( function () use ( $command , $profileRepository ) { $profile = Profile :: register ( $command -> id (), $command -> email () ); $profileRepository -> save ( $profile ); }); Note You can find out more about transaction here . You can also interact directly with the outbox store. $store -> saveOutboxMessage ( $message ); $store -> markOutboxMessageConsumed ( $message ); $store -> retrieveOutboxMessages (); $store -> countOutboxMessages () Note Both single table store and multi table store implement the outbox store. Tip Interacting with the outbox store is also possible via the cli .","title":"Using outbox"},{"location":"pipeline/","text":"Pipeline A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! The pipeline can also be used to create or rebuild a projection: use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $pipeline = new Pipeline ( new StoreSource ( $store ), new ProjectionTarget ( $projection ) ); The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand. Source The first thing you need is a source of where the data should come from. Store The StoreSource is the standard source to load all events from the database. use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; $source = new StoreSource ( $store ); In Memory There is an InMemorySource that receives the messages in an array. This source can be used to write pipeline tests. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource ; $source = new InMemorySource ([ new Message ( Profile :: class , '1' , 1 , new ProfileCreated ( Email :: fromString ( 'david.badura@patchlevel.de' )), ), // ... ]); Custom Source You can also create your own source class. It has to inherit from Source . Here you can, for example, create a migration from another event sourcing system or similar system. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\Source ; $source = new class implements Source { /** * @return Generator<Message> */ public function load () : Generator { yield new Message ( Profile :: class , '1' , 0 , new ProfileCreated ( '1' , [ 'name' => 'David' ]) ); } public function count () : int { reutrn 1 ; } } Target After you have a source, you still need the destination of the pipeline. Store You can use a store to save the final result. use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $target = new StoreTarget ( $store ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline. Projection A projection can also be used as a target. For example, to set up a new projection or to build a new projection. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $target = new ProjectionTarget ( $projection ); Projection Handler If you want to build or create all projections from scratch, then you can also use the ProjectionRepositoryTarget. In this, the individual projections are iterated and the events are then passed on. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionHandlerTarget ; $target = new ProjectionHandlerTarget ( $projectionHandler ); In Memory There is also an in-memory variant for the target. This target can also be used for tests. With the messages method you get all Messages that have reached the target. use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget ; $target = new InMemoryTarget (); // run pipeline $messages = $target -> messages (); Custom Target You can also define your own target. To do this, you need to implement the Target interface. use Patchlevel\\EventSourcing\\EventBus\\Message ; final class OtherStoreTarget implements Target { private OtherStore $store ; public function __construct ( OtherStore $store ) { $this -> store = $store ; } public function save ( Message $message ) : void { $this -> store -> save ( $message ); } } Middlewares Middelwares can be used to manipulate, delete or expand messages or events during the process. Warning It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware. Exclude With this middleware you can exclude certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; $middleware = new ExcludeEventMiddleware ([ EmailChanged :: class ]); Warning After this middleware, the playhead must be recalculated! Include With this middleware you can only allow certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware ; $middleware = new IncludeEventMiddleware ([ ProfileCreated :: class ]); Warning After this middleware, the playhead must be recalculated! Filter If the middlewares ExcludeEventMiddleware and IncludeEventMiddleware are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware ; $middleware = new FilterEventMiddleware ( function ( AggregateChanged $event ) { if ( ! $event instanceof ProfileCreated ) { return true ; } return $event -> allowNewsletter (); }); Warning After this middleware, the playhead must be recalculated! Exclude Archived Events With this middleware you can exclude archived events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeArchivedEventMiddleware ; $middleware = new ExcludeArchivedEventMiddleware (); Warning After this middleware, the playhead must be recalculated! Only Archived Events With this middleware you can only allow archived events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\OnlyArchivedEventMiddleware ; $middleware = new OnlyArchivedEventMiddleware (); Warning After this middleware, the playhead must be recalculated! Replace If you want to replace an event, you can use the ReplaceEventMiddleware . The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; $middleware = new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }); Note The middleware takes over the playhead and recordedAt information. Until A use case could also be that you want to look at the projection from a previous point in time. You can use the UntilEventMiddleware to only allow events that were recorded before this point in time. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ClassRenameMiddleware ; $middleware = new UntilEventMiddleware ( new DateTimeImmutable ( '2020-01-01 12:00:00' )); Warning After this middleware, the playhead must be recalculated! Recalculate playhead This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware RecalculatePlayheadMiddleware can fix this problem. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new RecalculatePlayheadMiddleware (); Note You only need to add this middleware once at the end of the pipeline. Chain If you want to group your middleware, you can use one or more ChainMiddleware . use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new ChainMiddleware ([ new ExcludeEventMiddleware ([ EmailChanged :: class ]), new RecalculatePlayheadMiddleware () ]); Custom middleware You can also write a custom middleware. The middleware gets a message and can return N messages. There are the following possibilities: Return only the message to an array to leave it unchanged. Put another message in the array to swap the message. Return an empty array to remove the message. Or return multiple messages to enrich the stream. In our case, the domain has changed a bit. In the beginning we had a ProfileCreated event that just created a profile. Now we have a ProfileRegistered and a ProfileActivated event, which should replace the ProfileCreated event. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\Middleware ; final class SplitProfileCreatedMiddleware implements Middleware { public function __invoke ( Message $message ) : array { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return [ $message ]; } $profileRegisteredMessage = Message :: createWithHeaders ( new ProfileRegistered ( $event -> id (), $event -> name ()), $message -> headers () ); $profileActivatedMessage = Message :: createWithHeaders ( new ProfileActivated ( $event -> id ()), $message -> headers () ); return [ $profileRegisteredMessage , $profileActivatedMessage ]; } } Warning Since we changed the number of messages, we have to recalculate the playhead. Note You can find more about messages here .","title":"Pipeline"},{"location":"pipeline/#pipeline","text":"A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! The pipeline can also be used to create or rebuild a projection: use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $pipeline = new Pipeline ( new StoreSource ( $store ), new ProjectionTarget ( $projection ) ); The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand.","title":"Pipeline"},{"location":"pipeline/#source","text":"The first thing you need is a source of where the data should come from.","title":"Source"},{"location":"pipeline/#store","text":"The StoreSource is the standard source to load all events from the database. use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; $source = new StoreSource ( $store );","title":"Store"},{"location":"pipeline/#in-memory","text":"There is an InMemorySource that receives the messages in an array. This source can be used to write pipeline tests. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource ; $source = new InMemorySource ([ new Message ( Profile :: class , '1' , 1 , new ProfileCreated ( Email :: fromString ( 'david.badura@patchlevel.de' )), ), // ... ]);","title":"In Memory"},{"location":"pipeline/#custom-source","text":"You can also create your own source class. It has to inherit from Source . Here you can, for example, create a migration from another event sourcing system or similar system. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\Source ; $source = new class implements Source { /** * @return Generator<Message> */ public function load () : Generator { yield new Message ( Profile :: class , '1' , 0 , new ProfileCreated ( '1' , [ 'name' => 'David' ]) ); } public function count () : int { reutrn 1 ; } }","title":"Custom Source"},{"location":"pipeline/#target","text":"After you have a source, you still need the destination of the pipeline.","title":"Target"},{"location":"pipeline/#store_1","text":"You can use a store to save the final result. use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $target = new StoreTarget ( $store ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline.","title":"Store"},{"location":"pipeline/#projection","text":"A projection can also be used as a target. For example, to set up a new projection or to build a new projection. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $target = new ProjectionTarget ( $projection );","title":"Projection"},{"location":"pipeline/#projection-handler","text":"If you want to build or create all projections from scratch, then you can also use the ProjectionRepositoryTarget. In this, the individual projections are iterated and the events are then passed on. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionHandlerTarget ; $target = new ProjectionHandlerTarget ( $projectionHandler );","title":"Projection Handler"},{"location":"pipeline/#in-memory_1","text":"There is also an in-memory variant for the target. This target can also be used for tests. With the messages method you get all Messages that have reached the target. use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget ; $target = new InMemoryTarget (); // run pipeline $messages = $target -> messages ();","title":"In Memory"},{"location":"pipeline/#custom-target","text":"You can also define your own target. To do this, you need to implement the Target interface. use Patchlevel\\EventSourcing\\EventBus\\Message ; final class OtherStoreTarget implements Target { private OtherStore $store ; public function __construct ( OtherStore $store ) { $this -> store = $store ; } public function save ( Message $message ) : void { $this -> store -> save ( $message ); } }","title":"Custom Target"},{"location":"pipeline/#middlewares","text":"Middelwares can be used to manipulate, delete or expand messages or events during the process. Warning It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware.","title":"Middlewares"},{"location":"pipeline/#exclude","text":"With this middleware you can exclude certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; $middleware = new ExcludeEventMiddleware ([ EmailChanged :: class ]); Warning After this middleware, the playhead must be recalculated!","title":"Exclude"},{"location":"pipeline/#include","text":"With this middleware you can only allow certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware ; $middleware = new IncludeEventMiddleware ([ ProfileCreated :: class ]); Warning After this middleware, the playhead must be recalculated!","title":"Include"},{"location":"pipeline/#filter","text":"If the middlewares ExcludeEventMiddleware and IncludeEventMiddleware are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware ; $middleware = new FilterEventMiddleware ( function ( AggregateChanged $event ) { if ( ! $event instanceof ProfileCreated ) { return true ; } return $event -> allowNewsletter (); }); Warning After this middleware, the playhead must be recalculated!","title":"Filter"},{"location":"pipeline/#exclude-archived-events","text":"With this middleware you can exclude archived events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeArchivedEventMiddleware ; $middleware = new ExcludeArchivedEventMiddleware (); Warning After this middleware, the playhead must be recalculated!","title":"Exclude Archived Events"},{"location":"pipeline/#only-archived-events","text":"With this middleware you can only allow archived events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\OnlyArchivedEventMiddleware ; $middleware = new OnlyArchivedEventMiddleware (); Warning After this middleware, the playhead must be recalculated!","title":"Only Archived Events"},{"location":"pipeline/#replace","text":"If you want to replace an event, you can use the ReplaceEventMiddleware . The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; $middleware = new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }); Note The middleware takes over the playhead and recordedAt information.","title":"Replace"},{"location":"pipeline/#until","text":"A use case could also be that you want to look at the projection from a previous point in time. You can use the UntilEventMiddleware to only allow events that were recorded before this point in time. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ClassRenameMiddleware ; $middleware = new UntilEventMiddleware ( new DateTimeImmutable ( '2020-01-01 12:00:00' )); Warning After this middleware, the playhead must be recalculated!","title":"Until"},{"location":"pipeline/#recalculate-playhead","text":"This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware RecalculatePlayheadMiddleware can fix this problem. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new RecalculatePlayheadMiddleware (); Note You only need to add this middleware once at the end of the pipeline.","title":"Recalculate playhead"},{"location":"pipeline/#chain","text":"If you want to group your middleware, you can use one or more ChainMiddleware . use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new ChainMiddleware ([ new ExcludeEventMiddleware ([ EmailChanged :: class ]), new RecalculatePlayheadMiddleware () ]);","title":"Chain"},{"location":"pipeline/#custom-middleware","text":"You can also write a custom middleware. The middleware gets a message and can return N messages. There are the following possibilities: Return only the message to an array to leave it unchanged. Put another message in the array to swap the message. Return an empty array to remove the message. Or return multiple messages to enrich the stream. In our case, the domain has changed a bit. In the beginning we had a ProfileCreated event that just created a profile. Now we have a ProfileRegistered and a ProfileActivated event, which should replace the ProfileCreated event. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\Middleware ; final class SplitProfileCreatedMiddleware implements Middleware { public function __invoke ( Message $message ) : array { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return [ $message ]; } $profileRegisteredMessage = Message :: createWithHeaders ( new ProfileRegistered ( $event -> id (), $event -> name ()), $message -> headers () ); $profileActivatedMessage = Message :: createWithHeaders ( new ProfileActivated ( $event -> id ()), $message -> headers () ); return [ $profileRegisteredMessage , $profileActivatedMessage ]; } } Warning Since we changed the number of messages, we have to recalculate the playhead. Note You can find more about messages here .","title":"Custom middleware"},{"location":"processor/","text":"Processor The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a profile has been created: use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return ; } $this -> mailer -> send ( $event -> email (), 'Profile created' , '...' ); } } Warning If you only want to listen to certain events, then you have to check it in the __invoke method.","title":"Processor"},{"location":"processor/#processor","text":"The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a profile has been created: use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return ; } $this -> mailer -> send ( $event -> email (), 'Profile created' , '...' ); } } Warning If you only want to listen to certain events, then you have to check it in the __invoke method.","title":"Processor"},{"location":"projection/","text":"Projections With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch. Projector To create a projection you need a projector. In this example we always create a new data set in a relational database when a profile is created: use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class ProfileProjection implements Projector { public function __construct ( private readonly Connection $connection ) { } /** * @return list<array{id: string, name: string}> */ public function getProfiles () : array { return $this -> connection -> fetchAllAssociative ( 'SELECT id, name FROM projection_profile;' ); } #[Create] public function create () : void { $this -> connection -> executeStatement ( 'CREATE TABLE IF NOT EXISTS projection_profile (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( 'DROP TABLE IF EXISTS projection_profile;' ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( Message $message ) : void { $profileCreated = $message -> event (); $this -> connection -> executeStatement ( 'INSERT INTO projection_profile (`id`, `name`) VALUES(:id, :name);' , [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } } Projectors can also have one create and drop method that is executed when the projection is created or deleted. In some cases it may be that no schema has to be created for the projection, as the target does it automatically. To do this, you must add either the Create or Drop attribute to the method. The method name itself doesn't matter. Otherwise, a projector can have any number of handle methods that are called for certain defined events. In order to say which method is responsible for which event, you need the Handle attribute. As the first parameter, you must pass the event class to which the reaction should then take place. The method itself must expect a Message , which then contains the event. The method name itself doesn't matter. As soon as the event has been dispatched, the appropriate methods are then executed. Several projectors can also listen to the same event. Danger You should not execute any actions with projectors, otherwise these will be executed again if you rebuild the projection! Tip If you are using psalm then you can install the event sourcing plugin to make the event method return the correct type. Projector Repository The projector repository can hold and make available all projectors. use Patchlevel\\EventSourcing\\Projection\\Projector\\InMemoryProjectorRepository ; $projectorRepository = new InMemoryProjectorRepository ([ new ProfileProjection ( $connection ) ]); Setup Projection A projection schama or database usually has to be created beforehand. And with a rebuild, the projection has to be deleted. The Projector Helper can help with this: Create Projection Schema With this you can prepare the projection: use Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorHelper ; ( new ProjectorHelper ()) -> createProjection ( new ProfileProjection ( $connection )); ( new ProjectorHelper ()) -> createProjection ( ... $projectionRepository -> projectors ()); Drop Projection Schema The projection can also be removed again: use Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorHelper ; ( new ProjectorHelper ()) -> dropProjection ( new ProfileProjection ( $connection )); ( new ProjectorHelper ()) -> dropProjection ( ... $projectionRepository -> projectors ()); Handle Message The helper also offers methods to process messages: use Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorHelper ; ( new ProjectorHelper ()) -> handleMessage ( $message , new ProfileProjection ( $connection )); ( new ProjectorHelper ()) -> handleMessage ( $message , ... $projectionRepository -> projectors ()); Sync Projector Listener The simplest configuration is to run the projectors synchronously. Says that you listen to the event bus and update the projections directly. Here you can use the SyncProjectorListener . use Patchlevel\\EventSourcing\\Projection\\Projector\\SyncProjectorListener ; $eventBus -> addListener ( new SyncProjectorListener ( $projectorRepository ) ); Note You can find out more about the event bus here . Note In order to exploit the full potential, the projectionist should be used in production.","title":"Projection"},{"location":"projection/#projections","text":"With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch.","title":"Projections"},{"location":"projection/#projector","text":"To create a projection you need a projector. In this example we always create a new data set in a relational database when a profile is created: use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class ProfileProjection implements Projector { public function __construct ( private readonly Connection $connection ) { } /** * @return list<array{id: string, name: string}> */ public function getProfiles () : array { return $this -> connection -> fetchAllAssociative ( 'SELECT id, name FROM projection_profile;' ); } #[Create] public function create () : void { $this -> connection -> executeStatement ( 'CREATE TABLE IF NOT EXISTS projection_profile (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( 'DROP TABLE IF EXISTS projection_profile;' ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( Message $message ) : void { $profileCreated = $message -> event (); $this -> connection -> executeStatement ( 'INSERT INTO projection_profile (`id`, `name`) VALUES(:id, :name);' , [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } } Projectors can also have one create and drop method that is executed when the projection is created or deleted. In some cases it may be that no schema has to be created for the projection, as the target does it automatically. To do this, you must add either the Create or Drop attribute to the method. The method name itself doesn't matter. Otherwise, a projector can have any number of handle methods that are called for certain defined events. In order to say which method is responsible for which event, you need the Handle attribute. As the first parameter, you must pass the event class to which the reaction should then take place. The method itself must expect a Message , which then contains the event. The method name itself doesn't matter. As soon as the event has been dispatched, the appropriate methods are then executed. Several projectors can also listen to the same event. Danger You should not execute any actions with projectors, otherwise these will be executed again if you rebuild the projection! Tip If you are using psalm then you can install the event sourcing plugin to make the event method return the correct type.","title":"Projector"},{"location":"projection/#projector-repository","text":"The projector repository can hold and make available all projectors. use Patchlevel\\EventSourcing\\Projection\\Projector\\InMemoryProjectorRepository ; $projectorRepository = new InMemoryProjectorRepository ([ new ProfileProjection ( $connection ) ]);","title":"Projector Repository"},{"location":"projection/#setup-projection","text":"A projection schama or database usually has to be created beforehand. And with a rebuild, the projection has to be deleted. The Projector Helper can help with this:","title":"Setup Projection"},{"location":"projection/#create-projection-schema","text":"With this you can prepare the projection: use Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorHelper ; ( new ProjectorHelper ()) -> createProjection ( new ProfileProjection ( $connection )); ( new ProjectorHelper ()) -> createProjection ( ... $projectionRepository -> projectors ());","title":"Create Projection Schema"},{"location":"projection/#drop-projection-schema","text":"The projection can also be removed again: use Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorHelper ; ( new ProjectorHelper ()) -> dropProjection ( new ProfileProjection ( $connection )); ( new ProjectorHelper ()) -> dropProjection ( ... $projectionRepository -> projectors ());","title":"Drop Projection Schema"},{"location":"projection/#handle-message","text":"The helper also offers methods to process messages: use Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorHelper ; ( new ProjectorHelper ()) -> handleMessage ( $message , new ProfileProjection ( $connection )); ( new ProjectorHelper ()) -> handleMessage ( $message , ... $projectionRepository -> projectors ());","title":"Handle Message"},{"location":"projection/#sync-projector-listener","text":"The simplest configuration is to run the projectors synchronously. Says that you listen to the event bus and update the projections directly. Here you can use the SyncProjectorListener . use Patchlevel\\EventSourcing\\Projection\\Projector\\SyncProjectorListener ; $eventBus -> addListener ( new SyncProjectorListener ( $projectorRepository ) ); Note You can find out more about the event bus here . Note In order to exploit the full potential, the projectionist should be used in production.","title":"Sync Projector Listener"},{"location":"projectionist/","text":"Projectionist The projectionist manages individual projectors and keeps the projections running. Internally, the projectionist does this by tracking where each projection is in the event stream and keeping all projections up to date. He also takes care that new projections are booted and old ones are removed again. If something breaks, the projectionist marks the individual projections as faulty. Note You can find the basics of projections and projectors here Tip The Projectionist was inspired by the following two blog posts: Projection Building Blocks: What you'll need to build projections Managing projectors is harder than you think Versioned Projector So that the projectionist can also assign the projectors to a projection, the interface must be changed from Projector to VersionedProjector . As the name suggests, the projector will also be versionable. In addition, you have to implement the targetProjection method, which returns the target projection id. So that several versions of the projection can exist, the version of the projection should flow into the table or collection name. use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\ProjectionId ; use Patchlevel\\EventSourcing\\Projection\\Projectionist\\VersionedProjector ; final class ProfileProjection implements VersionedProjector { public function __construct ( private readonly Connection $connection ) { } public function targetProjection () : ProjectionId { return new ProjectionId ( name : 'profile' , version : 1 ); } /** * @return list<array{id: string, name: string}> */ public function getProfiles () : array { return $this -> connection -> fetchAllAssociative ( sprintf ( 'SELECT id, name FROM %s;' , $this -> table ()) ); } #[Create] public function create () : void { $this -> connection -> executeStatement ( sprintf ( 'CREATE TABLE IF NOT EXISTS %s (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' , $this -> table () ) ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( sprintf ( 'DROP TABLE IF EXISTS %s;' , $this -> table ()) ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( Message $message ) : void { $profileCreated = $message -> event (); $this -> connection -> executeStatement ( sprintf ( 'INSERT INTO %s (`id`, `name`) VALUES(:id, :name);' , $this -> table ()), [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } private function table () : string { return sprintf ( 'projection_%s_%s' , $this -> targetProjection () -> name (), $this -> targetProjection () -> version () ); } } Projection Id A projection id consists of a unique name and a version. As soon as the projection changes, such as the structure or the data, the version of the projection must be incremented. This tells the projectionist to build an another projection. Projection Position Furthermore, the position in the event stream is noted for each projection. So that the projectionist knows where the projection stopped and must continue. Projection Status There is a lifecycle for each projection. This cycle is tracked by the projectionist. stateDiagram-v2 direction LR [*] --> New New --> Booting Booting --> Active Booting --> Error Active --> Outdated Active --> Error Error --> Active Error --> [*] Outdated --> Active Outdated --> [*] New A projection gets the status new if there is a projector with an unknown projection id. This can happen when either a new projector has been added, the version has changed or the projection has been manually deleted from the projection store. Booting Booting status is reached when the boot process is invoked. Then the new projections are built up in a separate process parallel. As soon as the projection is built up to the current status, the status changes to active. Active The active status describes the projections currently being actively managed by the projectionist. These projections have a projector, follow the event stream and are up to date. Outdated If a projection exists in the projection store that does not have a projector in the source code with a corresponding projection id, then this projection is marked as outdated. This happens when either the projector has been deleted or the projection id of a projector has changed. In the last case there is a new projection. An outdated projection does not automatically become active again when the projection id exists again. This happens, for example, when an old version was deployed again during a rollback. There are two options here: Reactivate the projection. Remove the projection and rebuild it from scratch. Error If an error occurs in a projector, then the target projection is set to Error. This projection will then no longer run until the projection is activated again. There are two options here: Reactivate the projection. Remove the projection and rebuild it from scratch. Setup In order for the projectionist to be able to do its work, you have to assemble it beforehand. Warning The SyncProjectorListener must be removed again so that the events are not processed directly! Projection Store In order for the projectionist to know the status and position of the projections, they must be saved. Currently there is only the Doctrine Store. use Patchlevel\\EventSourcing\\Projection\\Projection\\Store\\DoctrineStore ; $projectionStore = new DoctrineStore ( $connection ); So that the schema for the projection store can also be created, we have to tell the SchemaDirector our schema configuration. Using ChainSchemaConfigurator we can add multiple schema configurators. In our case they need the SchemaConfigurator from the event store and projection store. use Patchlevel\\EventSourcing\\Schema\\ChainSchemaConfigurator ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $schemaDirector = new DoctrineSchemaDirector ( $connection new ChainSchemaConfigurator ([ $eventStore , $projectionStore ]), ); Note You can find more about schema configurator here Projectionist Now we can create the projectionist: use Patchlevel\\EventSourcing\\Projection\\Projectionist\\DefaultProjectionist ; $projectionist = new DefaultProjectionist ( $eventStore , $projectionStore , $projectorRepository ); Usage The Projectionist has a few methods needed to use it effectively. These are explained here: Boot So that the projectionist can manage the projections, they must be booted. In this step, the structures are created for all new projections. The projections then catch up with the current position of the event stream. When the projections are finished, they switch to the active state. $projectionist -> boot (); Run All active projections are continued and updated here. $projectionist -> run (); Teardown If projections are outdated, they can be cleaned up here. The projectionist also tries to remove the structures created for the projection. $projectionist -> teardown (); Remove You can also directly remove a projection regardless of its status. An attempt is made to remove the structures, but the entry will still be removed if it doesn't work. $projectionist -> remove (); Reactivate If a projection had an error, you can reactivate it. As a result, the projection gets the status active again and is then kept up-to-date again by the projectionist. $projectionist -> reactivate (); Projections To get the current status of all projections, you can get them using the projections method. $projections = $projectionist -> projections (); foreach ( $projections as $projection ) { echo $projection -> status (); } Note There are also cli commands for all commands.","title":"Projectionist"},{"location":"projectionist/#projectionist","text":"The projectionist manages individual projectors and keeps the projections running. Internally, the projectionist does this by tracking where each projection is in the event stream and keeping all projections up to date. He also takes care that new projections are booted and old ones are removed again. If something breaks, the projectionist marks the individual projections as faulty. Note You can find the basics of projections and projectors here Tip The Projectionist was inspired by the following two blog posts: Projection Building Blocks: What you'll need to build projections Managing projectors is harder than you think","title":"Projectionist"},{"location":"projectionist/#versioned-projector","text":"So that the projectionist can also assign the projectors to a projection, the interface must be changed from Projector to VersionedProjector . As the name suggests, the projector will also be versionable. In addition, you have to implement the targetProjection method, which returns the target projection id. So that several versions of the projection can exist, the version of the projection should flow into the table or collection name. use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\ProjectionId ; use Patchlevel\\EventSourcing\\Projection\\Projectionist\\VersionedProjector ; final class ProfileProjection implements VersionedProjector { public function __construct ( private readonly Connection $connection ) { } public function targetProjection () : ProjectionId { return new ProjectionId ( name : 'profile' , version : 1 ); } /** * @return list<array{id: string, name: string}> */ public function getProfiles () : array { return $this -> connection -> fetchAllAssociative ( sprintf ( 'SELECT id, name FROM %s;' , $this -> table ()) ); } #[Create] public function create () : void { $this -> connection -> executeStatement ( sprintf ( 'CREATE TABLE IF NOT EXISTS %s (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' , $this -> table () ) ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( sprintf ( 'DROP TABLE IF EXISTS %s;' , $this -> table ()) ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( Message $message ) : void { $profileCreated = $message -> event (); $this -> connection -> executeStatement ( sprintf ( 'INSERT INTO %s (`id`, `name`) VALUES(:id, :name);' , $this -> table ()), [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } private function table () : string { return sprintf ( 'projection_%s_%s' , $this -> targetProjection () -> name (), $this -> targetProjection () -> version () ); } }","title":"Versioned Projector"},{"location":"projectionist/#projection-id","text":"A projection id consists of a unique name and a version. As soon as the projection changes, such as the structure or the data, the version of the projection must be incremented. This tells the projectionist to build an another projection.","title":"Projection Id"},{"location":"projectionist/#projection-position","text":"Furthermore, the position in the event stream is noted for each projection. So that the projectionist knows where the projection stopped and must continue.","title":"Projection Position"},{"location":"projectionist/#projection-status","text":"There is a lifecycle for each projection. This cycle is tracked by the projectionist. stateDiagram-v2 direction LR [*] --> New New --> Booting Booting --> Active Booting --> Error Active --> Outdated Active --> Error Error --> Active Error --> [*] Outdated --> Active Outdated --> [*]","title":"Projection Status"},{"location":"projectionist/#new","text":"A projection gets the status new if there is a projector with an unknown projection id. This can happen when either a new projector has been added, the version has changed or the projection has been manually deleted from the projection store.","title":"New"},{"location":"projectionist/#booting","text":"Booting status is reached when the boot process is invoked. Then the new projections are built up in a separate process parallel. As soon as the projection is built up to the current status, the status changes to active.","title":"Booting"},{"location":"projectionist/#active","text":"The active status describes the projections currently being actively managed by the projectionist. These projections have a projector, follow the event stream and are up to date.","title":"Active"},{"location":"projectionist/#outdated","text":"If a projection exists in the projection store that does not have a projector in the source code with a corresponding projection id, then this projection is marked as outdated. This happens when either the projector has been deleted or the projection id of a projector has changed. In the last case there is a new projection. An outdated projection does not automatically become active again when the projection id exists again. This happens, for example, when an old version was deployed again during a rollback. There are two options here: Reactivate the projection. Remove the projection and rebuild it from scratch.","title":"Outdated"},{"location":"projectionist/#error","text":"If an error occurs in a projector, then the target projection is set to Error. This projection will then no longer run until the projection is activated again. There are two options here: Reactivate the projection. Remove the projection and rebuild it from scratch.","title":"Error"},{"location":"projectionist/#setup","text":"In order for the projectionist to be able to do its work, you have to assemble it beforehand. Warning The SyncProjectorListener must be removed again so that the events are not processed directly!","title":"Setup"},{"location":"projectionist/#projection-store","text":"In order for the projectionist to know the status and position of the projections, they must be saved. Currently there is only the Doctrine Store. use Patchlevel\\EventSourcing\\Projection\\Projection\\Store\\DoctrineStore ; $projectionStore = new DoctrineStore ( $connection ); So that the schema for the projection store can also be created, we have to tell the SchemaDirector our schema configuration. Using ChainSchemaConfigurator we can add multiple schema configurators. In our case they need the SchemaConfigurator from the event store and projection store. use Patchlevel\\EventSourcing\\Schema\\ChainSchemaConfigurator ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $schemaDirector = new DoctrineSchemaDirector ( $connection new ChainSchemaConfigurator ([ $eventStore , $projectionStore ]), ); Note You can find more about schema configurator here","title":"Projection Store"},{"location":"projectionist/#projectionist_1","text":"Now we can create the projectionist: use Patchlevel\\EventSourcing\\Projection\\Projectionist\\DefaultProjectionist ; $projectionist = new DefaultProjectionist ( $eventStore , $projectionStore , $projectorRepository );","title":"Projectionist"},{"location":"projectionist/#usage","text":"The Projectionist has a few methods needed to use it effectively. These are explained here:","title":"Usage"},{"location":"projectionist/#boot","text":"So that the projectionist can manage the projections, they must be booted. In this step, the structures are created for all new projections. The projections then catch up with the current position of the event stream. When the projections are finished, they switch to the active state. $projectionist -> boot ();","title":"Boot"},{"location":"projectionist/#run","text":"All active projections are continued and updated here. $projectionist -> run ();","title":"Run"},{"location":"projectionist/#teardown","text":"If projections are outdated, they can be cleaned up here. The projectionist also tries to remove the structures created for the projection. $projectionist -> teardown ();","title":"Teardown"},{"location":"projectionist/#remove","text":"You can also directly remove a projection regardless of its status. An attempt is made to remove the structures, but the entry will still be removed if it doesn't work. $projectionist -> remove ();","title":"Remove"},{"location":"projectionist/#reactivate","text":"If a projection had an error, you can reactivate it. As a result, the projection gets the status active again and is then kept up-to-date again by the projectionist. $projectionist -> reactivate ();","title":"Reactivate"},{"location":"projectionist/#projections","text":"To get the current status of all projections, you can get them using the projections method. $projections = $projectionist -> projections (); foreach ( $projections as $projection ) { echo $projection -> status (); } Note There are also cli commands for all commands.","title":"Projections"},{"location":"repository/","text":"Repository A repository takes care of storing and loading the aggregates . He is also responsible for building messages from the events and then dispatching them to the event bus. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate. Create a repository The best way to create a repository is to use the DefaultRepositoryManager . This helps to build the repository correctly. The DefaultRepositoryManager needs some services to work. For one, it needs AggregateRootRegistry so that it knows which aggregates exist. The store , which is then given to the repository so that it can save and load the events at the end. And the EventBus to publish the new events. After plugging the DefaultRepositoryManager together, you can create the repository associated with the aggregate. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus ); $repository = $repositoryManager -> get ( Profile :: class ); Note The same repository instance is always returned for a specific aggregate. Snapshots Loading events for an aggregate is superfast. You can have thousands of events in the database that load in a few milliseconds and build the corresponding aggregate. But at some point you realize that it takes time. To counteract this there is a snapshot store. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $adapter = new Psr16SnapshotAdapter ( $cache ); $snapshotStore = new DefaultSnapshotStore ([ 'default' => $adapter ]); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , $snapshotStore ); $repository = $repositoryManager -> get ( Profile :: class ); Note You can find out more about snapshots here . Decorator If you want to add more metadata to the message, like e.g. an application id, then you can use decorator. use Patchlevel\\EventSourcing\\EventBus\\Decorator\\RecordedOnDecorator ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $decorator = new RecordedOnDecorator ( $clock ); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , null , $decorator ); $repository = $repositoryManager -> get ( Profile :: class ); Warning We also use the decorator to fill in the recordedOn time. If you want to add your own decorator, then you need to make sure to add the RecordedOnDecorator as well. You can e.g. solve with the ChainMessageDecorator . Note You can find out more about message decorator here . Use the repository Each repository has three methods that are responsible for loading an aggregate , saving it or checking whether it exists. Save an aggregate An aggregate can be saved . All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database. After the events have been written, the new events are dispatched on the event bus . $profile = Profile :: create ( 'david.badura@patchlevel.de' ); $repository -> save ( $profile ); Note All events are written to the database with one transaction in order to ensure data consistency. Tip If you want to make sure that dispatching events and storing events is transaction safe, then you should look at the outbox pattern. Load an aggregate An aggregate can be loaded using the load method. All events for the aggregate are loaded from the database and the current state is rebuilt. $profile = $repository -> load ( '229286ff-6f95-4df6-bc72-0a239fe7b284' ); Warning When the method is called, the aggregate is always reloaded from the database and rebuilt. Note You can only fetch one aggregate at a time and don't do any complex queries either. Projections are used for this purpose. Has an aggregate You can also check whether an aggregate with a certain id exists. It is checked whether any event with this id exists in the database. if ( $repository -> has ( '229286ff-6f95-4df6-bc72-0a239fe7b284' )) { // ... } Note The query is fast and does not load any event. This means that the state of the aggregate is not rebuild either. Custom Repository In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; class ProfileRepository { /** @var Repository<Profile> */ private Repository $repository ; public function __construct ( RepositoryManager $repositoryManager ) { $this -> repository = $repositoryManager -> get ( Profile :: class ); } public function load ( ProfileId $id ) : Profile { return $this -> repository -> load ( $id -> toString ()); } public function save ( Profile $profile ) : void { return $this -> repository -> save ( $profile ); } public function has ( ProfileId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"Repository"},{"location":"repository/#repository","text":"A repository takes care of storing and loading the aggregates . He is also responsible for building messages from the events and then dispatching them to the event bus. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate.","title":"Repository"},{"location":"repository/#create-a-repository","text":"The best way to create a repository is to use the DefaultRepositoryManager . This helps to build the repository correctly. The DefaultRepositoryManager needs some services to work. For one, it needs AggregateRootRegistry so that it knows which aggregates exist. The store , which is then given to the repository so that it can save and load the events at the end. And the EventBus to publish the new events. After plugging the DefaultRepositoryManager together, you can create the repository associated with the aggregate. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus ); $repository = $repositoryManager -> get ( Profile :: class ); Note The same repository instance is always returned for a specific aggregate.","title":"Create a repository"},{"location":"repository/#snapshots","text":"Loading events for an aggregate is superfast. You can have thousands of events in the database that load in a few milliseconds and build the corresponding aggregate. But at some point you realize that it takes time. To counteract this there is a snapshot store. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $adapter = new Psr16SnapshotAdapter ( $cache ); $snapshotStore = new DefaultSnapshotStore ([ 'default' => $adapter ]); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , $snapshotStore ); $repository = $repositoryManager -> get ( Profile :: class ); Note You can find out more about snapshots here .","title":"Snapshots"},{"location":"repository/#decorator","text":"If you want to add more metadata to the message, like e.g. an application id, then you can use decorator. use Patchlevel\\EventSourcing\\EventBus\\Decorator\\RecordedOnDecorator ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $decorator = new RecordedOnDecorator ( $clock ); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , null , $decorator ); $repository = $repositoryManager -> get ( Profile :: class ); Warning We also use the decorator to fill in the recordedOn time. If you want to add your own decorator, then you need to make sure to add the RecordedOnDecorator as well. You can e.g. solve with the ChainMessageDecorator . Note You can find out more about message decorator here .","title":"Decorator"},{"location":"repository/#use-the-repository","text":"Each repository has three methods that are responsible for loading an aggregate , saving it or checking whether it exists.","title":"Use the repository"},{"location":"repository/#save-an-aggregate","text":"An aggregate can be saved . All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database. After the events have been written, the new events are dispatched on the event bus . $profile = Profile :: create ( 'david.badura@patchlevel.de' ); $repository -> save ( $profile ); Note All events are written to the database with one transaction in order to ensure data consistency. Tip If you want to make sure that dispatching events and storing events is transaction safe, then you should look at the outbox pattern.","title":"Save an aggregate"},{"location":"repository/#load-an-aggregate","text":"An aggregate can be loaded using the load method. All events for the aggregate are loaded from the database and the current state is rebuilt. $profile = $repository -> load ( '229286ff-6f95-4df6-bc72-0a239fe7b284' ); Warning When the method is called, the aggregate is always reloaded from the database and rebuilt. Note You can only fetch one aggregate at a time and don't do any complex queries either. Projections are used for this purpose.","title":"Load an aggregate"},{"location":"repository/#has-an-aggregate","text":"You can also check whether an aggregate with a certain id exists. It is checked whether any event with this id exists in the database. if ( $repository -> has ( '229286ff-6f95-4df6-bc72-0a239fe7b284' )) { // ... } Note The query is fast and does not load any event. This means that the state of the aggregate is not rebuild either.","title":"Has an aggregate"},{"location":"repository/#custom-repository","text":"In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; class ProfileRepository { /** @var Repository<Profile> */ private Repository $repository ; public function __construct ( RepositoryManager $repositoryManager ) { $this -> repository = $repositoryManager -> get ( Profile :: class ); } public function load ( ProfileId $id ) : Profile { return $this -> repository -> load ( $id -> toString ()); } public function save ( Profile $profile ) : void { return $this -> repository -> save ( $profile ); } public function has ( ProfileId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"Custom Repository"},{"location":"snapshots/","text":"Snapshots Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all. Configuration First of all you have to define a snapshot store. This store may have multiple adapters for different caches. These caches also need a name so that you can determine which aggregates should be stored in which cache. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $snapshotStore = new DefaultSnapshotStore ([ 'default' => new Psr16SnapshotAdapter ( $defaultCache ), 'other_cache' => new Psr16SnapshotAdapter ( $otherCache ), ]); After creating the snapshot store, you need to pass that store to the DefaultRepositoryManager. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $snapshotStore = // ... $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , $snapshotStore ); Note You can read more about Repository here . Next we need to tell the Aggregate to take a snapshot of it. We do this using the snapshot attribute. There we also specify where it should be saved. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { // ... } When taking a snapshot, all properties are extracted and saved. When loading, this data is written back to the properties. In other words, in the end everything has to be serializable. To ensure this, the same system is used as for the events. You can define normalizers to bring the properties into the correct format. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { public string $id ; public string $name , #[Normalize(new DateTimeImmutableNormalizer())] public DateTimeImmutable $createdAt ; // ... } Danger If anything changes in the properties of the aggregate, then the cache must be cleared. Or the snapshot version needs to be changed so that the previous snapshot is invalid. Warning In the end it has to be possible to serialize it as json. Note You can find more about normalizer here . Snapshot batching Since the loading of events in itself is quite fast and only becomes noticeably slower with thousands of events, we do not need to create a snapshot after each event. That would also have a negative impact on performance. Instead, we can also create a snapshot after N events. The remaining events that are not in the snapshot are then loaded from store. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default', batch: 1000)] final class Profile extends AggregateRoot { // ... } Snapshot versioning Whenever something changes on the aggregate, the previous snapshot must be discarded. You can do this by removing the entire snapshot cache when deploying. But that can be quickly forgotten. It is much easier to specify a snapshot version. This snapshot version is also saved. When loading, the versions are compared and if they do not match, the snapshot is discarded and the aggregate is rebuilt from scratch. The new aggregate is then saved again as a snapshot. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default', version: '2')] final class Profile extends AggregateRoot { // ... } Warning If the snapshots are discarded, a load peak can occur since the aggregates have to be rebuilt. Tip You can also use uuids for the snapshot version. Adapter We offer a few SnapshotAdapter implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed: symfony cache laminas cache scrapbook psr6 A Psr6SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter ; $adapter = new Psr6SnapshotAdapter ( $cache ); psr16 A Psr16SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; $adapter = new Psr16SnapshotAdapter ( $cache ); in memory A InMemorySnapshotAdapter that can be used for test purposes. use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter ; $adapter = new InMemorySnapshotAdapter ();","title":"Snapshots"},{"location":"snapshots/#snapshots","text":"Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all.","title":"Snapshots"},{"location":"snapshots/#configuration","text":"First of all you have to define a snapshot store. This store may have multiple adapters for different caches. These caches also need a name so that you can determine which aggregates should be stored in which cache. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $snapshotStore = new DefaultSnapshotStore ([ 'default' => new Psr16SnapshotAdapter ( $defaultCache ), 'other_cache' => new Psr16SnapshotAdapter ( $otherCache ), ]); After creating the snapshot store, you need to pass that store to the DefaultRepositoryManager. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $snapshotStore = // ... $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , $snapshotStore ); Note You can read more about Repository here . Next we need to tell the Aggregate to take a snapshot of it. We do this using the snapshot attribute. There we also specify where it should be saved. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { // ... } When taking a snapshot, all properties are extracted and saved. When loading, this data is written back to the properties. In other words, in the end everything has to be serializable. To ensure this, the same system is used as for the events. You can define normalizers to bring the properties into the correct format. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { public string $id ; public string $name , #[Normalize(new DateTimeImmutableNormalizer())] public DateTimeImmutable $createdAt ; // ... } Danger If anything changes in the properties of the aggregate, then the cache must be cleared. Or the snapshot version needs to be changed so that the previous snapshot is invalid. Warning In the end it has to be possible to serialize it as json. Note You can find more about normalizer here .","title":"Configuration"},{"location":"snapshots/#snapshot-batching","text":"Since the loading of events in itself is quite fast and only becomes noticeably slower with thousands of events, we do not need to create a snapshot after each event. That would also have a negative impact on performance. Instead, we can also create a snapshot after N events. The remaining events that are not in the snapshot are then loaded from store. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default', batch: 1000)] final class Profile extends AggregateRoot { // ... }","title":"Snapshot batching"},{"location":"snapshots/#snapshot-versioning","text":"Whenever something changes on the aggregate, the previous snapshot must be discarded. You can do this by removing the entire snapshot cache when deploying. But that can be quickly forgotten. It is much easier to specify a snapshot version. This snapshot version is also saved. When loading, the versions are compared and if they do not match, the snapshot is discarded and the aggregate is rebuilt from scratch. The new aggregate is then saved again as a snapshot. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default', version: '2')] final class Profile extends AggregateRoot { // ... } Warning If the snapshots are discarded, a load peak can occur since the aggregates have to be rebuilt. Tip You can also use uuids for the snapshot version.","title":"Snapshot versioning"},{"location":"snapshots/#adapter","text":"We offer a few SnapshotAdapter implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed: symfony cache laminas cache scrapbook","title":"Adapter"},{"location":"snapshots/#psr6","text":"A Psr6SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter ; $adapter = new Psr6SnapshotAdapter ( $cache );","title":"psr6"},{"location":"snapshots/#psr16","text":"A Psr16SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; $adapter = new Psr16SnapshotAdapter ( $cache );","title":"psr16"},{"location":"snapshots/#in-memory","text":"A InMemorySnapshotAdapter that can be used for test purposes. use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter ; $adapter = new InMemorySnapshotAdapter ();","title":"in memory"},{"location":"split_stream/","text":"Splitting the eventstream In some cases the business has rules which implies an restart of the event stream for an aggregate since the past events are not relevant for the current state. For example a user decides to end his active subscription and the business rules says if the user start a new subscription all past events should not be considered anymore. Another case could be a banking scenario. There the business decides to save the current state every quarter for each banking account. Not only that some businesses requires such an action it also increases the performance for aggregate which would have a really long event stream. Flagging an event to split the stream To use this feature you need to add the SplitStreamDecorator . You will also need events which will trigger this action. For that you can use the #[SplitStream] attribute. We decided that we are not literallty splitting the stream, instead we are marking all past events as archived as soon as this event is saved. Then the past events will not be loaded anymore for building the aggregate. This means that all needed data has to be present in these events which should trigger the event split. #[Event('bank_account.month_passed')] #[SplitStream] final class MonthPassed { public function __construct ( #[Normalize(new AccountIdNormalizer())] public AccountId $accountId , public string $name , public int $balanceInCents , ) { } } Warning The event needs all data which is relevant the aggregate to be used since all past event will not be loaded! Keep this in mind if you want to use this feature. Note This archive flag only impacts the Store::load method which is used the build the aggregate from the stream.","title":"Split Stream"},{"location":"split_stream/#splitting-the-eventstream","text":"In some cases the business has rules which implies an restart of the event stream for an aggregate since the past events are not relevant for the current state. For example a user decides to end his active subscription and the business rules says if the user start a new subscription all past events should not be considered anymore. Another case could be a banking scenario. There the business decides to save the current state every quarter for each banking account. Not only that some businesses requires such an action it also increases the performance for aggregate which would have a really long event stream.","title":"Splitting the eventstream"},{"location":"split_stream/#flagging-an-event-to-split-the-stream","text":"To use this feature you need to add the SplitStreamDecorator . You will also need events which will trigger this action. For that you can use the #[SplitStream] attribute. We decided that we are not literallty splitting the stream, instead we are marking all past events as archived as soon as this event is saved. Then the past events will not be loaded anymore for building the aggregate. This means that all needed data has to be present in these events which should trigger the event split. #[Event('bank_account.month_passed')] #[SplitStream] final class MonthPassed { public function __construct ( #[Normalize(new AccountIdNormalizer())] public AccountId $accountId , public string $name , public int $balanceInCents , ) { } } Warning The event needs all data which is relevant the aggregate to be used since all past event will not be loaded! Keep this in mind if you want to use this feature. Note This archive flag only impacts the Store::load method which is used the build the aggregate from the stream.","title":"Flagging an event to split the stream"},{"location":"store/","text":"Store In the end, the events/messages have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. But it is also possible to develop your own store by implementing the Store interface. Create DBAL connection The first thing we need for our store is a DBAL connection: use Doctrine\\DBAL\\DriverManager ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); Note You can find out more about how to create a connection here Store types We offer two store strategies that you can choose as you like. Single Table Store With the SingleTableStore everything is saved in one table. The dbal connection is needed, a mapping of the aggregate class and aggregate name and, last but not least, the table name. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $store = new SingleTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline . Multi Table Store With the MultiTableStore a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. The dbal connection is needed, a mapping of the aggregate class and table name and, last but not least, the table name for the metadata. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; $store = new MultiTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline . Transaction Our stores also implement the TransactionStore interface. This allows you to combine several aggregate interactions in one transaction and thus ensure that everything is saved together or none of it. Since the library is based on doctrine dbal, our implementation is just a proxy. Note You can find more about dbal transaction here . Begin transaction $store -> transactionBegin (); Commit transaction $store -> transactionCommit (); Rollback transaction $store -> transactionRollback (); Transactional function There is also the possibility of executing a function in a transaction. Then dbal takes care of starting a transaction, committing it and then possibly rollback it again. $store -> transactional ( function () use ( $command , $bankAccountRepository ) { $accountFrom = $bankAccountRepository -> get ( $command -> from ()); $accountTo = $bankAccountRepository -> get ( $command -> to ()); $accountFrom -> transferMoney ( $command -> to (), $command -> amount ()); $accountTo -> receiveMoney ( $command -> from (), $command -> amount ()); $bankAccountRepository -> save ( $accountFrom ); $bankAccountRepository -> save ( $accountTo ); }); Tip To ensure that all listeners are executed for the released events or that the listeners are not executed if the transaction fails, you can use the outbox pattern for it. Schema With the help of the SchemaDirector , the database structure can be created, updated and deleted. Tip You can also use doctrine migration to create and keep your schema in sync. Create SchemaDirector use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $schemaDirector = new DoctrineSchemaDirector ( $connection , $store ); Create schema $schemaDirector -> create (); Update schema $schemaDirector -> update (); Drop schema $schemaDirector -> drop ();","title":"Store"},{"location":"store/#store","text":"In the end, the events/messages have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. But it is also possible to develop your own store by implementing the Store interface.","title":"Store"},{"location":"store/#create-dbal-connection","text":"The first thing we need for our store is a DBAL connection: use Doctrine\\DBAL\\DriverManager ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); Note You can find out more about how to create a connection here","title":"Create DBAL connection"},{"location":"store/#store-types","text":"We offer two store strategies that you can choose as you like.","title":"Store types"},{"location":"store/#single-table-store","text":"With the SingleTableStore everything is saved in one table. The dbal connection is needed, a mapping of the aggregate class and aggregate name and, last but not least, the table name. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $store = new SingleTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline .","title":"Single Table Store"},{"location":"store/#multi-table-store","text":"With the MultiTableStore a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. The dbal connection is needed, a mapping of the aggregate class and table name and, last but not least, the table name for the metadata. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; $store = new MultiTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline .","title":"Multi Table Store"},{"location":"store/#transaction","text":"Our stores also implement the TransactionStore interface. This allows you to combine several aggregate interactions in one transaction and thus ensure that everything is saved together or none of it. Since the library is based on doctrine dbal, our implementation is just a proxy. Note You can find more about dbal transaction here .","title":"Transaction"},{"location":"store/#begin-transaction","text":"$store -> transactionBegin ();","title":"Begin transaction"},{"location":"store/#commit-transaction","text":"$store -> transactionCommit ();","title":"Commit transaction"},{"location":"store/#rollback-transaction","text":"$store -> transactionRollback ();","title":"Rollback transaction"},{"location":"store/#transactional-function","text":"There is also the possibility of executing a function in a transaction. Then dbal takes care of starting a transaction, committing it and then possibly rollback it again. $store -> transactional ( function () use ( $command , $bankAccountRepository ) { $accountFrom = $bankAccountRepository -> get ( $command -> from ()); $accountTo = $bankAccountRepository -> get ( $command -> to ()); $accountFrom -> transferMoney ( $command -> to (), $command -> amount ()); $accountTo -> receiveMoney ( $command -> from (), $command -> amount ()); $bankAccountRepository -> save ( $accountFrom ); $bankAccountRepository -> save ( $accountTo ); }); Tip To ensure that all listeners are executed for the released events or that the listeners are not executed if the transaction fails, you can use the outbox pattern for it.","title":"Transactional function"},{"location":"store/#schema","text":"With the help of the SchemaDirector , the database structure can be created, updated and deleted. Tip You can also use doctrine migration to create and keep your schema in sync.","title":"Schema"},{"location":"store/#create-schemadirector","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector ; $schemaDirector = new DoctrineSchemaDirector ( $connection , $store );","title":"Create SchemaDirector"},{"location":"store/#create-schema","text":"$schemaDirector -> create ();","title":"Create schema"},{"location":"store/#update-schema","text":"$schemaDirector -> update ();","title":"Update schema"},{"location":"store/#drop-schema","text":"$schemaDirector -> drop ();","title":"Drop schema"},{"location":"tests/","text":"Tests The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events. use PHPUnit\\Framework\\TestCase ; final class ProfileTest extends TestCase { public function testCreateProfile () : void { $id = ProfileId :: generate (); $profile = Profile :: createProfile ( $id , Email :: fromString ( 'foo@email.com' )); self :: assertEquals ( $profile -> releaseEvents (), [ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ] ); self :: assertEquals ( 'foo@email.com' , $profile -> email () -> toString ()); } public function testChangeName () : void { $id = ProfileId :: generate (); $profile = Profile :: createFromEvents ([ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ]); $profile -> changeEmail ( Email :: fromString ( 'bar@email.com' )); self :: assertEquals ( $profile -> releaseEvents (), [ new EmailChanged ( Email :: fromString ( 'bar@email.com' )), ] ); self :: assertEquals ( 'bar@email.com' , $profile -> email () -> toString ()); } }","title":"Tests"},{"location":"tests/#tests","text":"The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events. use PHPUnit\\Framework\\TestCase ; final class ProfileTest extends TestCase { public function testCreateProfile () : void { $id = ProfileId :: generate (); $profile = Profile :: createProfile ( $id , Email :: fromString ( 'foo@email.com' )); self :: assertEquals ( $profile -> releaseEvents (), [ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ] ); self :: assertEquals ( 'foo@email.com' , $profile -> email () -> toString ()); } public function testChangeName () : void { $id = ProfileId :: generate (); $profile = Profile :: createFromEvents ([ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ]); $profile -> changeEmail ( Email :: fromString ( 'bar@email.com' )); self :: assertEquals ( $profile -> releaseEvents (), [ new EmailChanged ( Email :: fromString ( 'bar@email.com' )), ] ); self :: assertEquals ( 'bar@email.com' , $profile -> email () -> toString ()); } }","title":"Tests"},{"location":"upcasting/","text":"Upcasting There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer Upcaster , which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event. Adjust payload Let's assume the have an ProfileCreated event which holds an email. Now the business needs to have all emails to be in lower cast. For that we could adjust the aggregate and the projections to take care of that. Or we can do this beforehand so we dont need to maintain two different places. use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; final class ProfileCreatedEmailLowerCastUpcaster implements Upcaster { public function __invoke ( Upcast $upcast ) : Upcast { // ignore if other event is processed if ( $upcast -> eventName !== 'profile_created' ) { return $upcast ; } $payload = $upcast -> payload ; $payload [ 'email' ] = strtolower ( $payload [ 'email' ]); return new Upcast ( $upcast -> eventName , $payload ) } } Warning You need to consider that other events are passed to the Upcaster. So and early out is here endorsed. Adjust event name For the upgrade to 2.0.0 this feature is also really handy since we adjusted the event value from FQCN to an unique name which the user needs to choose. This opens up for moving or renaming the events at code level. Here an example for the upgrade path. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; final class LegacyEventNameUpaster implements Upcaster { public function __construct ( private readonly EventRegistry $eventRegistry ){} public function __invoke ( Upcast $upcast ) : Upcast { return new Upcast ( $this -> eventRegistry -> eventName ( $upcast -> eventName ), $upcast -> payload ); } } Use upcasting After we have defined the upcasting rules, we also have to pass the whole thing to the serializer. Since we have multiple upcasters, we use a chain here. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\UpcasterChain ; $upcaster = new UpcasterChain ([ new ProfileCreatedEmailLowerCastUpcaster (), new LegacyEventNameUpaster ( $eventRegistry ) ]); $serializer = DefaultEventSerializer :: createFromPaths ( [ 'src/Domain' ], $upcaster ); Update event stream But what if we need it also in our stream because some other applications has also access on it? Or want to cleanup our Upcasters since we have collected alot of them over the time? Then we can use our pipeline feature without any middlewares to achive a complete rebuild of our stream with adjusted event data. final class EventStreamCleanupCommand extends Command { protected static $defaultName = 'event-stream:cleanup' ; protected static $defaultDescription = 'rebuild event stream' ; public function __construct ( private readonly Store $sourceStore , private readonly Store $targetStore , private readonly ProjectionHandler $projectionHandler ){ } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $pipeline = new Pipeline ( new StoreSource ( $sourceStore ), new StoreTarget ( $targetStore ) ); $pipeline -> run (); } Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note You can find out more about the pipeline here .","title":"Upcasting"},{"location":"upcasting/#upcasting","text":"There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer Upcaster , which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event.","title":"Upcasting"},{"location":"upcasting/#adjust-payload","text":"Let's assume the have an ProfileCreated event which holds an email. Now the business needs to have all emails to be in lower cast. For that we could adjust the aggregate and the projections to take care of that. Or we can do this beforehand so we dont need to maintain two different places. use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; final class ProfileCreatedEmailLowerCastUpcaster implements Upcaster { public function __invoke ( Upcast $upcast ) : Upcast { // ignore if other event is processed if ( $upcast -> eventName !== 'profile_created' ) { return $upcast ; } $payload = $upcast -> payload ; $payload [ 'email' ] = strtolower ( $payload [ 'email' ]); return new Upcast ( $upcast -> eventName , $payload ) } } Warning You need to consider that other events are passed to the Upcaster. So and early out is here endorsed.","title":"Adjust payload"},{"location":"upcasting/#adjust-event-name","text":"For the upgrade to 2.0.0 this feature is also really handy since we adjusted the event value from FQCN to an unique name which the user needs to choose. This opens up for moving or renaming the events at code level. Here an example for the upgrade path. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; final class LegacyEventNameUpaster implements Upcaster { public function __construct ( private readonly EventRegistry $eventRegistry ){} public function __invoke ( Upcast $upcast ) : Upcast { return new Upcast ( $this -> eventRegistry -> eventName ( $upcast -> eventName ), $upcast -> payload ); } }","title":"Adjust event name"},{"location":"upcasting/#use-upcasting","text":"After we have defined the upcasting rules, we also have to pass the whole thing to the serializer. Since we have multiple upcasters, we use a chain here. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\UpcasterChain ; $upcaster = new UpcasterChain ([ new ProfileCreatedEmailLowerCastUpcaster (), new LegacyEventNameUpaster ( $eventRegistry ) ]); $serializer = DefaultEventSerializer :: createFromPaths ( [ 'src/Domain' ], $upcaster );","title":"Use upcasting"},{"location":"upcasting/#update-event-stream","text":"But what if we need it also in our stream because some other applications has also access on it? Or want to cleanup our Upcasters since we have collected alot of them over the time? Then we can use our pipeline feature without any middlewares to achive a complete rebuild of our stream with adjusted event data. final class EventStreamCleanupCommand extends Command { protected static $defaultName = 'event-stream:cleanup' ; protected static $defaultDescription = 'rebuild event stream' ; public function __construct ( private readonly Store $sourceStore , private readonly Store $targetStore , private readonly ProjectionHandler $projectionHandler ){ } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $pipeline = new Pipeline ( new StoreSource ( $sourceStore ), new StoreTarget ( $targetStore ) ); $pipeline -> run (); } Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note You can find out more about the pipeline here .","title":"Update event stream"},{"location":"uuid/","text":"UUID A UUID can be generated for the aggregateId . There are two popular libraries that can be used: ramsey/uuid symfony/uid The aggregate does not care how the id is generated, since only an aggregate-wide unique string is expected here. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\Uuid ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private UuidInterface $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : UuidInterface { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = Uuid :: uuid4 (); $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Or even better, you create your own aggregate-specific id class. This allows you to ensure that the correct id is always used. The whole thing looks like this: use Ramsey\\Uuid\\Uuid ; class ProfileId { private string $id ; public function __construct ( string $id ) { $this -> id = $id ; } public static function generate () : self { return new self ( Uuid :: uuid4 () -> toString ()); } public function toString () : string { return $this -> id ; } } use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private ProfileId $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : ProfileId { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = ProfileId :: generate (); $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Note If you want to use snapshots, then you have to make sure that the value objects are normalized. You can find how to do this here .","title":"UUID"},{"location":"uuid/#uuid","text":"A UUID can be generated for the aggregateId . There are two popular libraries that can be used: ramsey/uuid symfony/uid The aggregate does not care how the id is generated, since only an aggregate-wide unique string is expected here. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\Uuid ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private UuidInterface $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : UuidInterface { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = Uuid :: uuid4 (); $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Or even better, you create your own aggregate-specific id class. This allows you to ensure that the correct id is always used. The whole thing looks like this: use Ramsey\\Uuid\\Uuid ; class ProfileId { private string $id ; public function __construct ( string $id ) { $this -> id = $id ; } public static function generate () : self { return new self ( Uuid :: uuid4 () -> toString ()); } public function toString () : string { return $this -> id ; } } use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private ProfileId $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : ProfileId { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = ProfileId :: generate (); $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Note If you want to use snapshots, then you have to make sure that the value objects are normalized. You can find how to do this here .","title":"UUID"},{"location":"watch_server/","text":"Watch We have implemented a watch server that can be used for development. Every event that is saved is sent to the watch server using a watch listener. You can subscribe to it and display the information anywhere, e.g. in the CLI. Watch client The watch client and the listener are used to send all events that are saved to a specific host. use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServerClient ; use Patchlevel\\EventSourcing\\WatchServer\\WatchListener ; $watchServerClient = new SocketWatchServerClient ( '127.0.0.1:5000' , $eventSerializer ); $watchListener = new WatchListener ( $watchServerClient ); Warning This should only be used for dev purposes and should not be registered in production. Watch server The watch server is used to receive all events that are sent. You can subscribe to the watch server and process or display each event as you wish. As soon as you execute start , the server will be started until you terminate the php process. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $eventSerializer ); $watchServer -> listen ( function ( Message $message ) { var_dump ( $message ); } ); $watchServer -> start (); Warning The host must match the one defined in the watch server client. Watch server CLI Here is an example of how to use it with a symfony cli. use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; use Symfony\\Component\\Console\\Application ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $eventSerializer ); $command = new WatchCommand ( $watchServer ); $cli -> addCommands ([ /* more commands */ new Command\\WatchCommand ( $watchServer ), ]); $cli -> run (); Warning To use the watch server CLI command, you have to configure the CLI beforehand. Note The command can be terminated with ctrl+c or control+c .","title":"Watch Server"},{"location":"watch_server/#watch","text":"We have implemented a watch server that can be used for development. Every event that is saved is sent to the watch server using a watch listener. You can subscribe to it and display the information anywhere, e.g. in the CLI.","title":"Watch"},{"location":"watch_server/#watch-client","text":"The watch client and the listener are used to send all events that are saved to a specific host. use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServerClient ; use Patchlevel\\EventSourcing\\WatchServer\\WatchListener ; $watchServerClient = new SocketWatchServerClient ( '127.0.0.1:5000' , $eventSerializer ); $watchListener = new WatchListener ( $watchServerClient ); Warning This should only be used for dev purposes and should not be registered in production.","title":"Watch client"},{"location":"watch_server/#watch-server","text":"The watch server is used to receive all events that are sent. You can subscribe to the watch server and process or display each event as you wish. As soon as you execute start , the server will be started until you terminate the php process. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $eventSerializer ); $watchServer -> listen ( function ( Message $message ) { var_dump ( $message ); } ); $watchServer -> start (); Warning The host must match the one defined in the watch server client.","title":"Watch server"},{"location":"watch_server/#watch-server-cli","text":"Here is an example of how to use it with a symfony cli. use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; use Symfony\\Component\\Console\\Application ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $eventSerializer ); $command = new WatchCommand ( $watchServer ); $cli -> addCommands ([ /* more commands */ new Command\\WatchCommand ( $watchServer ), ]); $cli -> run (); Warning To use the watch server CLI command, you have to configure the CLI beforehand. Note The command can be terminated with ctrl+c or control+c .","title":"Watch server CLI"}]}