{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"aggregate/","text":"Aggregate Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. [...] DDD Aggregate - Martin Flower An AggregateRoot has to inherit from AggregateRoot and need to implement the method aggregateRootId . aggregateRootId is the identifier from AggregateRoot like a primary key for an entity. The events will be added later, but the following is enough to make it executable: To register an aggregate you have to set the Aggregate attribute over the class, otherwise it will not be recognized as an aggregate. There you also have to give the aggregate a name. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; public function aggregateRootId () : string { return $this -> id ; } public static function create ( string $id ) : self { $self = new self (); // todo: record create event return $self ; } } The aggregate is not yet finished and has only been built to the point that you can instantiate the object. An aggregateId can be an uuid , you can find more about this here . We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like createFromRegistration . After the basic structure for an aggregate is in place, it could theoretically be saved: use Patchlevel\\EventSourcing\\Repository\\Repository ; final class CreateProfileHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( CreateProfile $command ) : void { $profile = Profile :: create ( $command -> id ()); $this -> profileRepository -> save ( $profile ); } } If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens. A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service. Create a new aggregate In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event ProfileCreated : use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } You can find out more about events here . After we have defined the event, we have to adapt the creation of the profile: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : self { $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Prefixing the apply methods with \"apply\" improves readability. In our named constructor create we have now created the event and recorded it with the method record . The aggregate remembers all recorded events in order to save them later. At the same time, a defined apply method is executed directly so that we can change our state. So that the AggregateRoot also knows which method it should call, we have to provide it with the Apply attributes . We did that in the applyProfileCreated method. In this method we change the Profile properties id and name with the transferred values. Modify an aggregate In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a NameChanged event: use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name ) { } } Events should best be written in the past, as they describe a state that has happened. After we have defined the event, we can define a new public method called changeName to change the profile name. This method then creates the event NameChanged and records it: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } public function changeName ( string $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } #[Apply(NameChanged::class)] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } We have also defined a new apply method named applyNameChanged where we change the name depending on the value in the event. When using it, it can look like this: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Repository\\Repository ; final class ChangeNameHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( ChangeName $command ) : void { $profile = $this -> profileRepository -> load ( $command -> id ()); $profile -> changeName ( $command -> name ()); $this -> profileRepository -> save ( $profile ); } } You can read more about Repository here . Here the aggregate is loaded from the repository by fetching all events from the database. These events are then executed again with the apply methods in order to rebuild the current state. All of this happens automatically in the load method. The method changeName is then executed on the aggregate to change the name. In this method the event NameChanged is generated and recorded. The applyNameChanged method was also called again internally to adjust the state. When the save method is called on the repository, all newly recorded events are then fetched and written to the database. Multiple apply attributes on the same method You can also define several apply attributes with different events using the same method. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] #[Apply(NameChanged::class)] protected function applyProfileCreated ( ProfileCreated | NameChanged $event ) : void { if ( $event instanceof ProfileCreated ) { $this -> id = $event -> profileId ; } $this -> name = $event -> name ; } } Suppress missing apply methods Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future, to listen on it or to create a projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the SuppressMissingApply attribute. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([NameChanged::class])] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Suppress missing apply for all methods You can also completely deactivate the exceptions for missing apply methods. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply(SuppressMissingApply::ALL)] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } When all events are suppressed, debugging becomes more difficult if you forget an apply method. Business rules Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group. These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone. A further check in the apply method is also not possible because these events have already happened and were then also saved in the database. In the next example we want to make sure that the name is at least 3 characters long : use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... public function name () : string { return $this -> name ; } public function changeName ( string $name ) : void { if ( strlen ( $name ) < 3 ) { throw new NameIsToShortException ( $name ); } $this -> recordThat ( new NameChanged ( $name )); } #[Apply(NameChanged::class)] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name (); } } Disregarding this can break the rebuilding of the state! We have now ensured that this rule takes effect when a name is changed with the method changeName . But when we create a new profile this rule does not currently apply. In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } We can now use the value object Name in our aggregate: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; public static function create ( string $id , Name $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } // ... public function name () : Name { return $this -> name ; } public function changeName ( Name $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply(NameChanged::class)] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } In order for the whole thing to work, we still have to adapt our NameChanged event, since we only expected a string before but now passed a Name value object. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } The payload must be serializable and unserializable as json. You can find out more about event normalizer here . There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the apply methods are always executed immediately. In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event FullyBooked , if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([FullyBooked::class])] final class Hotel extends AggregateRoot { private const SIZE = 5 ; private int $people ; // ... public function book ( string $name ) : void { if ( $this -> people === self :: SIZE ) { throw new NoPlaceException ( $name ); } $this -> recordThat ( new RoomBocked ( $name )); if ( $this -> people === self :: SIZE ) { $this -> recordThat ( new FullyBooked ()); } } #[Apply(RoomBocked::class)] protected function applyRoomBocked ( RoomBocked $event ) : void { $this -> people ++ ; } } Aggregate Root Registry The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an AggregateRootRegistry for this purpose. The registry is a simple hashmap between aggregate name and aggregate class. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = new AggregateRootRegistry ([ 'profile' => Profile :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeAggregateRootRegistryFactory is used. There, with the help of paths, all classes with the attribute Aggregate are searched for and the AggregateRootRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AttributeAggregateRootRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Aggregate"},{"location":"aggregate/#aggregate","text":"Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. [...] DDD Aggregate - Martin Flower An AggregateRoot has to inherit from AggregateRoot and need to implement the method aggregateRootId . aggregateRootId is the identifier from AggregateRoot like a primary key for an entity. The events will be added later, but the following is enough to make it executable: To register an aggregate you have to set the Aggregate attribute over the class, otherwise it will not be recognized as an aggregate. There you also have to give the aggregate a name. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; public function aggregateRootId () : string { return $this -> id ; } public static function create ( string $id ) : self { $self = new self (); // todo: record create event return $self ; } } The aggregate is not yet finished and has only been built to the point that you can instantiate the object. An aggregateId can be an uuid , you can find more about this here . We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like createFromRegistration . After the basic structure for an aggregate is in place, it could theoretically be saved: use Patchlevel\\EventSourcing\\Repository\\Repository ; final class CreateProfileHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( CreateProfile $command ) : void { $profile = Profile :: create ( $command -> id ()); $this -> profileRepository -> save ( $profile ); } } If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens. A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service.","title":"Aggregate"},{"location":"aggregate/#create-a-new-aggregate","text":"In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event ProfileCreated : use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } You can find out more about events here . After we have defined the event, we have to adapt the creation of the profile: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : self { $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Prefixing the apply methods with \"apply\" improves readability. In our named constructor create we have now created the event and recorded it with the method record . The aggregate remembers all recorded events in order to save them later. At the same time, a defined apply method is executed directly so that we can change our state. So that the AggregateRoot also knows which method it should call, we have to provide it with the Apply attributes . We did that in the applyProfileCreated method. In this method we change the Profile properties id and name with the transferred values.","title":"Create a new aggregate"},{"location":"aggregate/#modify-an-aggregate","text":"In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a NameChanged event: use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name ) { } } Events should best be written in the past, as they describe a state that has happened. After we have defined the event, we can define a new public method called changeName to change the profile name. This method then creates the event NameChanged and records it: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } public function changeName ( string $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } #[Apply(NameChanged::class)] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } We have also defined a new apply method named applyNameChanged where we change the name depending on the value in the event. When using it, it can look like this: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Repository\\Repository ; final class ChangeNameHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( ChangeName $command ) : void { $profile = $this -> profileRepository -> load ( $command -> id ()); $profile -> changeName ( $command -> name ()); $this -> profileRepository -> save ( $profile ); } } You can read more about Repository here . Here the aggregate is loaded from the repository by fetching all events from the database. These events are then executed again with the apply methods in order to rebuild the current state. All of this happens automatically in the load method. The method changeName is then executed on the aggregate to change the name. In this method the event NameChanged is generated and recorded. The applyNameChanged method was also called again internally to adjust the state. When the save method is called on the repository, all newly recorded events are then fetched and written to the database.","title":"Modify an aggregate"},{"location":"aggregate/#multiple-apply-attributes-on-the-same-method","text":"You can also define several apply attributes with different events using the same method. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] #[Apply(NameChanged::class)] protected function applyProfileCreated ( ProfileCreated | NameChanged $event ) : void { if ( $event instanceof ProfileCreated ) { $this -> id = $event -> profileId ; } $this -> name = $event -> name ; } }","title":"Multiple apply attributes on the same method"},{"location":"aggregate/#suppress-missing-apply-methods","text":"Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future, to listen on it or to create a projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the SuppressMissingApply attribute. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([NameChanged::class])] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } }","title":"Suppress missing apply methods"},{"location":"aggregate/#suppress-missing-apply-for-all-methods","text":"You can also completely deactivate the exceptions for missing apply methods. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply(SuppressMissingApply::ALL)] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } When all events are suppressed, debugging becomes more difficult if you forget an apply method.","title":"Suppress missing apply for all methods"},{"location":"aggregate/#business-rules","text":"Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group. These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone. A further check in the apply method is also not possible because these events have already happened and were then also saved in the database. In the next example we want to make sure that the name is at least 3 characters long : use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... public function name () : string { return $this -> name ; } public function changeName ( string $name ) : void { if ( strlen ( $name ) < 3 ) { throw new NameIsToShortException ( $name ); } $this -> recordThat ( new NameChanged ( $name )); } #[Apply(NameChanged::class)] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name (); } } Disregarding this can break the rebuilding of the state! We have now ensured that this rule takes effect when a name is changed with the method changeName . But when we create a new profile this rule does not currently apply. In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } We can now use the value object Name in our aggregate: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; public static function create ( string $id , Name $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } // ... public function name () : Name { return $this -> name ; } public function changeName ( Name $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply(NameChanged::class)] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } In order for the whole thing to work, we still have to adapt our NameChanged event, since we only expected a string before but now passed a Name value object. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } The payload must be serializable and unserializable as json. You can find out more about event normalizer here . There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the apply methods are always executed immediately. In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event FullyBooked , if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([FullyBooked::class])] final class Hotel extends AggregateRoot { private const SIZE = 5 ; private int $people ; // ... public function book ( string $name ) : void { if ( $this -> people === self :: SIZE ) { throw new NoPlaceException ( $name ); } $this -> recordThat ( new RoomBocked ( $name )); if ( $this -> people === self :: SIZE ) { $this -> recordThat ( new FullyBooked ()); } } #[Apply(RoomBocked::class)] protected function applyRoomBocked ( RoomBocked $event ) : void { $this -> people ++ ; } }","title":"Business rules"},{"location":"aggregate/#aggregate-root-registry","text":"The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an AggregateRootRegistry for this purpose. The registry is a simple hashmap between aggregate name and aggregate class. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = new AggregateRootRegistry ([ 'profile' => Profile :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeAggregateRootRegistryFactory is used. There, with the help of paths, all classes with the attribute Aggregate are searched for and the AggregateRootRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AttributeAggregateRootRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Aggregate Root Registry"},{"location":"cli/","text":"CLI The library also offers symfony cli commands to create or delete databases . It is also possible to manage the schema and projections . These commands are optional and only wrap existing functionalities that are also available in this way. Require package To use the symfony cli command you first have to install the packet. composer require symfony/console Database commands There are two commands for creating and deleting a database. DatabaseCreateCommand: event-sourcing:database:create DatabaseDropCommand: event-sourcing:database:drop Schema commands The database schema can also be created, updated and dropped. SchemaCreateCommand: event-sourcing:schema:create SchemaUpdateCommand: event-sourcing:schema:update SchemaDropCommand: event-sourcing:schema:drop You can also register doctrine migration commands, see the store documentation for this. Projection commands The creation, deletion and rebuilding of the projections is also possible via the cli. ProjectionCreateCommand: event-sourcing:projection:create ProjectionDropCommand: event-sourcing:projection:drop ProjectionRebuildCommand: event-sourcing:projection:rebuild The pipeline will be used to rebuild the projection. CLI example A cli php file can look like this: use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\Console\\DoctrineHelper ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; use Symfony\\Component\\Console\\Application ; $store = /* define your doctrine store */ ; $projectionRepository = /* create a project repository */ ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $doctrineHelper = new DoctrineHelper (); $schemaManager = new DoctrineSchemaManager (); $cli -> addCommands ( array ( new Command\\DatabaseCreateCommand ( $store , $doctrineHelper ), new Command\\DatabaseDropCommand ( $store , $doctrineHelper ), new Command\\ProjectionCreateCommand ( $projectionRepository ), new Command\\ProjectionDropCommand ( $projectionRepository ), new Command\\ProjectionRebuildCommand ( $store , $projectionRepository ), new Command\\SchemaCreateCommand ( $store , $schemaManager ), new Command\\SchemaDropCommand ( $store , $schemaManager ), new Command\\SchemaUpdateCommand ( $store , $schemaManager ), )); $cli -> run (); You can also register doctrine migration commands, see the store documentation for this.","title":"CLI"},{"location":"cli/#cli","text":"The library also offers symfony cli commands to create or delete databases . It is also possible to manage the schema and projections . These commands are optional and only wrap existing functionalities that are also available in this way.","title":"CLI"},{"location":"cli/#require-package","text":"To use the symfony cli command you first have to install the packet. composer require symfony/console","title":"Require package"},{"location":"cli/#database-commands","text":"There are two commands for creating and deleting a database. DatabaseCreateCommand: event-sourcing:database:create DatabaseDropCommand: event-sourcing:database:drop","title":"Database commands"},{"location":"cli/#schema-commands","text":"The database schema can also be created, updated and dropped. SchemaCreateCommand: event-sourcing:schema:create SchemaUpdateCommand: event-sourcing:schema:update SchemaDropCommand: event-sourcing:schema:drop You can also register doctrine migration commands, see the store documentation for this.","title":"Schema commands"},{"location":"cli/#projection-commands","text":"The creation, deletion and rebuilding of the projections is also possible via the cli. ProjectionCreateCommand: event-sourcing:projection:create ProjectionDropCommand: event-sourcing:projection:drop ProjectionRebuildCommand: event-sourcing:projection:rebuild The pipeline will be used to rebuild the projection.","title":"Projection commands"},{"location":"cli/#cli-example","text":"A cli php file can look like this: use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\Console\\DoctrineHelper ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; use Symfony\\Component\\Console\\Application ; $store = /* define your doctrine store */ ; $projectionRepository = /* create a project repository */ ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $doctrineHelper = new DoctrineHelper (); $schemaManager = new DoctrineSchemaManager (); $cli -> addCommands ( array ( new Command\\DatabaseCreateCommand ( $store , $doctrineHelper ), new Command\\DatabaseDropCommand ( $store , $doctrineHelper ), new Command\\ProjectionCreateCommand ( $projectionRepository ), new Command\\ProjectionDropCommand ( $projectionRepository ), new Command\\ProjectionRebuildCommand ( $store , $projectionRepository ), new Command\\SchemaCreateCommand ( $store , $schemaManager ), new Command\\SchemaDropCommand ( $store , $schemaManager ), new Command\\SchemaUpdateCommand ( $store , $schemaManager ), )); $cli -> run (); You can also register doctrine migration commands, see the store documentation for this.","title":"CLI example"},{"location":"event_bus/","text":"Event Bus This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event wrapped in a message will be dispatched to the event bus . All listeners are then called for each event/message. Message A Message contains the event and related meta information such as the aggregate class and id. A message contains the following information: aggregate class aggregate id playhead event recorded on Each event is packed into a message and dispatched using the event bus. use Patchlevel\\EventSourcing\\EventBus\\Message ; $event = new NameChanged ( 'foo' ); $message = new Message ( Profile :: class , // aggregate class 'bca7576c-536f-4428-b694-7b1f00c714b7' , // aggregate id 2 , // playhead $event // event object ); $eventBus -> dispatch ( $message ); You don't have to create the message yourself, it is automatically created in the aggregate and automatically fetched, saved and dispatched from the repository. Default event bus The library also delivers a light-weight event bus. This can only register listener and dispatch events. use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; $eventBus = new DefaultEventBus (); $eventBus -> addListener ( $mailListener ); $eventBus -> addListener ( $projectionListener ); You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Symfony event bus You can also use the symfony message bus which is much more powerful. To use the optional symfony messenger you first have to install the packet. composer require symfony/messenger You can either let us build it with the create factory: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $eventBus = SymfonyEventBus :: create ([ $mailListener , $projectionListener ]); You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Or plug it together by hand: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $symfonyMessenger = //... $eventBus = new SymfonyEventBus ( $symfonyMessenger ); You can't mix it with a command bus. You should create a new bus for it. An event bus can have zero or more listeners on an event. You should allow no handler in the HandleMessageMiddleware . Listener A listener must implement the Listener interface and define the __invoke method. This listener is then called for all saved events / messages. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $listener = new class implements Listener { public function __invoke ( Message $message ) : void { if ( $message -> event () instanceof ProfileCreated ) { echo 'Welcome!' ; } } } If you only want to listen to certain messages, then you have to check it in the __invoke method. Basically, listeners can be categorized according to their tasks. We have a processor and projections .","title":"Event Bus"},{"location":"event_bus/#event-bus","text":"This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event wrapped in a message will be dispatched to the event bus . All listeners are then called for each event/message.","title":"Event Bus"},{"location":"event_bus/#message","text":"A Message contains the event and related meta information such as the aggregate class and id. A message contains the following information: aggregate class aggregate id playhead event recorded on Each event is packed into a message and dispatched using the event bus. use Patchlevel\\EventSourcing\\EventBus\\Message ; $event = new NameChanged ( 'foo' ); $message = new Message ( Profile :: class , // aggregate class 'bca7576c-536f-4428-b694-7b1f00c714b7' , // aggregate id 2 , // playhead $event // event object ); $eventBus -> dispatch ( $message ); You don't have to create the message yourself, it is automatically created in the aggregate and automatically fetched, saved and dispatched from the repository.","title":"Message"},{"location":"event_bus/#default-event-bus","text":"The library also delivers a light-weight event bus. This can only register listener and dispatch events. use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; $eventBus = new DefaultEventBus (); $eventBus -> addListener ( $mailListener ); $eventBus -> addListener ( $projectionListener ); You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections .","title":"Default event bus"},{"location":"event_bus/#symfony-event-bus","text":"You can also use the symfony message bus which is much more powerful. To use the optional symfony messenger you first have to install the packet. composer require symfony/messenger You can either let us build it with the create factory: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $eventBus = SymfonyEventBus :: create ([ $mailListener , $projectionListener ]); You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Or plug it together by hand: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $symfonyMessenger = //... $eventBus = new SymfonyEventBus ( $symfonyMessenger ); You can't mix it with a command bus. You should create a new bus for it. An event bus can have zero or more listeners on an event. You should allow no handler in the HandleMessageMiddleware .","title":"Symfony event bus"},{"location":"event_bus/#listener","text":"A listener must implement the Listener interface and define the __invoke method. This listener is then called for all saved events / messages. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $listener = new class implements Listener { public function __invoke ( Message $message ) : void { if ( $message -> event () instanceof ProfileCreated ) { echo 'Welcome!' ; } } } If you only want to listen to certain messages, then you have to check it in the __invoke method. Basically, listeners can be categorized according to their tasks. We have a processor and projections .","title":"Listener"},{"location":"events/","text":"Events Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values. To register an event you have to set the Event attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name. use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event(name: 'profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } The payload must be serializable and unserializable as json. An event should be named in the past because it has already happened. Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples: profile.created profile.name_changed hotel.guest_checked_out Serializer So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a JsonSerializer that can be given further instructions using attributes. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain' ]); The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later. Normalizer Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. In our example we build a Name Value Object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } And for that we need our own normalizer. This normalizer must implement the Normalizer interface. You also need to implement a normalize and denormalize method. The important thing is that the result of Normalize is serializable. use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\Normalizer ; class NameNormalizer implements Normalizer { public function normalize ( mixed $value ) : string { if ( ! $value instanceof Name ) { throw new InvalidArgumentException (); } return $value -> toString (); } public function denormalize ( mixed $value ) : ? Name { if ( $value === null ) { return null ; } if ( ! is_string ( $value )) { throw new InvalidArgumentException (); } return new Name ( $value ); } } We can use all of this with the Normalize attribute as follows. The attribute must be set over the property to which it is to be applied. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } In the example we simply specified the class. But we can also instantiate the normalizer and pass parameters. That doesn't make sense at this point, but here's the example: use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(new NameNormalizer('foo'))] public readonly Name $name ) {} } new initializers works only from php 8.1 Serialized Name By default the property name is used to name the field in json. This can be customized with the SerializedName attribute. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\SerializedName ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[SerializedName('profile_name')] public readonly string $name ) {} } The whole thing looks like this { \"profile_name\" : \"David\" } Event Registry The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = new EventRegistry ([ 'profile.created' => ProfileCreated :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeEventRegistryFactory is used. There, with the help of paths, all classes with the attribute Event are searched for and the EventRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Events"},{"location":"events/#events","text":"Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values. To register an event you have to set the Event attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name. use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event(name: 'profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } The payload must be serializable and unserializable as json. An event should be named in the past because it has already happened. Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples: profile.created profile.name_changed hotel.guest_checked_out","title":"Events"},{"location":"events/#serializer","text":"So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a JsonSerializer that can be given further instructions using attributes. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain' ]); The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later.","title":"Serializer"},{"location":"events/#normalizer","text":"Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. In our example we build a Name Value Object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } And for that we need our own normalizer. This normalizer must implement the Normalizer interface. You also need to implement a normalize and denormalize method. The important thing is that the result of Normalize is serializable. use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\Normalizer ; class NameNormalizer implements Normalizer { public function normalize ( mixed $value ) : string { if ( ! $value instanceof Name ) { throw new InvalidArgumentException (); } return $value -> toString (); } public function denormalize ( mixed $value ) : ? Name { if ( $value === null ) { return null ; } if ( ! is_string ( $value )) { throw new InvalidArgumentException (); } return new Name ( $value ); } } We can use all of this with the Normalize attribute as follows. The attribute must be set over the property to which it is to be applied. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } In the example we simply specified the class. But we can also instantiate the normalizer and pass parameters. That doesn't make sense at this point, but here's the example: use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(new NameNormalizer('foo'))] public readonly Name $name ) {} } new initializers works only from php 8.1","title":"Normalizer"},{"location":"events/#serialized-name","text":"By default the property name is used to name the field in json. This can be customized with the SerializedName attribute. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\SerializedName ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[SerializedName('profile_name')] public readonly string $name ) {} } The whole thing looks like this { \"profile_name\" : \"David\" }","title":"Serialized Name"},{"location":"events/#event-registry","text":"The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = new EventRegistry ([ 'profile.created' => ProfileCreated :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeEventRegistryFactory is used. There, with the help of paths, all classes with the attribute Event are searched for and the EventRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Event Registry"},{"location":"faq/","text":"FAQ Here you will find some answers to the most common questions that did not fit in the actual documentation. How can i generate an aggregate id? How can i improve the handling of the repositories? How can i generate an aggregate id? A UUID can be generated for the aggregateId . There are two popular libraries that can be used: ramsey/uuid symfony/uid The aggregate does not care how the id is generated, since only an aggregate-wide unique string is expected here. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\Uuid ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private UuidInterface $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : UuidInterface { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = Uuid :: uuid4 (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Or even better, you create your own aggregate-specific id class. This allows you to ensure that the correct id is always used. The whole thing looks like this: use Ramsey\\Uuid\\Uuid ; class ProfileId { private string $id ; public function __constructor ( string $id ) { $this -> id = $id ; } public static function generate () : self { return new self ( Uuid :: uuid4 () -> toString ()); } public function toString () : string { return $this -> id ; } } use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private ProfileId $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : ProfileId { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = ProfileId :: generate (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } How can i improve the handling of the repositories? In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; class ProfileRepository { private Repository $repository ; public function __constructor ( Repository $repository ) { $this -> repository = $repository ; } public function load ( ProfileId $id ) : Profile { return $this -> repository -> load ( $id -> toString ()); } public function save ( Profile $profile ) : void { return $this -> repository -> save ( $profile ); } public function has ( ProfileId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"FAQ"},{"location":"faq/#faq","text":"Here you will find some answers to the most common questions that did not fit in the actual documentation. How can i generate an aggregate id? How can i improve the handling of the repositories?","title":"FAQ"},{"location":"faq/#how-can-i-generate-an-aggregate-id","text":"A UUID can be generated for the aggregateId . There are two popular libraries that can be used: ramsey/uuid symfony/uid The aggregate does not care how the id is generated, since only an aggregate-wide unique string is expected here. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\Uuid ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private UuidInterface $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : UuidInterface { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = Uuid :: uuid4 (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Or even better, you create your own aggregate-specific id class. This allows you to ensure that the correct id is always used. The whole thing looks like this: use Ramsey\\Uuid\\Uuid ; class ProfileId { private string $id ; public function __constructor ( string $id ) { $this -> id = $id ; } public static function generate () : self { return new self ( Uuid :: uuid4 () -> toString ()); } public function toString () : string { return $this -> id ; } } use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private ProfileId $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : ProfileId { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = ProfileId :: generate (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } }","title":"How can i generate an aggregate id?"},{"location":"faq/#how-can-i-improve-the-handling-of-the-repositories","text":"In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; class ProfileRepository { private Repository $repository ; public function __constructor ( Repository $repository ) { $this -> repository = $repository ; } public function load ( ProfileId $id ) : Profile { return $this -> repository -> load ( $id -> toString ()); } public function save ( Profile $profile ) : void { return $this -> repository -> save ( $profile ); } public function has ( ProfileId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"How can i improve the handling of the repositories?"},{"location":"pipeline/","text":"Pipeline A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! The pipeline can also be used to create or rebuild a projection: use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $pipeline = new Pipeline ( new StoreSource ( $store ), new ProjectionTarget ( $projection ) ); The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand. Source The first thing you need is a source of where the data should come from. Store The StoreSource is the standard source to load all events from the database. use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; $source = new StoreSource ( $store ); In Memory There is an InMemorySource that receives the messages in an array. This source can be used to write pipeline tests. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource ; $source = new InMemorySource ([ new Message ( Profile :: class , '1' , 1 , new ProfileCreated ( Email :: fromString ( 'david.badura@patchlevel.de' )), ), // ... ]); Custom Source You can also create your own source class. It has to inherit from Source . Here you can, for example, create a migration from another event sourcing system or similar system. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\Source ; $source = new class implements Source { /** * @return Generator<Message> */ public function load () : Generator { yield new Message ( Profile :: class , '1' , 0 , new ProfileCreated ( '1' , [ 'name' => 'David' ]) ); } public function count () : int { reutrn 1 ; } } Target After you have a source, you still need the destination of the pipeline. Store You can use a store to save the final result. use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $target = new StoreTarget ( $store ); Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline. Projection A projection can also be used as a target. For example, to set up a new projection or to build a new projection. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $target = new ProjectionTarget ( $projection ); Projection Handler If you want to build or create all projections from scratch, then you can also use the ProjectionRepositoryTarget. In this, the individual projections are iterated and the events are then passed on. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionHandlerTarget ; $target = new ProjectionHandlerTarget ( $projectionHandler ); In Memory There is also an in-memory variant for the target. This target can also be used for tests. With the messages method you get all Messages that have reached the target. use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget ; $target = new InMemoryTarget (); // run pipeline $messages = $target -> messages (); Middlewares Middelwares can be used to manipulate, delete or expand messages or events during the process. It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware. exclude With this middleware you can exclude certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; $middleware = new ExcludeEventMiddleware ([ EmailChanged :: class ]); After this middleware, the playhead must be recalculated! include With this middleware you can only allow certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware ; $middleware = new IncludeEventMiddleware ([ ProfileCreated :: class ]); After this middleware, the playhead must be recalculated! filter If the middlewares ExcludeEventMiddleware and IncludeEventMiddleware are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware ; $middleware = new FilterEventMiddleware ( function ( AggregateChanged $event ) { if ( ! $event instanceof ProfileCreated ) { return true ; } return $event -> allowNewsletter (); }); After this middleware, the playhead must be recalculated! replace If you want to replace an event, you can use the ReplaceEventMiddleware . The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; $middleware = new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }); The middleware takes over the playhead and recordedAt information. until A use case could also be that you want to look at the projection from a previous point in time. You can use the UntilEventMiddleware to only allow events that were recorded before this point in time. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ClassRenameMiddleware ; $middleware = new UntilEventMiddleware ( new DateTimeImmutable ( '2020-01-01 12:00:00' )); After this middleware, the playhead must be recalculated! recalculate playhead This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware RecalculatePlayheadMiddleware can fix this problem. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new RecalculatePlayheadMiddleware (); You only need to add this middleware once at the end of the pipeline. chain If you want to group your middleware, you can use one or more ChainMiddleware . use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new ChainMiddleware ([ new ExcludeEventMiddleware ([ EmailChanged :: class ]), new RecalculatePlayheadMiddleware () ]);","title":"Pipeline"},{"location":"pipeline/#pipeline","text":"A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! The pipeline can also be used to create or rebuild a projection: use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $pipeline = new Pipeline ( new StoreSource ( $store ), new ProjectionTarget ( $projection ) ); The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand.","title":"Pipeline"},{"location":"pipeline/#source","text":"The first thing you need is a source of where the data should come from.","title":"Source"},{"location":"pipeline/#store","text":"The StoreSource is the standard source to load all events from the database. use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; $source = new StoreSource ( $store );","title":"Store"},{"location":"pipeline/#in-memory","text":"There is an InMemorySource that receives the messages in an array. This source can be used to write pipeline tests. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource ; $source = new InMemorySource ([ new Message ( Profile :: class , '1' , 1 , new ProfileCreated ( Email :: fromString ( 'david.badura@patchlevel.de' )), ), // ... ]);","title":"In Memory"},{"location":"pipeline/#custom-source","text":"You can also create your own source class. It has to inherit from Source . Here you can, for example, create a migration from another event sourcing system or similar system. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\Source ; $source = new class implements Source { /** * @return Generator<Message> */ public function load () : Generator { yield new Message ( Profile :: class , '1' , 0 , new ProfileCreated ( '1' , [ 'name' => 'David' ]) ); } public function count () : int { reutrn 1 ; } }","title":"Custom Source"},{"location":"pipeline/#target","text":"After you have a source, you still need the destination of the pipeline.","title":"Target"},{"location":"pipeline/#store_1","text":"You can use a store to save the final result. use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $target = new StoreTarget ( $store ); Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline.","title":"Store"},{"location":"pipeline/#projection","text":"A projection can also be used as a target. For example, to set up a new projection or to build a new projection. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $target = new ProjectionTarget ( $projection );","title":"Projection"},{"location":"pipeline/#projection-handler","text":"If you want to build or create all projections from scratch, then you can also use the ProjectionRepositoryTarget. In this, the individual projections are iterated and the events are then passed on. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionHandlerTarget ; $target = new ProjectionHandlerTarget ( $projectionHandler );","title":"Projection Handler"},{"location":"pipeline/#in-memory_1","text":"There is also an in-memory variant for the target. This target can also be used for tests. With the messages method you get all Messages that have reached the target. use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget ; $target = new InMemoryTarget (); // run pipeline $messages = $target -> messages ();","title":"In Memory"},{"location":"pipeline/#middlewares","text":"Middelwares can be used to manipulate, delete or expand messages or events during the process. It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware.","title":"Middlewares"},{"location":"pipeline/#exclude","text":"With this middleware you can exclude certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; $middleware = new ExcludeEventMiddleware ([ EmailChanged :: class ]); After this middleware, the playhead must be recalculated!","title":"exclude"},{"location":"pipeline/#include","text":"With this middleware you can only allow certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware ; $middleware = new IncludeEventMiddleware ([ ProfileCreated :: class ]); After this middleware, the playhead must be recalculated!","title":"include"},{"location":"pipeline/#filter","text":"If the middlewares ExcludeEventMiddleware and IncludeEventMiddleware are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware ; $middleware = new FilterEventMiddleware ( function ( AggregateChanged $event ) { if ( ! $event instanceof ProfileCreated ) { return true ; } return $event -> allowNewsletter (); }); After this middleware, the playhead must be recalculated!","title":"filter"},{"location":"pipeline/#replace","text":"If you want to replace an event, you can use the ReplaceEventMiddleware . The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; $middleware = new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }); The middleware takes over the playhead and recordedAt information.","title":"replace"},{"location":"pipeline/#until","text":"A use case could also be that you want to look at the projection from a previous point in time. You can use the UntilEventMiddleware to only allow events that were recorded before this point in time. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ClassRenameMiddleware ; $middleware = new UntilEventMiddleware ( new DateTimeImmutable ( '2020-01-01 12:00:00' )); After this middleware, the playhead must be recalculated!","title":"until"},{"location":"pipeline/#recalculate-playhead","text":"This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware RecalculatePlayheadMiddleware can fix this problem. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new RecalculatePlayheadMiddleware (); You only need to add this middleware once at the end of the pipeline.","title":"recalculate playhead"},{"location":"pipeline/#chain","text":"If you want to group your middleware, you can use one or more ChainMiddleware . use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new ChainMiddleware ([ new ExcludeEventMiddleware ([ EmailChanged :: class ]), new RecalculatePlayheadMiddleware () ]);","title":"chain"},{"location":"processor/","text":"Processor The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a profile has been created: use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return ; } $this -> mailer -> send ( $event -> email (), 'Profile created' , '...' ); } } If you only want to listen to certain events, then you have to check it in the __invoke method.","title":"Processor"},{"location":"processor/#processor","text":"The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a profile has been created: use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return ; } $this -> mailer -> send ( $event -> email (), 'Profile created' , '...' ); } } If you only want to listen to certain events, then you have to check it in the __invoke method.","title":"Processor"},{"location":"projection/","text":"Projections With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch. Define Projection In this example we always create a new data set in a relational database when a profile is created: use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class ProfileProjection implements Projection { private Connection $connection ; public function __construct ( Connection $connection ) { $this -> connection = $connection ; } #[Create] public function create () : void { $this -> connection -> executeStatement ( 'CREATE TABLE IF NOT EXISTS projection_profile (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( 'DROP TABLE IF EXISTS projection_profile;' ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( ProfileCreated $profileCreated ) : void { $this -> connection -> executeStatement ( 'INSERT INTO projection_profile (`id`, `name`) VALUES(:id, :name);' , [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } } You should not execute any actions with projections, otherwise these will be executed again if you rebuild the projection! Projections have a create and a drop method that is executed when the projection is created or deleted. In some cases it may be that no schema has to be created for the projection, as the target does it automatically. In order for the projection to know which method is responsible for which event, the methods must be given the Handle attribute with the respective event class name. As soon as the event has been dispatched, the appropriate methods are then executed. Several projections can also listen to the same event. Register projections So that the projections are known and also executed, you have to add them to the ProjectionHandler . Then add this to the event bus using the ProjectionListener . use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\MetadataAwareProjectionHandler ; use Patchlevel\\EventSourcing\\Projection\\ProjectionListener ; $profileProjection = new ProfileProjection ( $connection ); $messageProjection = new MessageProjection ( $connection ); $projectionHandler = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $eventBus -> addListener ( new ProjectionListener ( $projectionHandler )); You can find out more about the event bus here . Setup Projection A projection schama or database usually has to be created beforehand. And with a rebuild, the projection has to be deleted. To make this possible, projections have two methods create and drop that can be defined and executed. Create Projection Schema Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> create (); Drop Projection Schema Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> drop ();","title":"Projection"},{"location":"projection/#projections","text":"With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch.","title":"Projections"},{"location":"projection/#define-projection","text":"In this example we always create a new data set in a relational database when a profile is created: use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class ProfileProjection implements Projection { private Connection $connection ; public function __construct ( Connection $connection ) { $this -> connection = $connection ; } #[Create] public function create () : void { $this -> connection -> executeStatement ( 'CREATE TABLE IF NOT EXISTS projection_profile (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( 'DROP TABLE IF EXISTS projection_profile;' ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( ProfileCreated $profileCreated ) : void { $this -> connection -> executeStatement ( 'INSERT INTO projection_profile (`id`, `name`) VALUES(:id, :name);' , [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } } You should not execute any actions with projections, otherwise these will be executed again if you rebuild the projection! Projections have a create and a drop method that is executed when the projection is created or deleted. In some cases it may be that no schema has to be created for the projection, as the target does it automatically. In order for the projection to know which method is responsible for which event, the methods must be given the Handle attribute with the respective event class name. As soon as the event has been dispatched, the appropriate methods are then executed. Several projections can also listen to the same event.","title":"Define Projection"},{"location":"projection/#register-projections","text":"So that the projections are known and also executed, you have to add them to the ProjectionHandler . Then add this to the event bus using the ProjectionListener . use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\MetadataAwareProjectionHandler ; use Patchlevel\\EventSourcing\\Projection\\ProjectionListener ; $profileProjection = new ProfileProjection ( $connection ); $messageProjection = new MessageProjection ( $connection ); $projectionHandler = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $eventBus -> addListener ( new ProjectionListener ( $projectionHandler )); You can find out more about the event bus here .","title":"Register projections"},{"location":"projection/#setup-projection","text":"A projection schama or database usually has to be created beforehand. And with a rebuild, the projection has to be deleted. To make this possible, projections have two methods create and drop that can be defined and executed.","title":"Setup Projection"},{"location":"projection/#create-projection-schema","text":"Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> create ();","title":"Create Projection Schema"},{"location":"projection/#drop-projection-schema","text":"Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> drop ();","title":"Drop Projection Schema"},{"location":"repository/","text":"Repository A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate. Create We offer two implementations. One is a DefaultRepository that only reads or writes the data from one store. And a SnapshotRepository that holds a state of the aggregate in a cache so that loading and rebuilding of the aggregate is faster. Both repositories implement the Repository interface. This interface can be used for the typehints so that a change is possible at any time. Default Repository The default repository acts directly with the store and therefore needs one. The event bus is used as a further parameter to dispatch new events. Finally, the aggregate class is needed, which aggregates the repository should take care of. use Patchlevel\\EventSourcing\\Repository\\Repository ; $repository = new Repository ( $store , $eventBus , Profile :: class ); You can find out more about stores here Snapshot Repository The SnapshotRepository is instantiated just like the DefaultRepository, except that it also needs a SnapshotStore to load and save the Snapshots . use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $snapshot = new DefaultSnapshotStore ([ /* adapters */ ]); $repository = new DefaultRepository ( $store , $eventBus , Profile :: class , $snapshot ); The aggregate must inherit from the SnapshotableAggregateRoot You can find out more about snapshots here Usage Each repository has three methods that are responsible for loading an aggregate , saving it or checking whether it exists. Save An aggregate can be saved . All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database. After the events have been written, the new events are dispatched on the event bus . $profile = Profile :: create ( 'david.badura@patchlevel.de' ); $repository -> save ( $profile ); All events are written to the database with one transaction in order to ensure data consistency. Load An aggregate can be loaded using the load method. All events for the aggregate are loaded from the database and the current state is rebuilt. $profile = $repository -> load ( '229286ff-6f95-4df6-bc72-0a239fe7b284' ); You can only fetch one aggregate at a time and don't do any complex queries either. Projections are used for this purpose. The repository ensures that only one instance per aggregate is returned. A strict instance comparison is therefore easily possible. Has You can also check whether an aggregate with a certain id exists. It is checked whether any event with this id exists in the database. if ( $repository -> has ( '229286ff-6f95-4df6-bc72-0a239fe7b284' )) { // ... } The query is fast and does not load any event. This means that the state of the aggregate is not rebuild either.","title":"Repository"},{"location":"repository/#repository","text":"A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate.","title":"Repository"},{"location":"repository/#create","text":"We offer two implementations. One is a DefaultRepository that only reads or writes the data from one store. And a SnapshotRepository that holds a state of the aggregate in a cache so that loading and rebuilding of the aggregate is faster. Both repositories implement the Repository interface. This interface can be used for the typehints so that a change is possible at any time.","title":"Create"},{"location":"repository/#default-repository","text":"The default repository acts directly with the store and therefore needs one. The event bus is used as a further parameter to dispatch new events. Finally, the aggregate class is needed, which aggregates the repository should take care of. use Patchlevel\\EventSourcing\\Repository\\Repository ; $repository = new Repository ( $store , $eventBus , Profile :: class ); You can find out more about stores here","title":"Default Repository"},{"location":"repository/#snapshot-repository","text":"The SnapshotRepository is instantiated just like the DefaultRepository, except that it also needs a SnapshotStore to load and save the Snapshots . use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $snapshot = new DefaultSnapshotStore ([ /* adapters */ ]); $repository = new DefaultRepository ( $store , $eventBus , Profile :: class , $snapshot ); The aggregate must inherit from the SnapshotableAggregateRoot You can find out more about snapshots here","title":"Snapshot Repository"},{"location":"repository/#usage","text":"Each repository has three methods that are responsible for loading an aggregate , saving it or checking whether it exists.","title":"Usage"},{"location":"repository/#save","text":"An aggregate can be saved . All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database. After the events have been written, the new events are dispatched on the event bus . $profile = Profile :: create ( 'david.badura@patchlevel.de' ); $repository -> save ( $profile ); All events are written to the database with one transaction in order to ensure data consistency.","title":"Save"},{"location":"repository/#load","text":"An aggregate can be loaded using the load method. All events for the aggregate are loaded from the database and the current state is rebuilt. $profile = $repository -> load ( '229286ff-6f95-4df6-bc72-0a239fe7b284' ); You can only fetch one aggregate at a time and don't do any complex queries either. Projections are used for this purpose. The repository ensures that only one instance per aggregate is returned. A strict instance comparison is therefore easily possible.","title":"Load"},{"location":"repository/#has","text":"You can also check whether an aggregate with a certain id exists. It is checked whether any event with this id exists in the database. if ( $repository -> has ( '229286ff-6f95-4df6-bc72-0a239fe7b284' )) { // ... } The query is fast and does not load any event. This means that the state of the aggregate is not rebuild either.","title":"Has"},{"location":"snapshots/","text":"Snapshots Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all. Configuration To use the snapshot system, the SnapshotRepository must be used. In addition, a SnapshotStore must then be given. use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $adapter = new Psr16SnapshotAdapter ( $cache ); $snapshotStore = new DefaultSnapshotStore ([ 'default' => $adapter ]); $repository = new DefaultRepository ( $store , $eventStream , Profile :: class , $snapshotStore ); You can read more about Repository here . So that the state can also be cached, the aggregate must be taught how to serialize and deserialize its state. To do this, the aggregate must inherit from the SnapshotableAggregateRoot instead of the AggregateRoot and implement the necessary methods. use Patchlevel\\EventSourcing\\Aggregate\\SnapshotableAggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends SnapshotableAggregateRoot { // ... protected function serialize () : array { return [ 'id' => $this -> id , ]; } protected static function deserialize ( array $payload ) : static { $self = new static (); $self -> id = $payload [ 'id' ]; return $self ; } } In the end it has to be possible to serialize it as json. Batch Adapter We offer a few SnapshotAdapter implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed: symfony cache laminas cache scrapbook psr6 A Psr6SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter ; $adapter = new Psr6SnapshotAdapter ( $cache ); psr16 A Psr16SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; $adapter = new Psr16SnapshotAdapter ( $cache ); in memory A InMemorySnapshotAdapter that can be used for test purposes. use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter ; $adapter = new InMemorySnapshotAdapter ();","title":"Snapshots"},{"location":"snapshots/#snapshots","text":"Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all.","title":"Snapshots"},{"location":"snapshots/#configuration","text":"To use the snapshot system, the SnapshotRepository must be used. In addition, a SnapshotStore must then be given. use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $adapter = new Psr16SnapshotAdapter ( $cache ); $snapshotStore = new DefaultSnapshotStore ([ 'default' => $adapter ]); $repository = new DefaultRepository ( $store , $eventStream , Profile :: class , $snapshotStore ); You can read more about Repository here . So that the state can also be cached, the aggregate must be taught how to serialize and deserialize its state. To do this, the aggregate must inherit from the SnapshotableAggregateRoot instead of the AggregateRoot and implement the necessary methods. use Patchlevel\\EventSourcing\\Aggregate\\SnapshotableAggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends SnapshotableAggregateRoot { // ... protected function serialize () : array { return [ 'id' => $this -> id , ]; } protected static function deserialize ( array $payload ) : static { $self = new static (); $self -> id = $payload [ 'id' ]; return $self ; } } In the end it has to be possible to serialize it as json.","title":"Configuration"},{"location":"snapshots/#batch","text":"","title":"Batch"},{"location":"snapshots/#adapter","text":"We offer a few SnapshotAdapter implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed: symfony cache laminas cache scrapbook","title":"Adapter"},{"location":"snapshots/#psr6","text":"A Psr6SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter ; $adapter = new Psr6SnapshotAdapter ( $cache );","title":"psr6"},{"location":"snapshots/#psr16","text":"A Psr16SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; $adapter = new Psr16SnapshotAdapter ( $cache );","title":"psr16"},{"location":"snapshots/#in-memory","text":"A InMemorySnapshotAdapter that can be used for test purposes. use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter ; $adapter = new InMemorySnapshotAdapter ();","title":"in memory"},{"location":"store/","text":"Store In the end, the events/messages have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. But it is also possible to develop your own store by implementing the Store interface. Create DBAL connection The first thing we need for our store is a DBAL connection: use Doctrine\\DBAL\\DriverManager ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); You can find out more about how to create a connection here Store types We offer two store strategies that you can choose as you like. Single Table Store With the SingleTableStore everything is saved in one table. The dbal connection is needed, a mapping of the aggregate class and aggregate name and, last but not least, the table name. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $store = new SingleTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); You can switch between strategies using the pipeline . Multi Table Store With the MultiTableStore a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. The dbal connection is needed, a mapping of the aggregate class and table name and, last but not least, the table name for the metadata. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; $store = new MultiTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); You can switch between strategies using the pipeline . Transaction // TODO Schema Manager With the help of the SchemaManager , the database structure can be created, updated and deleted. Create schema use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> create ( $store ); Update schema use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> update ( $store ); Drop schema use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> drop ( $store ); Migration You can also manage your schema with doctrine migrations. In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations We have added a schema provider for doctrine migrations so that you just have to plug the whole thing together. use Patchlevel\\EventSourcing\\Schema\\MigrationSchemaProvider ; $schemaProvider = new MigrationSchemaProvider ( $store ); You can plug this together, for example, as follows to create CLI applications like cli.php : use Doctrine\\DBAL\\DriverManager ; use Doctrine\\Migrations\\DependencyFactory ; use Doctrine\\Migrations\\Configuration\\Migration\\PhpFile ; use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection ; use Doctrine\\Migrations\\Tools\\Console\\Command ; use Symfony\\Component\\Console\\Application ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $config = new PhpFile ( 'migrations.php' ); $dependencyFactory = DependencyFactory :: fromConnection ( $config , new ExistingConnection ( $connection ) ); $store = /* define your doctrine store */ ; $dependencyFactory -> setService ( SchemaProvider :: class , new MigrationSchemaProvider ( $store ) ); $cli = new Application ( 'Doctrine Migrations' ); $cli -> setCatchExceptions ( true ); $cli -> addCommands ( array ( new Command\\ExecuteCommand ( $dependencyFactory ), new Command\\GenerateCommand ( $dependencyFactory ), new Command\\LatestCommand ( $dependencyFactory ), new Command\\ListCommand ( $dependencyFactory ), new Command\\MigrateCommand ( $dependencyFactory ), new Command\\DiffCommand ( $dependencyFactory ), new Command\\StatusCommand ( $dependencyFactory ), new Command\\VersionCommand ( $dependencyFactory ), )); $cli -> run (); Here you can find more information on how to configure doctrine migration . Now you can execute commands like: cli.php migrations:diff cli.php migrations:migrate","title":"Store"},{"location":"store/#store","text":"In the end, the events/messages have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. But it is also possible to develop your own store by implementing the Store interface.","title":"Store"},{"location":"store/#create-dbal-connection","text":"The first thing we need for our store is a DBAL connection: use Doctrine\\DBAL\\DriverManager ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); You can find out more about how to create a connection here","title":"Create DBAL connection"},{"location":"store/#store-types","text":"We offer two store strategies that you can choose as you like.","title":"Store types"},{"location":"store/#single-table-store","text":"With the SingleTableStore everything is saved in one table. The dbal connection is needed, a mapping of the aggregate class and aggregate name and, last but not least, the table name. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $store = new SingleTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); You can switch between strategies using the pipeline .","title":"Single Table Store"},{"location":"store/#multi-table-store","text":"With the MultiTableStore a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. The dbal connection is needed, a mapping of the aggregate class and table name and, last but not least, the table name for the metadata. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; $store = new MultiTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); You can switch between strategies using the pipeline .","title":"Multi Table Store"},{"location":"store/#transaction","text":"// TODO","title":"Transaction"},{"location":"store/#schema-manager","text":"With the help of the SchemaManager , the database structure can be created, updated and deleted.","title":"Schema Manager"},{"location":"store/#create-schema","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> create ( $store );","title":"Create schema"},{"location":"store/#update-schema","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> update ( $store );","title":"Update schema"},{"location":"store/#drop-schema","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> drop ( $store );","title":"Drop schema"},{"location":"store/#migration","text":"You can also manage your schema with doctrine migrations. In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations We have added a schema provider for doctrine migrations so that you just have to plug the whole thing together. use Patchlevel\\EventSourcing\\Schema\\MigrationSchemaProvider ; $schemaProvider = new MigrationSchemaProvider ( $store ); You can plug this together, for example, as follows to create CLI applications like cli.php : use Doctrine\\DBAL\\DriverManager ; use Doctrine\\Migrations\\DependencyFactory ; use Doctrine\\Migrations\\Configuration\\Migration\\PhpFile ; use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection ; use Doctrine\\Migrations\\Tools\\Console\\Command ; use Symfony\\Component\\Console\\Application ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $config = new PhpFile ( 'migrations.php' ); $dependencyFactory = DependencyFactory :: fromConnection ( $config , new ExistingConnection ( $connection ) ); $store = /* define your doctrine store */ ; $dependencyFactory -> setService ( SchemaProvider :: class , new MigrationSchemaProvider ( $store ) ); $cli = new Application ( 'Doctrine Migrations' ); $cli -> setCatchExceptions ( true ); $cli -> addCommands ( array ( new Command\\ExecuteCommand ( $dependencyFactory ), new Command\\GenerateCommand ( $dependencyFactory ), new Command\\LatestCommand ( $dependencyFactory ), new Command\\ListCommand ( $dependencyFactory ), new Command\\MigrateCommand ( $dependencyFactory ), new Command\\DiffCommand ( $dependencyFactory ), new Command\\StatusCommand ( $dependencyFactory ), new Command\\VersionCommand ( $dependencyFactory ), )); $cli -> run (); Here you can find more information on how to configure doctrine migration . Now you can execute commands like: cli.php migrations:diff cli.php migrations:migrate","title":"Migration"},{"location":"tests/","text":"Tests The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events. use PHPUnit\\Framework\\TestCase ; final class ProfileTest extends TestCase { use AggregateTestHelper ; public function testCreateProfile () : void { $id = ProfileId :: generate (); $profile = Profile :: createProfile ( $id , Email :: fromString ( 'foo@email.com' )); self :: assertRecordedEvents ( $profile , [ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ] ); self :: assertEquals ( 'foo@email.com' , $profile -> email () -> toString ()); } public function testChangeName () : void { $id = ProfileId :: generate (); $profile = self :: createAggregateFromEvents ([ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ]); $profile -> changeEmail ( Email :: fromString ( 'bar@email.com' )); self :: assertRecordedEvents ( $profile , [ new EmailChanged ( Email :: fromString ( 'bar@email.com' )), ] ); self :: assertEquals ( 'bar@email.com' , $profile -> email () -> toString ()); } }","title":"Tests"},{"location":"tests/#tests","text":"The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events. use PHPUnit\\Framework\\TestCase ; final class ProfileTest extends TestCase { use AggregateTestHelper ; public function testCreateProfile () : void { $id = ProfileId :: generate (); $profile = Profile :: createProfile ( $id , Email :: fromString ( 'foo@email.com' )); self :: assertRecordedEvents ( $profile , [ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ] ); self :: assertEquals ( 'foo@email.com' , $profile -> email () -> toString ()); } public function testChangeName () : void { $id = ProfileId :: generate (); $profile = self :: createAggregateFromEvents ([ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ]); $profile -> changeEmail ( Email :: fromString ( 'bar@email.com' )); self :: assertRecordedEvents ( $profile , [ new EmailChanged ( Email :: fromString ( 'bar@email.com' )), ] ); self :: assertEquals ( 'bar@email.com' , $profile -> email () -> toString ()); } }","title":"Tests"},{"location":"tools/","text":"Tools The library offers a few developer tools to simplify the work and debug of event sourcing. Watch We have implemented a watch server that can be used for development. Every event that is saved is sent to the watch server using a watch listener. You can subscribe to it and display the information anywhere, e.g. in the CLI. Watch client The watch client and the listener are used to send all events that are saved to a specific host. use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServerClient ; use Patchlevel\\EventSourcing\\WatchServer\\WatchListener ; $watchServerClient = new SocketWatchServerClient ( '127.0.0.1:5000' , $serializer ); $watchListener = new WatchListener ( $watchServerClient ); This should only be used for dev purposes and should not be registered in production. Watch server The watch server is used to receive all events that are sent. You can subscribe to the watch server and process or display each event as you wish. As soon as you execute start , the server will be started until you terminate the php process. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $watchServer -> listen ( function ( Message $message ) { var_dump ( $message ); } ); $watchServer -> start (); The host must match the one defined in the watch server client. Here is an example of how to use it with a symfony cli. use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; use Symfony\\Component\\Console\\Application ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $command = new WatchCommand ( $watchServer ); $cli -> addCommands ([ /* more commands */ new Command\\WatchCommand ( $watchServer ), ]); $cli -> run (); The command can be terminated with ctrl+c or control+c .","title":"Tools"},{"location":"tools/#tools","text":"The library offers a few developer tools to simplify the work and debug of event sourcing.","title":"Tools"},{"location":"tools/#watch","text":"We have implemented a watch server that can be used for development. Every event that is saved is sent to the watch server using a watch listener. You can subscribe to it and display the information anywhere, e.g. in the CLI.","title":"Watch"},{"location":"tools/#watch-client","text":"The watch client and the listener are used to send all events that are saved to a specific host. use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServerClient ; use Patchlevel\\EventSourcing\\WatchServer\\WatchListener ; $watchServerClient = new SocketWatchServerClient ( '127.0.0.1:5000' , $serializer ); $watchListener = new WatchListener ( $watchServerClient ); This should only be used for dev purposes and should not be registered in production.","title":"Watch client"},{"location":"tools/#watch-server","text":"The watch server is used to receive all events that are sent. You can subscribe to the watch server and process or display each event as you wish. As soon as you execute start , the server will be started until you terminate the php process. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $watchServer -> listen ( function ( Message $message ) { var_dump ( $message ); } ); $watchServer -> start (); The host must match the one defined in the watch server client. Here is an example of how to use it with a symfony cli. use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; use Symfony\\Component\\Console\\Application ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $command = new WatchCommand ( $watchServer ); $cli -> addCommands ([ /* more commands */ new Command\\WatchCommand ( $watchServer ), ]); $cli -> run (); The command can be terminated with ctrl+c or control+c .","title":"Watch server"}]}