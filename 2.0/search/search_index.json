{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Event-Sourcing A lightweight but also all-inclusive event sourcing library with a focus on developer experience. Features Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony Installation composer require patchlevel/event-sourcing Integration Symfony Psalm","title":"Introduction"},{"location":"#event-sourcing","text":"A lightweight but also all-inclusive event sourcing library with a focus on developer experience.","title":"Event-Sourcing"},{"location":"#features","text":"Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony","title":"Features"},{"location":"#installation","text":"composer require patchlevel/event-sourcing","title":"Installation"},{"location":"#integration","text":"Symfony Psalm","title":"Integration"},{"location":"aggregate/","text":"Aggregate Abstract Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. [...] DDD Aggregate - Martin Flower An AggregateRoot has to inherit from AggregateRoot and need to implement the method aggregateRootId . aggregateRootId is the identifier from AggregateRoot like a primary key for an entity. The events will be added later, but the following is enough to make it executable: To register an aggregate you have to set the Aggregate attribute over the class, otherwise it will not be recognized as an aggregate. There you also have to give the aggregate a name. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; public function aggregateRootId () : string { return $this -> id ; } public static function create ( string $id ) : self { $self = new self (); // todo: record create event return $self ; } } Warning The aggregate is not yet finished and has only been built to the point that you can instantiate the object. Note An aggregateId can be an uuid , you can find more about this here . We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like createFromRegistration . After the basic structure for an aggregate is in place, it could theoretically be saved: use Patchlevel\\EventSourcing\\Repository\\Repository ; final class CreateProfileHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( CreateProfile $command ) : void { $profile = Profile :: create ( $command -> id ()); $this -> profileRepository -> save ( $profile ); } } Warning If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens. Note A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service. Create a new aggregate In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event ProfileCreated : use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Note You can find out more about events here . After we have defined the event, we have to adapt the creation of the profile: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : self { $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Tip Prefixing the apply methods with \"apply\" improves readability. In our named constructor create we have now created the event and recorded it with the method record . The aggregate remembers all recorded events in order to save them later. At the same time, a defined apply method is executed directly so that we can change our state. So that the AggregateRoot also knows which method it should call, we have to provide it with the Apply attributes . We did that in the applyProfileCreated method. In this method we change the Profile properties id and name with the transferred values. Modify an aggregate In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a NameChanged event: use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name ) { } } Note Events should best be written in the past, as they describe a state that has happened. After we have defined the event, we can define a new public method called changeName to change the profile name. This method then creates the event NameChanged and records it: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } public function changeName ( string $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } We have also defined a new apply method named applyNameChanged where we change the name depending on the value in the event. When using it, it can look like this: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Repository\\Repository ; final class ChangeNameHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( ChangeName $command ) : void { $profile = $this -> profileRepository -> load ( $command -> id ()); $profile -> changeName ( $command -> name ()); $this -> profileRepository -> save ( $profile ); } } Note You can read more about Repository here . Here the aggregate is loaded from the repository by fetching all events from the database. These events are then executed again with the apply methods in order to rebuild the current state. All of this happens automatically in the load method. The method changeName is then executed on the aggregate to change the name. In this method the event NameChanged is generated and recorded. The applyNameChanged method was also called again internally to adjust the state. When the save method is called on the repository, all newly recorded events are then fetched and written to the database. Multiple apply attributes on the same method You can also define several apply attributes with different events using the same method. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] #[Apply(NameChanged::class)] protected function applyProfileCreated ( ProfileCreated | NameChanged $event ) : void { if ( $event instanceof ProfileCreated ) { $this -> id = $event -> profileId ; } $this -> name = $event -> name ; } } Suppress missing apply methods Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future, to listen on it or to create a projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the SuppressMissingApply attribute. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([NameChanged::class])] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Suppress missing apply for all methods You can also completely deactivate the exceptions for missing apply methods. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply(SuppressMissingApply::ALL)] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Warning When all events are suppressed, debugging becomes more difficult if you forget an apply method. Business rules Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group. These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone. A further check in the apply method is also not possible because these events have already happened and were then also saved in the database. In the next example we want to make sure that the name is at least 3 characters long : use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... public function name () : string { return $this -> name ; } public function changeName ( string $name ) : void { if ( strlen ( $name ) < 3 ) { throw new NameIsToShortException ( $name ); } $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name (); } } Danger Disregarding this can break the rebuilding of the state! We have now ensured that this rule takes effect when a name is changed with the method changeName . But when we create a new profile this rule does not currently apply. In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } We can now use the value object Name in our aggregate: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; public static function create ( string $id , Name $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } // ... public function name () : Name { return $this -> name ; } public function changeName ( Name $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } In order for the whole thing to work, we still have to adapt our NameChanged event, since we only expected a string before but now passed a Name value object. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } Warning The payload must be serializable and unserializable as json. Note You can find out more about event normalizer here . There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the apply methods are always executed immediately. In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event FullyBooked , if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([FullyBooked::class])] final class Hotel extends AggregateRoot { private const SIZE = 5 ; private int $people ; // ... public function book ( string $name ) : void { if ( $this -> people === self :: SIZE ) { throw new NoPlaceException ( $name ); } $this -> recordThat ( new RoomBocked ( $name )); if ( $this -> people === self :: SIZE ) { $this -> recordThat ( new FullyBooked ()); } } #[Apply] protected function applyRoomBocked ( RoomBocked $event ) : void { $this -> people ++ ; } } Aggregate Root Registry The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an AggregateRootRegistry for this purpose. The registry is a simple hashmap between aggregate name and aggregate class. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = new AggregateRootRegistry ([ 'profile' => Profile :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeAggregateRootRegistryFactory is used. There, with the help of paths, all classes with the attribute Aggregate are searched for and the AggregateRootRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AttributeAggregateRootRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Aggregate"},{"location":"aggregate/#aggregate","text":"Abstract Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. [...] DDD Aggregate - Martin Flower An AggregateRoot has to inherit from AggregateRoot and need to implement the method aggregateRootId . aggregateRootId is the identifier from AggregateRoot like a primary key for an entity. The events will be added later, but the following is enough to make it executable: To register an aggregate you have to set the Aggregate attribute over the class, otherwise it will not be recognized as an aggregate. There you also have to give the aggregate a name. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; public function aggregateRootId () : string { return $this -> id ; } public static function create ( string $id ) : self { $self = new self (); // todo: record create event return $self ; } } Warning The aggregate is not yet finished and has only been built to the point that you can instantiate the object. Note An aggregateId can be an uuid , you can find more about this here . We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like createFromRegistration . After the basic structure for an aggregate is in place, it could theoretically be saved: use Patchlevel\\EventSourcing\\Repository\\Repository ; final class CreateProfileHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( CreateProfile $command ) : void { $profile = Profile :: create ( $command -> id ()); $this -> profileRepository -> save ( $profile ); } } Warning If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens. Note A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service.","title":"Aggregate"},{"location":"aggregate/#create-a-new-aggregate","text":"In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event ProfileCreated : use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Note You can find out more about events here . After we have defined the event, we have to adapt the creation of the profile: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : self { $self = new self (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Tip Prefixing the apply methods with \"apply\" improves readability. In our named constructor create we have now created the event and recorded it with the method record . The aggregate remembers all recorded events in order to save them later. At the same time, a defined apply method is executed directly so that we can change our state. So that the AggregateRoot also knows which method it should call, we have to provide it with the Apply attributes . We did that in the applyProfileCreated method. In this method we change the Profile properties id and name with the transferred values.","title":"Create a new aggregate"},{"location":"aggregate/#modify-an-aggregate","text":"In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a NameChanged event: use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name ) { } } Note Events should best be written in the past, as they describe a state that has happened. After we have defined the event, we can define a new public method called changeName to change the profile name. This method then creates the event NameChanged and records it: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; public function aggregateRootId () : string { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $id , string $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } public function changeName ( string $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } We have also defined a new apply method named applyNameChanged where we change the name depending on the value in the event. When using it, it can look like this: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Repository\\Repository ; final class ChangeNameHandler { private Repository $profileRepository ; public function __construct ( Repository $profileRepository ) { $this -> profileRepository = $profileRepository ; } public function __invoke ( ChangeName $command ) : void { $profile = $this -> profileRepository -> load ( $command -> id ()); $profile -> changeName ( $command -> name ()); $this -> profileRepository -> save ( $profile ); } } Note You can read more about Repository here . Here the aggregate is loaded from the repository by fetching all events from the database. These events are then executed again with the apply methods in order to rebuild the current state. All of this happens automatically in the load method. The method changeName is then executed on the aggregate to change the name. In this method the event NameChanged is generated and recorded. The applyNameChanged method was also called again internally to adjust the state. When the save method is called on the repository, all newly recorded events are then fetched and written to the database.","title":"Modify an aggregate"},{"location":"aggregate/#multiple-apply-attributes-on-the-same-method","text":"You can also define several apply attributes with different events using the same method. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply(ProfileCreated::class)] #[Apply(NameChanged::class)] protected function applyProfileCreated ( ProfileCreated | NameChanged $event ) : void { if ( $event instanceof ProfileCreated ) { $this -> id = $event -> profileId ; } $this -> name = $event -> name ; } }","title":"Multiple apply attributes on the same method"},{"location":"aggregate/#suppress-missing-apply-methods","text":"Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future, to listen on it or to create a projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the SuppressMissingApply attribute. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([NameChanged::class])] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } }","title":"Suppress missing apply methods"},{"location":"aggregate/#suppress-missing-apply-for-all-methods","text":"You can also completely deactivate the exceptions for missing apply methods. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply(SuppressMissingApply::ALL)] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId ; $this -> name = $event -> name ; } } Warning When all events are suppressed, debugging becomes more difficult if you forget an apply method.","title":"Suppress missing apply for all methods"},{"location":"aggregate/#business-rules","text":"Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group. These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone. A further check in the apply method is also not possible because these events have already happened and were then also saved in the database. In the next example we want to make sure that the name is at least 3 characters long : use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private string $name ; // ... public function name () : string { return $this -> name ; } public function changeName ( string $name ) : void { if ( strlen ( $name ) < 3 ) { throw new NameIsToShortException ( $name ); } $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name (); } } Danger Disregarding this can break the rebuilding of the state! We have now ensured that this rule takes effect when a name is changed with the method changeName . But when we create a new profile this rule does not currently apply. In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } We can now use the value object Name in our aggregate: use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private string $id ; private Name $name ; public static function create ( string $id , Name $name ) : static { $self = new static (); $self -> recordThat ( new ProfileCreated ( $id , $name )); return $self ; } // ... public function name () : Name { return $this -> name ; } public function changeName ( Name $name ) : void { $this -> recordThat ( new NameChanged ( $name )); } #[Apply] protected function applyNameChanged ( NameChanged $event ) : void { $this -> name = $event -> name ; } } In order for the whole thing to work, we still have to adapt our NameChanged event, since we only expected a string before but now passed a Name value object. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } Warning The payload must be serializable and unserializable as json. Note You can find out more about event normalizer here . There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the apply methods are always executed immediately. In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event FullyBooked , if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels. use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply ; #[Aggregate('profile')] #[SuppressMissingApply([FullyBooked::class])] final class Hotel extends AggregateRoot { private const SIZE = 5 ; private int $people ; // ... public function book ( string $name ) : void { if ( $this -> people === self :: SIZE ) { throw new NoPlaceException ( $name ); } $this -> recordThat ( new RoomBocked ( $name )); if ( $this -> people === self :: SIZE ) { $this -> recordThat ( new FullyBooked ()); } } #[Apply] protected function applyRoomBocked ( RoomBocked $event ) : void { $this -> people ++ ; } }","title":"Business rules"},{"location":"aggregate/#aggregate-root-registry","text":"The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an AggregateRootRegistry for this purpose. The registry is a simple hashmap between aggregate name and aggregate class. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = new AggregateRootRegistry ([ 'profile' => Profile :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeAggregateRootRegistryFactory is used. There, with the help of paths, all classes with the attribute Aggregate are searched for and the AggregateRootRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AttributeAggregateRootRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; $aggregateRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Aggregate Root Registry"},{"location":"cli/","text":"CLI The library also offers symfony cli commands to create or delete databases . It is also possible to manage the schema and projections . These commands are optional and only wrap existing functionalities that are also available in this way. Require package To use the symfony cli command you first have to install the packet. composer require symfony/console Database commands There are two commands for creating and deleting a database. DatabaseCreateCommand: event-sourcing:database:create DatabaseDropCommand: event-sourcing:database:drop Schema commands The database schema can also be created, updated and dropped. SchemaCreateCommand: event-sourcing:schema:create SchemaUpdateCommand: event-sourcing:schema:update SchemaDropCommand: event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this. Projection commands The creation, deletion and rebuilding of the projections is also possible via the cli. ProjectionCreateCommand: event-sourcing:projection:create ProjectionDropCommand: event-sourcing:projection:drop ProjectionRebuildCommand: event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection. CLI example A cli php file can look like this: use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\Console\\DoctrineHelper ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; use Symfony\\Component\\Console\\Application ; $store = /* define your doctrine store */ ; $projectionRepository = /* create a project repository */ ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $doctrineHelper = new DoctrineHelper (); $schemaManager = new DoctrineSchemaManager (); $cli -> addCommands ( array ( new Command\\DatabaseCreateCommand ( $store , $doctrineHelper ), new Command\\DatabaseDropCommand ( $store , $doctrineHelper ), new Command\\ProjectionCreateCommand ( $projectionRepository ), new Command\\ProjectionDropCommand ( $projectionRepository ), new Command\\ProjectionRebuildCommand ( $store , $projectionRepository ), new Command\\SchemaCreateCommand ( $store , $schemaManager ), new Command\\SchemaDropCommand ( $store , $schemaManager ), new Command\\SchemaUpdateCommand ( $store , $schemaManager ), )); $cli -> run (); Note You can also register doctrine migration commands, see the store documentation for this.","title":"CLI"},{"location":"cli/#cli","text":"The library also offers symfony cli commands to create or delete databases . It is also possible to manage the schema and projections . These commands are optional and only wrap existing functionalities that are also available in this way.","title":"CLI"},{"location":"cli/#require-package","text":"To use the symfony cli command you first have to install the packet. composer require symfony/console","title":"Require package"},{"location":"cli/#database-commands","text":"There are two commands for creating and deleting a database. DatabaseCreateCommand: event-sourcing:database:create DatabaseDropCommand: event-sourcing:database:drop","title":"Database commands"},{"location":"cli/#schema-commands","text":"The database schema can also be created, updated and dropped. SchemaCreateCommand: event-sourcing:schema:create SchemaUpdateCommand: event-sourcing:schema:update SchemaDropCommand: event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this.","title":"Schema commands"},{"location":"cli/#projection-commands","text":"The creation, deletion and rebuilding of the projections is also possible via the cli. ProjectionCreateCommand: event-sourcing:projection:create ProjectionDropCommand: event-sourcing:projection:drop ProjectionRebuildCommand: event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection.","title":"Projection commands"},{"location":"cli/#cli-example","text":"A cli php file can look like this: use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\Console\\DoctrineHelper ; use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; use Symfony\\Component\\Console\\Application ; $store = /* define your doctrine store */ ; $projectionRepository = /* create a project repository */ ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $doctrineHelper = new DoctrineHelper (); $schemaManager = new DoctrineSchemaManager (); $cli -> addCommands ( array ( new Command\\DatabaseCreateCommand ( $store , $doctrineHelper ), new Command\\DatabaseDropCommand ( $store , $doctrineHelper ), new Command\\ProjectionCreateCommand ( $projectionRepository ), new Command\\ProjectionDropCommand ( $projectionRepository ), new Command\\ProjectionRebuildCommand ( $store , $projectionRepository ), new Command\\SchemaCreateCommand ( $store , $schemaManager ), new Command\\SchemaDropCommand ( $store , $schemaManager ), new Command\\SchemaUpdateCommand ( $store , $schemaManager ), )); $cli -> run (); Note You can also register doctrine migration commands, see the store documentation for this.","title":"CLI example"},{"location":"clock/","text":"Clock We have a Clock interface which enables you to replace the actual clock implementation in your services for testing purposes. We are using this clock to create the recorded_on datetime for the events. Note The Clock interface will be PSR-20 compatible as soon at it is published. For more information see here . SystemClock This uses the native system clock to return the DateTimeImmutable instance - in this case new DateTimeImmutable() . use Patchlevel\\EventSourcing\\Clock\\SystemClock ; $clock = new SystemClock (); $date = $clock -> now (); // get the actual datetime $date2 = $clock -> now (); $date == $date2 // false $date === $date2 // false FrozenClock This implementation should only be used for the tests. This enables you to freeze the time and with that to have deterministic tests. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $date = new DateTimeImmutable (); $clock = new FrozenClock ( $date ); $frozenDate = $clock -> now (); // gets the date provided before $date == $frozenDate // true $date === $frozenDate // false The FrozenClock can also be updated with a new date, so you can test a jump in time. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $firstDate = new DateTimeImmutable (); $clock = new FrozenClock ( $firstDate ); $secondDate = new DateTimeImmutable (); $clock -> update ( $secondDate ); $frozenDate = $clock -> now (); $firstDate == $frozenDate // false $secondDate == $frozenDate // true Note The instance of the frozen datetime will be cloned internally, so the it's not the same instance but equals.","title":"Time / Clock"},{"location":"clock/#clock","text":"We have a Clock interface which enables you to replace the actual clock implementation in your services for testing purposes. We are using this clock to create the recorded_on datetime for the events. Note The Clock interface will be PSR-20 compatible as soon at it is published. For more information see here .","title":"Clock"},{"location":"clock/#systemclock","text":"This uses the native system clock to return the DateTimeImmutable instance - in this case new DateTimeImmutable() . use Patchlevel\\EventSourcing\\Clock\\SystemClock ; $clock = new SystemClock (); $date = $clock -> now (); // get the actual datetime $date2 = $clock -> now (); $date == $date2 // false $date === $date2 // false","title":"SystemClock"},{"location":"clock/#frozenclock","text":"This implementation should only be used for the tests. This enables you to freeze the time and with that to have deterministic tests. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $date = new DateTimeImmutable (); $clock = new FrozenClock ( $date ); $frozenDate = $clock -> now (); // gets the date provided before $date == $frozenDate // true $date === $frozenDate // false The FrozenClock can also be updated with a new date, so you can test a jump in time. use Patchlevel\\EventSourcing\\Clock\\FrozenClock ; $firstDate = new DateTimeImmutable (); $clock = new FrozenClock ( $firstDate ); $secondDate = new DateTimeImmutable (); $clock -> update ( $secondDate ); $frozenDate = $clock -> now (); $firstDate == $frozenDate // false $secondDate == $frozenDate // true Note The instance of the frozen datetime will be cloned internally, so the it's not the same instance but equals.","title":"FrozenClock"},{"location":"event_bus/","text":"Event Bus This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event wrapped in a message will be dispatched to the event bus . All listeners are then called for each event/message. Message A Message contains the event and related meta information such as the aggregate class and id. A message contains the following information: aggregate class aggregate id playhead event recorded on Each event is packed into a message and dispatched using the event bus. use Patchlevel\\EventSourcing\\EventBus\\Message ; $event = new NameChanged ( 'foo' ); $message = new Message ( Profile :: class , // aggregate class 'bca7576c-536f-4428-b694-7b1f00c714b7' , // aggregate id 2 , // playhead $event // event object ); $eventBus -> dispatch ( $message ); You don't have to create the message yourself, it is automatically created, saved and dispatched in the repository. Default event bus The library also delivers a light-weight event bus. This can only register listener and dispatch events. use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; $eventBus = new DefaultEventBus (); $eventBus -> addListener ( $mailListener ); $eventBus -> addListener ( $projectionListener ); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Symfony event bus You can also use the symfony message bus which is much more powerful. To use the optional symfony messenger you first have to install the packet. composer require symfony/messenger You can either let us build it with the create factory: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $eventBus = SymfonyEventBus :: create ([ $mailListener , $projectionListener ]); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Or plug it together by hand: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $symfonyMessenger = //... $eventBus = new SymfonyEventBus ( $symfonyMessenger ); Warning You can't mix it with a command bus. You should create a new bus for it. Note An event bus can have zero or more listeners on an event. You should allow no handler in the HandleMessageMiddleware . Listener A listener must implement the Listener interface and define the __invoke method. This listener is then called for all saved events / messages. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $listener = new class implements Listener { public function __invoke ( Message $message ) : void { if ( $message -> event () instanceof ProfileCreated ) { echo 'Welcome!' ; } } } Warning If you only want to listen to certain messages, then you have to check it in the __invoke method. Note Basically, listeners can be categorized according to their tasks. We have a processor and projections .","title":"Event Bus"},{"location":"event_bus/#event-bus","text":"This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event wrapped in a message will be dispatched to the event bus . All listeners are then called for each event/message.","title":"Event Bus"},{"location":"event_bus/#message","text":"A Message contains the event and related meta information such as the aggregate class and id. A message contains the following information: aggregate class aggregate id playhead event recorded on Each event is packed into a message and dispatched using the event bus. use Patchlevel\\EventSourcing\\EventBus\\Message ; $event = new NameChanged ( 'foo' ); $message = new Message ( Profile :: class , // aggregate class 'bca7576c-536f-4428-b694-7b1f00c714b7' , // aggregate id 2 , // playhead $event // event object ); $eventBus -> dispatch ( $message ); You don't have to create the message yourself, it is automatically created, saved and dispatched in the repository.","title":"Message"},{"location":"event_bus/#default-event-bus","text":"The library also delivers a light-weight event bus. This can only register listener and dispatch events. use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; $eventBus = new DefaultEventBus (); $eventBus -> addListener ( $mailListener ); $eventBus -> addListener ( $projectionListener ); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections .","title":"Default event bus"},{"location":"event_bus/#symfony-event-bus","text":"You can also use the symfony message bus which is much more powerful. To use the optional symfony messenger you first have to install the packet. composer require symfony/messenger You can either let us build it with the create factory: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $eventBus = SymfonyEventBus :: create ([ $mailListener , $projectionListener ]); Note You can determine the order in which the listeners are executed. For example, you can also add listeners after ProjectionListener to access the projections . Or plug it together by hand: use Patchlevel\\EventSourcing\\EventBus\\SymfonyEventBus ; $symfonyMessenger = //... $eventBus = new SymfonyEventBus ( $symfonyMessenger ); Warning You can't mix it with a command bus. You should create a new bus for it. Note An event bus can have zero or more listeners on an event. You should allow no handler in the HandleMessageMiddleware .","title":"Symfony event bus"},{"location":"event_bus/#listener","text":"A listener must implement the Listener interface and define the __invoke method. This listener is then called for all saved events / messages. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; $listener = new class implements Listener { public function __invoke ( Message $message ) : void { if ( $message -> event () instanceof ProfileCreated ) { echo 'Welcome!' ; } } } Warning If you only want to listen to certain messages, then you have to check it in the __invoke method. Note Basically, listeners can be categorized according to their tasks. We have a processor and projections .","title":"Listener"},{"location":"events/","text":"Events Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values. To register an event you have to set the Event attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name. use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event(name: 'profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Warning The payload must be serializable and unserializable as json. Tip An event should be named in the past because it has already happened. Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples: profile.created profile.name_changed hotel.guest_checked_out Serializer So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a JsonSerializer that can be given further instructions using attributes. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain' ]); The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later. Normalizer Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name , #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $changedAt ) {} } Note You can find out more about normalizer here . Event Registry The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = new EventRegistry ([ 'profile.created' => ProfileCreated :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeEventRegistryFactory is used. There, with the help of paths, all classes with the attribute Event are searched for and the EventRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Events"},{"location":"events/#events","text":"Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values. To register an event you have to set the Event attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name. use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event(name: 'profile.created')] final class ProfileCreated { public function __construct ( public readonly string $profileId , public readonly string $name ) {} } Warning The payload must be serializable and unserializable as json. Tip An event should be named in the past because it has already happened. Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples: profile.created profile.name_changed hotel.guest_checked_out","title":"Events"},{"location":"events/#serializer","text":"So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a JsonSerializer that can be given further instructions using attributes. use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain' ]); The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later.","title":"Serializer"},{"location":"events/#normalizer","text":"Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\DateTimeImmutableNormalizer ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( public readonly string $name , #[Normalize(new DateTimeImmutableNormalizer())] public readonly DateTimeImmutable $changedAt ) {} } Note You can find out more about normalizer here .","title":"Normalizer"},{"location":"events/#event-registry","text":"The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = new EventRegistry ([ 'profile.created' => ProfileCreated :: class ]); So that you don't have to create it by hand, you can use a factory. By default, the AttributeEventRegistryFactory is used. There, with the help of paths, all classes with the attribute Event are searched for and the EventRegistry is built up. use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory ; use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; $eventRegistry = ( new AttributeEventRegistryFactory ()) -> create ( $paths );","title":"Event Registry"},{"location":"getting_started/","text":"Getting Started In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. Create some events Define an aggregate root Create projections Add a processor Configure your application Setup database Play with your domain Define some events First we define the events that happen in our system. A hotel can be created with a name and a id : #[Event('hotel.created')] final class HotelCreated { public function __construct ( public readonly string $hotelId , public readonly string $hotelName ) { } } A guest can check in by name : #[Event('hotel.guest_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: #[Event('hotel.guest_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Note You can find out more about events here . Define aggregates Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('hotel')] final class Hotel extends AggregateRoot { private string $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( string $id , string $hotelName ) : static { $self = new static (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( $guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> hotelId ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id ; } } Note You can find out more about aggregates here . Define projections So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class HotelProjection implements Projection { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } #[Handle(HotelCreated::class)] public function handleHotelCreated ( HotelCreated $event ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $event -> hotelId , 'name' => $event -> hotelName , 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Note You can find out more about projections here . Processor In our example we also want to send an email to the head office as soon as a guest is checked in. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendCheckInEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $this -> mailer -> send ( 'hq@patchlevel.de' , 'Guest is checked in' , sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ) ); } } Note You can find out more about processor here . Configuration After we have defined everything, we still have to plug the whole thing together: use Doctrine\\DBAL\\DriverManager ; use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\MetadataAwareProjectionHandler ; use Patchlevel\\EventSourcing\\Projection\\ProjectionListener ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $mailer = /* your own mailer */ ; $hotelProjection = new HotelProjection ( $connection ); $projectionHandler = new MetadataAwareProjectionHandler ([ $hotelProjection , ]); $eventBus = new DefaultEventBus (); $eventBus -> addListener ( new ProjectionListener ( $projectionHandler )); $eventBus -> addListener ( new SendCheckInEmailListener ( $mailer )); $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain/Hotel/Event' ]); $aggregateRegistry = ( new AttributeAggregateRootRegistryFactory ) -> create ([ 'src/Domain/Hotel' ]); $store = new SingleTableStore ( $connection , $serializer , $aggregateRegistry , 'eventstore' ); $hotelRepository = new DefaultRepository ( $store , $eventBus , Hotel :: class ); Note You can find out more about stores here . Database setup So that we can actually write the data to a database, we need the associated schema and databases. use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new DoctrineSchemaManager ()) -> create ( $store ); $projectionHandler -> create (); Note you can use the predefined cli commands for this. Usage We are now ready to use the Event Sourcing System. We can load, change and save aggregates. $hotel = Hotel :: create ( '1' , 'HOTEL' ); $hotel -> checkIn ( 'David' ); $hotel -> checkIn ( 'Daniel' ); $hotel -> checkOut ( 'David' ); $hotelRepository -> save ( $hotel ); $hotel2 = $hotelRepository -> load ( '2' ); $hotel2 -> checkIn ( 'David' ); $hotelRepository -> save ( $hotel2 ); Note An aggregateId can be an uuid , you can find more about this here . Result Success We have successfully implemented and used event sourcing. Feel free to browse further in the documentation for more detailed information. If there are still open questions, create a ticket on Github and we will try to help you.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. Create some events Define an aggregate root Create projections Add a processor Configure your application Setup database Play with your domain","title":"Getting Started"},{"location":"getting_started/#define-some-events","text":"First we define the events that happen in our system. A hotel can be created with a name and a id : #[Event('hotel.created')] final class HotelCreated { public function __construct ( public readonly string $hotelId , public readonly string $hotelName ) { } } A guest can check in by name : #[Event('hotel.guest_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: #[Event('hotel.guest_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Note You can find out more about events here .","title":"Define some events"},{"location":"getting_started/#define-aggregates","text":"Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; #[Aggregate('hotel')] final class Hotel extends AggregateRoot { private string $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( string $id , string $hotelName ) : static { $self = new static (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( $guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> hotelId ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id ; } } Note You can find out more about aggregates here .","title":"Define aggregates"},{"location":"getting_started/#define-projections","text":"So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class HotelProjection implements Projection { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } #[Handle(HotelCreated::class)] public function handleHotelCreated ( HotelCreated $event ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $event -> hotelId , 'name' => $event -> hotelName , 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Note You can find out more about projections here .","title":"Define projections"},{"location":"getting_started/#processor","text":"In our example we also want to send an email to the head office as soon as a guest is checked in. use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendCheckInEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $this -> mailer -> send ( 'hq@patchlevel.de' , 'Guest is checked in' , sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ) ); } } Note You can find out more about processor here .","title":"Processor"},{"location":"getting_started/#configuration","text":"After we have defined everything, we still have to plug the whole thing together: use Doctrine\\DBAL\\DriverManager ; use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\MetadataAwareProjectionHandler ; use Patchlevel\\EventSourcing\\Projection\\ProjectionListener ; use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $mailer = /* your own mailer */ ; $hotelProjection = new HotelProjection ( $connection ); $projectionHandler = new MetadataAwareProjectionHandler ([ $hotelProjection , ]); $eventBus = new DefaultEventBus (); $eventBus -> addListener ( new ProjectionListener ( $projectionHandler )); $eventBus -> addListener ( new SendCheckInEmailListener ( $mailer )); $serializer = DefaultEventSerializer :: createFromPaths ([ 'src/Domain/Hotel/Event' ]); $aggregateRegistry = ( new AttributeAggregateRootRegistryFactory ) -> create ([ 'src/Domain/Hotel' ]); $store = new SingleTableStore ( $connection , $serializer , $aggregateRegistry , 'eventstore' ); $hotelRepository = new DefaultRepository ( $store , $eventBus , Hotel :: class ); Note You can find out more about stores here .","title":"Configuration"},{"location":"getting_started/#database-setup","text":"So that we can actually write the data to a database, we need the associated schema and databases. use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new DoctrineSchemaManager ()) -> create ( $store ); $projectionHandler -> create (); Note you can use the predefined cli commands for this.","title":"Database setup"},{"location":"getting_started/#usage","text":"We are now ready to use the Event Sourcing System. We can load, change and save aggregates. $hotel = Hotel :: create ( '1' , 'HOTEL' ); $hotel -> checkIn ( 'David' ); $hotel -> checkIn ( 'Daniel' ); $hotel -> checkOut ( 'David' ); $hotelRepository -> save ( $hotel ); $hotel2 = $hotelRepository -> load ( '2' ); $hotel2 -> checkIn ( 'David' ); $hotelRepository -> save ( $hotel2 ); Note An aggregateId can be an uuid , you can find more about this here .","title":"Usage"},{"location":"getting_started/#result","text":"Success We have successfully implemented and used event sourcing. Feel free to browse further in the documentation for more detailed information. If there are still open questions, create a ticket on Github and we will try to help you.","title":"Result"},{"location":"message_decorator/","text":"Message Decorator There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With MessageDecorator we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on. We are internally using this to save the point of time the event is recorded. Here is the code from this message decorator. use Patchlevel\\EventSourcing\\Clock\\Clock ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class RecordedOnDecorator implements MessageDecorator { public function __construct ( private readonly Clock $clock ) { } public function __invoke ( Message $message ) : Message { return $message -> withRecordedOn ( $this -> clock -> now ()); } } Note The Message is immutable, for more information look up here . You can also use this feature to add your own metadata to your events. For this the have an extra methods on Message to add data withCustomHeader and to read this data later on customHeader . use Patchlevel\\EventSourcing\\EventBus\\Message ; final class OnSystemRecordedDecorator implements MessageDecorator { public function __invoke ( Message $message ) : Message { return $message -> withCustomHeader ( 'system' , 'accounting_system' ); } } Tip You can also set multiple headers with withCustomHeaders which expects an hashmap. Adding a message decorator","title":"Message Decorator"},{"location":"message_decorator/#message-decorator","text":"There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With MessageDecorator we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on. We are internally using this to save the point of time the event is recorded. Here is the code from this message decorator. use Patchlevel\\EventSourcing\\Clock\\Clock ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class RecordedOnDecorator implements MessageDecorator { public function __construct ( private readonly Clock $clock ) { } public function __invoke ( Message $message ) : Message { return $message -> withRecordedOn ( $this -> clock -> now ()); } } Note The Message is immutable, for more information look up here . You can also use this feature to add your own metadata to your events. For this the have an extra methods on Message to add data withCustomHeader and to read this data later on customHeader . use Patchlevel\\EventSourcing\\EventBus\\Message ; final class OnSystemRecordedDecorator implements MessageDecorator { public function __invoke ( Message $message ) : Message { return $message -> withCustomHeader ( 'system' , 'accounting_system' ); } } Tip You can also set multiple headers with withCustomHeaders which expects an hashmap.","title":"Message Decorator"},{"location":"message_decorator/#adding-a-message-decorator","text":"","title":"Adding a message decorator"},{"location":"migration/","text":"Migration You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. Warning To use the migration CLI commands, you have to configure the CLI beforehand. Installation In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations Configure Migration Schema Provider We have added a schema provider for doctrine migrations so that you just have to plug the whole thing together. use Patchlevel\\EventSourcing\\Schema\\MigrationSchemaProvider ; $schemaProvider = new MigrationSchemaProvider ( $store ); CLI example You can plug this together, for example, as follows to create CLI applications like cli.php : use Doctrine\\DBAL\\DriverManager ; use Doctrine\\Migrations\\DependencyFactory ; use Doctrine\\Migrations\\Configuration\\Migration\\PhpFile ; use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection ; use Doctrine\\Migrations\\Tools\\Console\\Command ; use Symfony\\Component\\Console\\Application ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $config = new PhpFile ( 'migrations.php' ); $dependencyFactory = DependencyFactory :: fromConnection ( $config , new ExistingConnection ( $connection ) ); $store = /* define your doctrine store */ ; $dependencyFactory -> setService ( SchemaProvider :: class , new MigrationSchemaProvider ( $store ) ); $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $cli -> addCommands ([ // other cli commands new Command\\ExecuteCommand ( $dependencyFactory , 'event-sourcing:migrations:execute' ), new Command\\GenerateCommand ( $dependencyFactory , 'event-sourcing:migrations:generate' ), new Command\\LatestCommand ( $dependencyFactory , 'event-sourcing:migrations:latest' ), new Command\\ListCommand ( $dependencyFactory , 'event-sourcing:migrations:list' ), new Command\\MigrateCommand ( $dependencyFactory , 'event-sourcing:migrations:migrate' ), new Command\\DiffCommand ( $dependencyFactory , 'event-sourcing:migrations:diff' ), new Command\\StatusCommand ( $dependencyFactory , 'event-sourcing:migrations:status' ), new Command\\VersionCommand ( $dependencyFactory , 'event-sourcing:migrations:version' ), ]); $cli -> run (); Note Here you can find more information on how to configure doctrine migration . Migration commands There are some commands to use the migration feature. ExecuteCommand: event-sourcing:migrations:execute GenerateCommand: event-sourcing:migrations:generate LatestCommand: event-sourcing:migrations:latest ListCommand: event-sourcing:migrations:list MigrateCommand: event-sourcing:migrations:migrate DiffCommand: event-sourcing:migrations:diff StatusCommand: event-sourcing:migrations:status VersionCommand: event-sourcing:migrations:version","title":"Schema Migration"},{"location":"migration/#migration","text":"You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. Warning To use the migration CLI commands, you have to configure the CLI beforehand.","title":"Migration"},{"location":"migration/#installation","text":"In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations","title":"Installation"},{"location":"migration/#configure-migration-schema-provider","text":"We have added a schema provider for doctrine migrations so that you just have to plug the whole thing together. use Patchlevel\\EventSourcing\\Schema\\MigrationSchemaProvider ; $schemaProvider = new MigrationSchemaProvider ( $store );","title":"Configure Migration Schema Provider"},{"location":"migration/#cli-example","text":"You can plug this together, for example, as follows to create CLI applications like cli.php : use Doctrine\\DBAL\\DriverManager ; use Doctrine\\Migrations\\DependencyFactory ; use Doctrine\\Migrations\\Configuration\\Migration\\PhpFile ; use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection ; use Doctrine\\Migrations\\Tools\\Console\\Command ; use Symfony\\Component\\Console\\Application ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); $config = new PhpFile ( 'migrations.php' ); $dependencyFactory = DependencyFactory :: fromConnection ( $config , new ExistingConnection ( $connection ) ); $store = /* define your doctrine store */ ; $dependencyFactory -> setService ( SchemaProvider :: class , new MigrationSchemaProvider ( $store ) ); $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $cli -> addCommands ([ // other cli commands new Command\\ExecuteCommand ( $dependencyFactory , 'event-sourcing:migrations:execute' ), new Command\\GenerateCommand ( $dependencyFactory , 'event-sourcing:migrations:generate' ), new Command\\LatestCommand ( $dependencyFactory , 'event-sourcing:migrations:latest' ), new Command\\ListCommand ( $dependencyFactory , 'event-sourcing:migrations:list' ), new Command\\MigrateCommand ( $dependencyFactory , 'event-sourcing:migrations:migrate' ), new Command\\DiffCommand ( $dependencyFactory , 'event-sourcing:migrations:diff' ), new Command\\StatusCommand ( $dependencyFactory , 'event-sourcing:migrations:status' ), new Command\\VersionCommand ( $dependencyFactory , 'event-sourcing:migrations:version' ), ]); $cli -> run (); Note Here you can find more information on how to configure doctrine migration .","title":"CLI example"},{"location":"migration/#migration-commands","text":"There are some commands to use the migration feature. ExecuteCommand: event-sourcing:migrations:execute GenerateCommand: event-sourcing:migrations:generate LatestCommand: event-sourcing:migrations:latest ListCommand: event-sourcing:migrations:list MigrateCommand: event-sourcing:migrations:migrate DiffCommand: event-sourcing:migrations:diff StatusCommand: event-sourcing:migrations:status VersionCommand: event-sourcing:migrations:version","title":"Migration commands"},{"location":"normalizer/","text":"Normalizer Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. Usage // todo Built-in Normalizer // todo Array // todo DateTimeImmutable // todo DateTime // todo DateTimeZone // todo Enum // todo Custom Normalizer // todo In our example we build a Name Value Object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } And for that we need our own normalizer. This normalizer must implement the Normalizer interface. You also need to implement a normalize and denormalize method. The important thing is that the result of Normalize is serializable. use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\Normalizer ; class NameNormalizer implements Normalizer { public function normalize ( mixed $value ) : string { if ( ! $value instanceof Name ) { throw new InvalidArgumentException (); } return $value -> toString (); } public function denormalize ( mixed $value ) : ? Name { if ( $value === null ) { return null ; } if ( ! is_string ( $value )) { throw new InvalidArgumentException (); } return new Name ( $value ); } } We can use all of this with the Normalize attribute as follows. The attribute must be set over the property to which it is to be applied. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } In the example we simply specified the class. But we can also instantiate the normalizer and pass parameters. That doesn't make sense at this point, but here's the example: use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(new NameNormalizer('foo'))] public readonly Name $name ) {} } Normalized Name By default, the property name is used to name the field in json. This can be customized with the NormalizedName attribute. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\NormalizedName ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[NormalizedName('profile_name')] public readonly string $name ) {} } The whole thing looks like this [ 'profile_name' : 'David' ]","title":"Normalizer"},{"location":"normalizer/#normalizer","text":"Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again.","title":"Normalizer"},{"location":"normalizer/#usage","text":"// todo","title":"Usage"},{"location":"normalizer/#built-in-normalizer","text":"// todo","title":"Built-in Normalizer"},{"location":"normalizer/#array","text":"// todo","title":"Array"},{"location":"normalizer/#datetimeimmutable","text":"// todo","title":"DateTimeImmutable"},{"location":"normalizer/#datetime","text":"// todo","title":"DateTime"},{"location":"normalizer/#datetimezone","text":"// todo","title":"DateTimeZone"},{"location":"normalizer/#enum","text":"// todo","title":"Enum"},{"location":"normalizer/#custom-normalizer","text":"// todo In our example we build a Name Value Object: final class Name { private string $value ; public function __construct ( string $value ) { if ( strlen ( $value ) < 3 ) { throw new NameIsToShortException ( $value ); } $this -> value = $value ; } public function toString () : string { return $this -> value ; } } And for that we need our own normalizer. This normalizer must implement the Normalizer interface. You also need to implement a normalize and denormalize method. The important thing is that the result of Normalize is serializable. use Patchlevel\\EventSourcing\\Serializer\\Normalizer\\Normalizer ; class NameNormalizer implements Normalizer { public function normalize ( mixed $value ) : string { if ( ! $value instanceof Name ) { throw new InvalidArgumentException (); } return $value -> toString (); } public function denormalize ( mixed $value ) : ? Name { if ( $value === null ) { return null ; } if ( ! is_string ( $value )) { throw new InvalidArgumentException (); } return new Name ( $value ); } } We can use all of this with the Normalize attribute as follows. The attribute must be set over the property to which it is to be applied. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(NameNormalizer::class)] public readonly Name $name ) {} } In the example we simply specified the class. But we can also instantiate the normalizer and pass parameters. That doesn't make sense at this point, but here's the example: use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[Normalize(new NameNormalizer('foo'))] public readonly Name $name ) {} }","title":"Custom Normalizer"},{"location":"normalizer/#normalized-name","text":"By default, the property name is used to name the field in json. This can be customized with the NormalizedName attribute. use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\NormalizedName ; #[Event('profile.name_changed')] final class NameChanged { public function __construct ( #[NormalizedName('profile_name')] public readonly string $name ) {} } The whole thing looks like this [ 'profile_name' : 'David' ]","title":"Normalized Name"},{"location":"outbox/","text":"Outbox // Todo","title":"Outbox"},{"location":"outbox/#outbox","text":"// Todo","title":"Outbox"},{"location":"pipeline/","text":"Pipeline A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! The pipeline can also be used to create or rebuild a projection: use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $pipeline = new Pipeline ( new StoreSource ( $store ), new ProjectionTarget ( $projection ) ); The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand. Source The first thing you need is a source of where the data should come from. Store The StoreSource is the standard source to load all events from the database. use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; $source = new StoreSource ( $store ); In Memory There is an InMemorySource that receives the messages in an array. This source can be used to write pipeline tests. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource ; $source = new InMemorySource ([ new Message ( Profile :: class , '1' , 1 , new ProfileCreated ( Email :: fromString ( 'david.badura@patchlevel.de' )), ), // ... ]); Custom Source You can also create your own source class. It has to inherit from Source . Here you can, for example, create a migration from another event sourcing system or similar system. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\Source ; $source = new class implements Source { /** * @return Generator<Message> */ public function load () : Generator { yield new Message ( Profile :: class , '1' , 0 , new ProfileCreated ( '1' , [ 'name' => 'David' ]) ); } public function count () : int { reutrn 1 ; } } Target After you have a source, you still need the destination of the pipeline. Store You can use a store to save the final result. use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $target = new StoreTarget ( $store ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline. Projection A projection can also be used as a target. For example, to set up a new projection or to build a new projection. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $target = new ProjectionTarget ( $projection ); Projection Handler If you want to build or create all projections from scratch, then you can also use the ProjectionRepositoryTarget. In this, the individual projections are iterated and the events are then passed on. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionHandlerTarget ; $target = new ProjectionHandlerTarget ( $projectionHandler ); In Memory There is also an in-memory variant for the target. This target can also be used for tests. With the messages method you get all Messages that have reached the target. use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget ; $target = new InMemoryTarget (); // run pipeline $messages = $target -> messages (); Middlewares Middelwares can be used to manipulate, delete or expand messages or events during the process. Warning It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware. Exclude With this middleware you can exclude certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; $middleware = new ExcludeEventMiddleware ([ EmailChanged :: class ]); Warning After this middleware, the playhead must be recalculated! Include With this middleware you can only allow certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware ; $middleware = new IncludeEventMiddleware ([ ProfileCreated :: class ]); Warning After this middleware, the playhead must be recalculated! Filter If the middlewares ExcludeEventMiddleware and IncludeEventMiddleware are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware ; $middleware = new FilterEventMiddleware ( function ( AggregateChanged $event ) { if ( ! $event instanceof ProfileCreated ) { return true ; } return $event -> allowNewsletter (); }); Warning After this middleware, the playhead must be recalculated! Replace If you want to replace an event, you can use the ReplaceEventMiddleware . The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; $middleware = new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }); Note The middleware takes over the playhead and recordedAt information. Until A use case could also be that you want to look at the projection from a previous point in time. You can use the UntilEventMiddleware to only allow events that were recorded before this point in time. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ClassRenameMiddleware ; $middleware = new UntilEventMiddleware ( new DateTimeImmutable ( '2020-01-01 12:00:00' )); Warning After this middleware, the playhead must be recalculated! Recalculate playhead This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware RecalculatePlayheadMiddleware can fix this problem. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new RecalculatePlayheadMiddleware (); Note You only need to add this middleware once at the end of the pipeline. Chain If you want to group your middleware, you can use one or more ChainMiddleware . use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new ChainMiddleware ([ new ExcludeEventMiddleware ([ EmailChanged :: class ]), new RecalculatePlayheadMiddleware () ]);","title":"Pipeline"},{"location":"pipeline/#pipeline","text":"A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! The pipeline can also be used to create or rebuild a projection: use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $pipeline = new Pipeline ( new StoreSource ( $store ), new ProjectionTarget ( $projection ) ); The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand.","title":"Pipeline"},{"location":"pipeline/#source","text":"The first thing you need is a source of where the data should come from.","title":"Source"},{"location":"pipeline/#store","text":"The StoreSource is the standard source to load all events from the database. use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; $source = new StoreSource ( $store );","title":"Store"},{"location":"pipeline/#in-memory","text":"There is an InMemorySource that receives the messages in an array. This source can be used to write pipeline tests. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource ; $source = new InMemorySource ([ new Message ( Profile :: class , '1' , 1 , new ProfileCreated ( Email :: fromString ( 'david.badura@patchlevel.de' )), ), // ... ]);","title":"In Memory"},{"location":"pipeline/#custom-source","text":"You can also create your own source class. It has to inherit from Source . Here you can, for example, create a migration from another event sourcing system or similar system. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\Source ; $source = new class implements Source { /** * @return Generator<Message> */ public function load () : Generator { yield new Message ( Profile :: class , '1' , 0 , new ProfileCreated ( '1' , [ 'name' => 'David' ]) ); } public function count () : int { reutrn 1 ; } }","title":"Custom Source"},{"location":"pipeline/#target","text":"After you have a source, you still need the destination of the pipeline.","title":"Target"},{"location":"pipeline/#store_1","text":"You can use a store to save the final result. use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; $target = new StoreTarget ( $store ); Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline.","title":"Store"},{"location":"pipeline/#projection","text":"A projection can also be used as a target. For example, to set up a new projection or to build a new projection. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionTarget ; $target = new ProjectionTarget ( $projection );","title":"Projection"},{"location":"pipeline/#projection-handler","text":"If you want to build or create all projections from scratch, then you can also use the ProjectionRepositoryTarget. In this, the individual projections are iterated and the events are then passed on. use Patchlevel\\EventSourcing\\Pipeline\\Target\\ProjectionHandlerTarget ; $target = new ProjectionHandlerTarget ( $projectionHandler );","title":"Projection Handler"},{"location":"pipeline/#in-memory_1","text":"There is also an in-memory variant for the target. This target can also be used for tests. With the messages method you get all Messages that have reached the target. use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget ; $target = new InMemoryTarget (); // run pipeline $messages = $target -> messages ();","title":"In Memory"},{"location":"pipeline/#middlewares","text":"Middelwares can be used to manipulate, delete or expand messages or events during the process. Warning It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware.","title":"Middlewares"},{"location":"pipeline/#exclude","text":"With this middleware you can exclude certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; $middleware = new ExcludeEventMiddleware ([ EmailChanged :: class ]); Warning After this middleware, the playhead must be recalculated!","title":"Exclude"},{"location":"pipeline/#include","text":"With this middleware you can only allow certain events. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware ; $middleware = new IncludeEventMiddleware ([ ProfileCreated :: class ]); Warning After this middleware, the playhead must be recalculated!","title":"Include"},{"location":"pipeline/#filter","text":"If the middlewares ExcludeEventMiddleware and IncludeEventMiddleware are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware ; $middleware = new FilterEventMiddleware ( function ( AggregateChanged $event ) { if ( ! $event instanceof ProfileCreated ) { return true ; } return $event -> allowNewsletter (); }); Warning After this middleware, the playhead must be recalculated!","title":"Filter"},{"location":"pipeline/#replace","text":"If you want to replace an event, you can use the ReplaceEventMiddleware . The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; $middleware = new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return new NewVisited ( $oldVisited -> profileId ()); }); Note The middleware takes over the playhead and recordedAt information.","title":"Replace"},{"location":"pipeline/#until","text":"A use case could also be that you want to look at the projection from a previous point in time. You can use the UntilEventMiddleware to only allow events that were recorded before this point in time. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ClassRenameMiddleware ; $middleware = new UntilEventMiddleware ( new DateTimeImmutable ( '2020-01-01 12:00:00' )); Warning After this middleware, the playhead must be recalculated!","title":"Until"},{"location":"pipeline/#recalculate-playhead","text":"This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware RecalculatePlayheadMiddleware can fix this problem. use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new RecalculatePlayheadMiddleware (); Note You only need to add this middleware once at the end of the pipeline.","title":"Recalculate playhead"},{"location":"pipeline/#chain","text":"If you want to group your middleware, you can use one or more ChainMiddleware . use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; $middleware = new ChainMiddleware ([ new ExcludeEventMiddleware ([ EmailChanged :: class ]), new RecalculatePlayheadMiddleware () ]);","title":"Chain"},{"location":"processor/","text":"Processor The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a profile has been created: use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return ; } $this -> mailer -> send ( $event -> email (), 'Profile created' , '...' ); } } Warning If you only want to listen to certain events, then you have to check it in the __invoke method.","title":"Processor"},{"location":"processor/#processor","text":"The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a profile has been created: use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; final class SendEmailListener implements Listener { private Mailer $mailer ; private function __construct ( Mailer $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof ProfileCreated ) { return ; } $this -> mailer -> send ( $event -> email (), 'Profile created' , '...' ); } } Warning If you only want to listen to certain events, then you have to check it in the __invoke method.","title":"Processor"},{"location":"projection/","text":"Projections With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch. Define Projection In this example we always create a new data set in a relational database when a profile is created: use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class ProfileProjection implements Projection { private Connection $connection ; public function __construct ( Connection $connection ) { $this -> connection = $connection ; } #[Create] public function create () : void { $this -> connection -> executeStatement ( 'CREATE TABLE IF NOT EXISTS projection_profile (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( 'DROP TABLE IF EXISTS projection_profile;' ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( ProfileCreated $profileCreated ) : void { $this -> connection -> executeStatement ( 'INSERT INTO projection_profile (`id`, `name`) VALUES(:id, :name);' , [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } } Danger You should not execute any actions with projections, otherwise these will be executed again if you rebuild the projection! Projections have a create and a drop method that is executed when the projection is created or deleted. In some cases it may be that no schema has to be created for the projection, as the target does it automatically. In order for the projection to know which method is responsible for which event, the methods must be given the Handle attribute with the respective event class name. As soon as the event has been dispatched, the appropriate methods are then executed. Several projections can also listen to the same event. Register projections So that the projections are known and also executed, you have to add them to the ProjectionHandler . Then add this to the event bus using the ProjectionListener . use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\MetadataAwareProjectionHandler ; use Patchlevel\\EventSourcing\\Projection\\ProjectionListener ; $profileProjection = new ProfileProjection ( $connection ); $messageProjection = new MessageProjection ( $connection ); $projectionHandler = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $eventBus -> addListener ( new ProjectionListener ( $projectionHandler )); Note You can find out more about the event bus here . Setup Projection A projection schama or database usually has to be created beforehand. And with a rebuild, the projection has to be deleted. To make this possible, projections have two methods create and drop that can be defined and executed. Create Projection Schema Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> create (); Drop Projection Schema Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> drop ();","title":"Projection"},{"location":"projection/#projections","text":"With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch.","title":"Projections"},{"location":"projection/#define-projection","text":"In this example we always create a new data set in a relational database when a profile is created: use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class ProfileProjection implements Projection { private Connection $connection ; public function __construct ( Connection $connection ) { $this -> connection = $connection ; } #[Create] public function create () : void { $this -> connection -> executeStatement ( 'CREATE TABLE IF NOT EXISTS projection_profile (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);' ); } #[Drop] public function drop () : void { $this -> connection -> executeStatement ( 'DROP TABLE IF EXISTS projection_profile;' ); } #[Handle(ProfileCreated::class)] public function handleProfileCreated ( ProfileCreated $profileCreated ) : void { $this -> connection -> executeStatement ( 'INSERT INTO projection_profile (`id`, `name`) VALUES(:id, :name);' , [ 'id' => $profileCreated -> profileId , 'name' => $profileCreated -> name ] ); } } Danger You should not execute any actions with projections, otherwise these will be executed again if you rebuild the projection! Projections have a create and a drop method that is executed when the projection is created or deleted. In some cases it may be that no schema has to be created for the projection, as the target does it automatically. In order for the projection to know which method is responsible for which event, the methods must be given the Handle attribute with the respective event class name. As soon as the event has been dispatched, the appropriate methods are then executed. Several projections can also listen to the same event.","title":"Define Projection"},{"location":"projection/#register-projections","text":"So that the projections are known and also executed, you have to add them to the ProjectionHandler . Then add this to the event bus using the ProjectionListener . use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus ; use Patchlevel\\EventSourcing\\Projection\\MetadataAwareProjectionHandler ; use Patchlevel\\EventSourcing\\Projection\\ProjectionListener ; $profileProjection = new ProfileProjection ( $connection ); $messageProjection = new MessageProjection ( $connection ); $projectionHandler = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $eventBus -> addListener ( new ProjectionListener ( $projectionHandler )); Note You can find out more about the event bus here .","title":"Register projections"},{"location":"projection/#setup-projection","text":"A projection schama or database usually has to be created beforehand. And with a rebuild, the projection has to be deleted. To make this possible, projections have two methods create and drop that can be defined and executed.","title":"Setup Projection"},{"location":"projection/#create-projection-schema","text":"Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> create ();","title":"Create Projection Schema"},{"location":"projection/#drop-projection-schema","text":"Or for all projections in the MetadataAwareProjectionHandler : $projectionRepository = new MetadataAwareProjectionHandler ([ $profileProjection , $messageProjection , ]); $projectionRepository -> drop ();","title":"Drop Projection Schema"},{"location":"repository/","text":"Repository A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate. Create We offer two implementations. One is a DefaultRepository that only reads or writes the data from one store. And a SnapshotRepository that holds a state of the aggregate in a cache so that loading and rebuilding of the aggregate is faster. Both repositories implement the Repository interface. This interface can be used for the typehints so that a change is possible at any time. Default Repository The default repository acts directly with the store and therefore needs one. The event bus is used as a further parameter to dispatch new events. Finally, the aggregate class is needed, which aggregates the repository should take care of. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus ); $repository = $repositoryManager -> get ( Profile :: class ); Note You can find out more about stores here Default Repository Manager // todo use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $snapshot = new DefaultSnapshotStore ([ /* adapters */ ]); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , $snapshot ); $repository = $repositoryManager -> get ( Profile :: class ); Note You can find out more about snapshots here Usage Each repository has three methods that are responsible for loading an aggregate , saving it or checking whether it exists. Save An aggregate can be saved . All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database. After the events have been written, the new events are dispatched on the event bus . $profile = Profile :: create ( 'david.badura@patchlevel.de' ); $repository -> save ( $profile ); Note All events are written to the database with one transaction in order to ensure data consistency. Load An aggregate can be loaded using the load method. All events for the aggregate are loaded from the database and the current state is rebuilt. $profile = $repository -> load ( '229286ff-6f95-4df6-bc72-0a239fe7b284' ); Note You can only fetch one aggregate at a time and don't do any complex queries either. Projections are used for this purpose. Has You can also check whether an aggregate with a certain id exists. It is checked whether any event with this id exists in the database. if ( $repository -> has ( '229286ff-6f95-4df6-bc72-0a239fe7b284' )) { // ... } Note The query is fast and does not load any event. This means that the state of the aggregate is not rebuild either. Custom Repository In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; class ProfileRepository { /** @var Repository<Profile> */ private Repository $repository ; public function __constructor ( RepositoryManager $repositoryManager ) { $this -> repository = $repositoryManager -> get ( Profile :: class ); } public function load ( ProfileId $id ) : Profile { return $this -> repository -> load ( $id -> toString ()); } public function save ( Profile $profile ) : void { return $this -> repository -> save ( $profile ); } public function has ( ProfileId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"Repository"},{"location":"repository/#repository","text":"A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate.","title":"Repository"},{"location":"repository/#create","text":"We offer two implementations. One is a DefaultRepository that only reads or writes the data from one store. And a SnapshotRepository that holds a state of the aggregate in a cache so that loading and rebuilding of the aggregate is faster. Both repositories implement the Repository interface. This interface can be used for the typehints so that a change is possible at any time.","title":"Create"},{"location":"repository/#default-repository","text":"The default repository acts directly with the store and therefore needs one. The event bus is used as a further parameter to dispatch new events. Finally, the aggregate class is needed, which aggregates the repository should take care of. use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus ); $repository = $repositoryManager -> get ( Profile :: class ); Note You can find out more about stores here","title":"Default Repository"},{"location":"repository/#default-repository-manager","text":"// todo use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $snapshot = new DefaultSnapshotStore ([ /* adapters */ ]); $repositoryManager = new DefaultRepositoryManager ( $aggregateRootRegistry , $store , $eventBus , $snapshot ); $repository = $repositoryManager -> get ( Profile :: class ); Note You can find out more about snapshots here","title":"Default Repository Manager"},{"location":"repository/#usage","text":"Each repository has three methods that are responsible for loading an aggregate , saving it or checking whether it exists.","title":"Usage"},{"location":"repository/#save","text":"An aggregate can be saved . All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database. After the events have been written, the new events are dispatched on the event bus . $profile = Profile :: create ( 'david.badura@patchlevel.de' ); $repository -> save ( $profile ); Note All events are written to the database with one transaction in order to ensure data consistency.","title":"Save"},{"location":"repository/#load","text":"An aggregate can be loaded using the load method. All events for the aggregate are loaded from the database and the current state is rebuilt. $profile = $repository -> load ( '229286ff-6f95-4df6-bc72-0a239fe7b284' ); Note You can only fetch one aggregate at a time and don't do any complex queries either. Projections are used for this purpose.","title":"Load"},{"location":"repository/#has","text":"You can also check whether an aggregate with a certain id exists. It is checked whether any event with this id exists in the database. if ( $repository -> has ( '229286ff-6f95-4df6-bc72-0a239fe7b284' )) { // ... } Note The query is fast and does not load any event. This means that the state of the aggregate is not rebuild either.","title":"Has"},{"location":"repository/#custom-repository","text":"In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; class ProfileRepository { /** @var Repository<Profile> */ private Repository $repository ; public function __constructor ( RepositoryManager $repositoryManager ) { $this -> repository = $repositoryManager -> get ( Profile :: class ); } public function load ( ProfileId $id ) : Profile { return $this -> repository -> load ( $id -> toString ()); } public function save ( Profile $profile ) : void { return $this -> repository -> save ( $profile ); } public function has ( ProfileId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"Custom Repository"},{"location":"snapshots/","text":"Snapshots Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all. Configuration To use the snapshot system, the SnapshotRepository must be used. In addition, a SnapshotStore must then be given. use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $adapter = new Psr16SnapshotAdapter ( $cache ); $snapshotStore = new DefaultSnapshotStore ([ 'default' => $adapter ]); $repository = new DefaultRepository ( $store , $eventStream , Profile :: class , $snapshotStore ); Note You can read more about Repository here . So that the state can also be cached, the aggregate must be taught how to serialize and deserialize its state. To do this, the aggregate must inherit from the SnapshotableAggregateRoot instead of the AggregateRoot and implement the necessary methods. use Patchlevel\\EventSourcing\\Aggregate\\SnapshotableAggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends SnapshotableAggregateRoot { // ... protected function serialize () : array { return [ 'id' => $this -> id , ]; } protected static function deserialize ( array $payload ) : static { $self = new static (); $self -> id = $payload [ 'id' ]; return $self ; } } Warning In the end it has to be possible to serialize it as json. Batch // Todo Adapter We offer a few SnapshotAdapter implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed: symfony cache laminas cache scrapbook psr6 A Psr6SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter ; $adapter = new Psr6SnapshotAdapter ( $cache ); psr16 A Psr16SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; $adapter = new Psr16SnapshotAdapter ( $cache ); in memory A InMemorySnapshotAdapter that can be used for test purposes. use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter ; $adapter = new InMemorySnapshotAdapter ();","title":"Snapshots"},{"location":"snapshots/#snapshots","text":"Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all.","title":"Snapshots"},{"location":"snapshots/#configuration","text":"To use the snapshot system, the SnapshotRepository must be used. In addition, a SnapshotStore must then be given. use Patchlevel\\EventSourcing\\Repository\\DefaultRepository ; use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; use Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore ; $adapter = new Psr16SnapshotAdapter ( $cache ); $snapshotStore = new DefaultSnapshotStore ([ 'default' => $adapter ]); $repository = new DefaultRepository ( $store , $eventStream , Profile :: class , $snapshotStore ); Note You can read more about Repository here . So that the state can also be cached, the aggregate must be taught how to serialize and deserialize its state. To do this, the aggregate must inherit from the SnapshotableAggregateRoot instead of the AggregateRoot and implement the necessary methods. use Patchlevel\\EventSourcing\\Aggregate\\SnapshotableAggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate('profile')] #[Snapshot('default')] final class Profile extends SnapshotableAggregateRoot { // ... protected function serialize () : array { return [ 'id' => $this -> id , ]; } protected static function deserialize ( array $payload ) : static { $self = new static (); $self -> id = $payload [ 'id' ]; return $self ; } } Warning In the end it has to be possible to serialize it as json.","title":"Configuration"},{"location":"snapshots/#batch","text":"// Todo","title":"Batch"},{"location":"snapshots/#adapter","text":"We offer a few SnapshotAdapter implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed: symfony cache laminas cache scrapbook","title":"Adapter"},{"location":"snapshots/#psr6","text":"A Psr6SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter ; $adapter = new Psr6SnapshotAdapter ( $cache );","title":"psr6"},{"location":"snapshots/#psr16","text":"A Psr16SnapshotAdapter , the associated documentation can be found here . use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter ; $adapter = new Psr16SnapshotAdapter ( $cache );","title":"psr16"},{"location":"snapshots/#in-memory","text":"A InMemorySnapshotAdapter that can be used for test purposes. use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter ; $adapter = new InMemorySnapshotAdapter ();","title":"in memory"},{"location":"store/","text":"Store In the end, the events/messages have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. But it is also possible to develop your own store by implementing the Store interface. Create DBAL connection The first thing we need for our store is a DBAL connection: use Doctrine\\DBAL\\DriverManager ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); Note You can find out more about how to create a connection here Store types We offer two store strategies that you can choose as you like. Single Table Store With the SingleTableStore everything is saved in one table. The dbal connection is needed, a mapping of the aggregate class and aggregate name and, last but not least, the table name. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $store = new SingleTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline . Multi Table Store With the MultiTableStore a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. The dbal connection is needed, a mapping of the aggregate class and table name and, last but not least, the table name for the metadata. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; $store = new MultiTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline . Transaction // TODO Tip To ensure that all listeners are executed for the released events or that the listeners are not executed if the transaction fails, you can use the outbox pattern for it. Schema Manager With the help of the SchemaManager , the database structure can be created, updated and deleted. Tip You can also use doctrine migration to create and keep your schema in sync. Create schema use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> create ( $store ); Update schema use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> update ( $store ); Drop schema use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> drop ( $store );","title":"Store"},{"location":"store/#store","text":"In the end, the events/messages have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. But it is also possible to develop your own store by implementing the Store interface.","title":"Store"},{"location":"store/#create-dbal-connection","text":"The first thing we need for our store is a DBAL connection: use Doctrine\\DBAL\\DriverManager ; $connection = DriverManager :: getConnection ([ 'url' => 'mysql://user:secret@localhost/app' ]); Note You can find out more about how to create a connection here","title":"Create DBAL connection"},{"location":"store/#store-types","text":"We offer two store strategies that you can choose as you like.","title":"Store types"},{"location":"store/#single-table-store","text":"With the SingleTableStore everything is saved in one table. The dbal connection is needed, a mapping of the aggregate class and aggregate name and, last but not least, the table name. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\SingleTableStore ; $store = new SingleTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline .","title":"Single Table Store"},{"location":"store/#multi-table-store","text":"With the MultiTableStore a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. The dbal connection is needed, a mapping of the aggregate class and table name and, last but not least, the table name for the metadata. use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; $store = new MultiTableStore ( $connection , DefaultEventSerializer :: createFromPaths ([ 'src/Event' ]), new AggregateRootRegistry ([ 'profile' => Profile :: class ]), 'eventstore' ); Tip You can switch between strategies using the pipeline .","title":"Multi Table Store"},{"location":"store/#transaction","text":"// TODO Tip To ensure that all listeners are executed for the released events or that the listeners are not executed if the transaction fails, you can use the outbox pattern for it.","title":"Transaction"},{"location":"store/#schema-manager","text":"With the help of the SchemaManager , the database structure can be created, updated and deleted. Tip You can also use doctrine migration to create and keep your schema in sync.","title":"Schema Manager"},{"location":"store/#create-schema","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> create ( $store );","title":"Create schema"},{"location":"store/#update-schema","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> update ( $store );","title":"Update schema"},{"location":"store/#drop-schema","text":"use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager ; ( new SchemaManager ()) -> drop ( $store );","title":"Drop schema"},{"location":"tests/","text":"Tests The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events. use PHPUnit\\Framework\\TestCase ; final class ProfileTest extends TestCase { use AggregateTestHelper ; public function testCreateProfile () : void { $id = ProfileId :: generate (); $profile = Profile :: createProfile ( $id , Email :: fromString ( 'foo@email.com' )); self :: assertRecordedEvents ( $profile , [ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ] ); self :: assertEquals ( 'foo@email.com' , $profile -> email () -> toString ()); } public function testChangeName () : void { $id = ProfileId :: generate (); $profile = self :: createAggregateFromEvents ([ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ]); $profile -> changeEmail ( Email :: fromString ( 'bar@email.com' )); self :: assertRecordedEvents ( $profile , [ new EmailChanged ( Email :: fromString ( 'bar@email.com' )), ] ); self :: assertEquals ( 'bar@email.com' , $profile -> email () -> toString ()); } }","title":"Tests"},{"location":"tests/#tests","text":"The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events. use PHPUnit\\Framework\\TestCase ; final class ProfileTest extends TestCase { use AggregateTestHelper ; public function testCreateProfile () : void { $id = ProfileId :: generate (); $profile = Profile :: createProfile ( $id , Email :: fromString ( 'foo@email.com' )); self :: assertRecordedEvents ( $profile , [ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ] ); self :: assertEquals ( 'foo@email.com' , $profile -> email () -> toString ()); } public function testChangeName () : void { $id = ProfileId :: generate (); $profile = self :: createAggregateFromEvents ([ new ProfileCreated ( $id , Email :: fromString ( 'foo@email.com' )), ]); $profile -> changeEmail ( Email :: fromString ( 'bar@email.com' )); self :: assertRecordedEvents ( $profile , [ new EmailChanged ( Email :: fromString ( 'bar@email.com' )), ] ); self :: assertEquals ( 'bar@email.com' , $profile -> email () -> toString ()); } }","title":"Tests"},{"location":"upcasting/","text":"Upcasting There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer Upcaster , which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event. Adjust payload Let's assume the have an ProfileCreated event which holds an email. Now the business needs to have all emails to be in lower cast. For that we could adjust the aggregate and the projections to take care of that. Or we can do this beforehand so we dont need to maintain two different places. use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; final class ProfileCreatedEmailLowerCastUpcaster implements Upcaster { public function __invoke ( Upcast $upcast ) : Upcast { // ignore if other event is processed if ( $upcast -> eventName !== 'profile_created' ) { return $upcast ; } $payload = $upcast -> payload ; $payload [ 'email' ] = strtolower ( $payload [ 'email' ]); return new Upcast ( $upcast -> eventName , $payload ) } } Warning You need to consider that other events are passed to the Upcaster. So and early out is here endorsed. Adjust event name For the upgrade to 2.0.0 this feature is also really handy since we adjusted the event value from FQCN to an unique name which the user needs to choose. This opens up for moving or renaming the events at code level. Here an example for the upgrade path. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; final class LegacyEventNameUpaster implements Upcaster { public function __construct ( private readonly EventRegistry $eventRegistry ){} public function __invoke ( Upcast $upcast ) : Upcast { return new Upcast ( $this -> eventRegistry -> eventName ( $upcast -> eventName ), $upcast -> payload ); } } Update event stream But what if we need it also in our stream because some other applications has also access on it? Or want to cleanup our Upcasters since we have collected alot of them over the time? Then we can use our pipeline feature without any middlewares to achive a complete rebuild of our stream with adjusted event data. final class EventStreamCleanupCommand extends Command { protected static $defaultName = 'event-stream:cleanup' ; protected static $defaultDescription = 'rebuild event stream' ; public function __construct ( private readonly Store $sourceStore , private readonly Store $targetStore , private readonly ProjectionHandler $projectionHandler ){ } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $pipeline = new Pipeline ( new StoreSource ( $sourceStore ), new StoreTarget ( $targetStore )); $pipeline -> run (); } Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note You can find out more about the pipeline here .","title":"Upcasting"},{"location":"upcasting/#upcasting","text":"There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer Upcaster , which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event.","title":"Upcasting"},{"location":"upcasting/#adjust-payload","text":"Let's assume the have an ProfileCreated event which holds an email. Now the business needs to have all emails to be in lower cast. For that we could adjust the aggregate and the projections to take care of that. Or we can do this beforehand so we dont need to maintain two different places. use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; final class ProfileCreatedEmailLowerCastUpcaster implements Upcaster { public function __invoke ( Upcast $upcast ) : Upcast { // ignore if other event is processed if ( $upcast -> eventName !== 'profile_created' ) { return $upcast ; } $payload = $upcast -> payload ; $payload [ 'email' ] = strtolower ( $payload [ 'email' ]); return new Upcast ( $upcast -> eventName , $payload ) } } Warning You need to consider that other events are passed to the Upcaster. So and early out is here endorsed.","title":"Adjust payload"},{"location":"upcasting/#adjust-event-name","text":"For the upgrade to 2.0.0 this feature is also really handy since we adjusted the event value from FQCN to an unique name which the user needs to choose. This opens up for moving or renaming the events at code level. Here an example for the upgrade path. use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; final class LegacyEventNameUpaster implements Upcaster { public function __construct ( private readonly EventRegistry $eventRegistry ){} public function __invoke ( Upcast $upcast ) : Upcast { return new Upcast ( $this -> eventRegistry -> eventName ( $upcast -> eventName ), $upcast -> payload ); } }","title":"Adjust event name"},{"location":"upcasting/#update-event-stream","text":"But what if we need it also in our stream because some other applications has also access on it? Or want to cleanup our Upcasters since we have collected alot of them over the time? Then we can use our pipeline feature without any middlewares to achive a complete rebuild of our stream with adjusted event data. final class EventStreamCleanupCommand extends Command { protected static $defaultName = 'event-stream:cleanup' ; protected static $defaultDescription = 'rebuild event stream' ; public function __construct ( private readonly Store $sourceStore , private readonly Store $targetStore , private readonly ProjectionHandler $projectionHandler ){ } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $pipeline = new Pipeline ( new StoreSource ( $sourceStore ), new StoreTarget ( $targetStore )); $pipeline -> run (); } Danger Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards! Note You can find out more about the pipeline here .","title":"Update event stream"},{"location":"uuid/","text":"UUID A UUID can be generated for the aggregateId . There are two popular libraries that can be used: ramsey/uuid symfony/uid The aggregate does not care how the id is generated, since only an aggregate-wide unique string is expected here. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\Uuid ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private UuidInterface $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : UuidInterface { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = Uuid :: uuid4 (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Or even better, you create your own aggregate-specific id class. This allows you to ensure that the correct id is always used. The whole thing looks like this: use Ramsey\\Uuid\\Uuid ; class ProfileId { private string $id ; public function __constructor ( string $id ) { $this -> id = $id ; } public static function generate () : self { return new self ( Uuid :: uuid4 () -> toString ()); } public function toString () : string { return $this -> id ; } } use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private ProfileId $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : ProfileId { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = ProfileId :: generate (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } }","title":"UUID"},{"location":"uuid/#uuid","text":"A UUID can be generated for the aggregateId . There are two popular libraries that can be used: ramsey/uuid symfony/uid The aggregate does not care how the id is generated, since only an aggregate-wide unique string is expected here. use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\Uuid ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private UuidInterface $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : UuidInterface { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = Uuid :: uuid4 (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } } Or even better, you create your own aggregate-specific id class. This allows you to ensure that the correct id is always used. The whole thing looks like this: use Ramsey\\Uuid\\Uuid ; class ProfileId { private string $id ; public function __constructor ( string $id ) { $this -> id = $id ; } public static function generate () : self { return new self ( Uuid :: uuid4 () -> toString ()); } public function toString () : string { return $this -> id ; } } use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Ramsey\\Uuid\\UuidInterface ; #[Aggregate('profile')] final class Profile extends AggregateRoot { private ProfileId $id ; private string $name ; public function aggregateRootId () : string { return $this -> id -> toString (); } public function id () : ProfileId { return $this -> id ; } public function name () : string { return $this -> name ; } public static function create ( string $name ) : self { $id = ProfileId :: generate (); $self = new self (); $self -> recordThat ( ProfileCreated :: raise ( $id , $name )); return $self ; } #[Apply] protected function applyProfileCreated ( ProfileCreated $event ) : void { $this -> id = $event -> profileId (); $this -> name = $event -> name (); } }","title":"UUID"},{"location":"watch_server/","text":"Watch We have implemented a watch server that can be used for development. Every event that is saved is sent to the watch server using a watch listener. You can subscribe to it and display the information anywhere, e.g. in the CLI. Watch client The watch client and the listener are used to send all events that are saved to a specific host. use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServerClient ; use Patchlevel\\EventSourcing\\WatchServer\\WatchListener ; $watchServerClient = new SocketWatchServerClient ( '127.0.0.1:5000' , $serializer ); $watchListener = new WatchListener ( $watchServerClient ); Warning This should only be used for dev purposes and should not be registered in production. Watch server The watch server is used to receive all events that are sent. You can subscribe to the watch server and process or display each event as you wish. As soon as you execute start , the server will be started until you terminate the php process. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $watchServer -> listen ( function ( Message $message ) { var_dump ( $message ); } ); $watchServer -> start (); Warning The host must match the one defined in the watch server client. Watch server CLI Here is an example of how to use it with a symfony cli. use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; use Symfony\\Component\\Console\\Application ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $command = new WatchCommand ( $watchServer ); $cli -> addCommands ([ /* more commands */ new Command\\WatchCommand ( $watchServer ), ]); $cli -> run (); Warning To use the watch server CLI command, you have to configure the CLI beforehand. Note The command can be terminated with ctrl+c or control+c .","title":"Watch Server"},{"location":"watch_server/#watch","text":"We have implemented a watch server that can be used for development. Every event that is saved is sent to the watch server using a watch listener. You can subscribe to it and display the information anywhere, e.g. in the CLI.","title":"Watch"},{"location":"watch_server/#watch-client","text":"The watch client and the listener are used to send all events that are saved to a specific host. use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServerClient ; use Patchlevel\\EventSourcing\\WatchServer\\WatchListener ; $watchServerClient = new SocketWatchServerClient ( '127.0.0.1:5000' , $serializer ); $watchListener = new WatchListener ( $watchServerClient ); Warning This should only be used for dev purposes and should not be registered in production.","title":"Watch client"},{"location":"watch_server/#watch-server","text":"The watch server is used to receive all events that are sent. You can subscribe to the watch server and process or display each event as you wish. As soon as you execute start , the server will be started until you terminate the php process. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $watchServer -> listen ( function ( Message $message ) { var_dump ( $message ); } ); $watchServer -> start (); Warning The host must match the one defined in the watch server client.","title":"Watch server"},{"location":"watch_server/#watch-server-cli","text":"Here is an example of how to use it with a symfony cli. use Patchlevel\\EventSourcing\\Console\\Command ; use Patchlevel\\EventSourcing\\WatchServer\\SocketWatchServer ; use Symfony\\Component\\Console\\Application ; $cli = new Application ( 'Event-Sourcing CLI' ); $cli -> setCatchExceptions ( true ); $watchServer = new SocketWatchServer ( '127.0.0.1:5000' , $serializer ); $command = new WatchCommand ( $watchServer ); $cli -> addCommands ([ /* more commands */ new Command\\WatchCommand ( $watchServer ), ]); $cli -> run (); Warning To use the watch server CLI command, you have to configure the CLI beforehand. Note The command can be terminated with ctrl+c or control+c .","title":"Watch server CLI"}]}