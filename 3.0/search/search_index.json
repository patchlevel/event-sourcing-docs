{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Event-Sourcing","text":"<p>A lightweight but also all-inclusive event sourcing library with a focus on developer experience.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Everything is included in the package for event sourcing</li> <li>Based on doctrine dbal and their ecosystem</li> <li>Developer experience oriented and fully typed</li> <li>Automatic snapshot-system to boost your performance</li> <li>Split big aggregates into multiple streams</li> <li>Build-in pipeline to export, import and migrate event streams</li> <li>Versioned and managed lifecycle of subscriptions like projections and processors</li> <li>Smooth upcasting of old events</li> <li>Simple setup with scheme management and doctrine migration</li> <li>Built in cli commands with symfony</li> <li>and much more...</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require patchlevel/event-sourcing\n</code></pre>"},{"location":"#integration","title":"Integration","text":"<ul> <li>Symfony</li> <li>Psalm</li> </ul> <p>Tip</p> <p>Start with the quickstart to get a feeling for the library.</p>"},{"location":"aggregate/","title":"Aggregate","text":"<p>The linchpin of event-sourcing is the aggregate. These aggregates can be imagined like entities in ORM. One main difference is that we don't save the current state, but only the individual events that led to the state. This means it is always possible to build the current state again from the events.</p> <p>Note</p> <p>The term aggregate itself comes from DDD and has nothing to do with event sourcing and can be used independently as a pattern.  You can find out more about Aggregates here.</p> <p>An aggregate must fulfill a few points so that we can use it in event-sourcing:</p> <ul> <li>It must implement the <code>AggregateRoot</code> interface.</li> <li>It needs a unique identifier.</li> <li>It needs to provide the current playhead.</li> <li>It must make changes to his state available as events.</li> <li>And rebuild/catchup its state from the events.</li> </ul> <p>We can implement this ourselves, or use the <code>BasicAggregateRoot</code> implementation that already brings everything with it. This basic implementation uses attributes to configure the aggregate and to specify how it should handle events. We are building a minimal aggregate class here which only has an ID and mark this with the <code>Id</code> attribute. To make it easy to register with a name, we also add the <code>Aggregate</code> attribute. This is what it looks like:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n\n    public static function register(Uuid $id): self\n    {\n        $self = new self();\n\n        $self-&gt;id = $id; // we need to set the id temporary here for the basic example and will be replaced later.\n\n        return $self;\n    }\n}\n</code></pre> <p>Warning</p> <p>The aggregate is not yet finished and has only been built to the point that you can instantiate the object.</p> <p>Tip</p> <p>Find out more about aggregate IDs here.</p> <p>We use a so-called named constructor here to create an object of the AggregateRoot. The constructor itself is protected and cannot be called from outside. But it is possible to define different named constructors for different use-cases like <code>import</code>.</p> <p>After the basic structure for an aggregate is in place, it could theoretically be saved:</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\Repository;\n\nfinal class CreateProfileHandler\n{\n    public function __construct(\n        private readonly Repository $profileRepository,\n    ) {\n    }\n\n    public function __invoke(CreateProfile $command): void\n    {\n        $profile = Profile::register($command-&gt;id());\n\n        $this-&gt;profileRepository-&gt;save($profile);\n    }\n}\n</code></pre> <p>Warning</p> <p>If you look in the database now, you would see that nothing has been saved. This is because only events are stored in the database and as long as no events exist, nothing happens.</p> <p>Tip</p> <p>A command bus system is not necessary, only recommended. The interaction can also easily take place in a controller or service.</p>"},{"location":"aggregate/#create-a-new-aggregate","title":"Create a new aggregate","text":"<p>In order that an aggregate is actually saved, at least one event must exist in the DB. For our aggregate we create the Event <code>ProfileRegistered</code> with an ID and a name. Since the ID is a complex data type and cannot be easily serialized, we need to define a normalizer for the ID. We do this with the <code>IdNormalizer</code> attribute. We also give the event a unique name using the <code>Event</code> attribute.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Event('profile.registered')]\nfinal class ProfileRegistered\n{\n    public function __construct(\n        #[IdNormalizer]\n        public readonly Uuid $profileId,\n        public readonly string $name,\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about events here. And for normalizer here.</p> <p>After we have defined the event, we have to adapt the profile aggregate:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private string $name;\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n\n    public static function register(Uuid $id, string $name): self\n    {\n        $self = new self();\n        $self-&gt;recordThat(new ProfileRegistered($id, $name));\n\n        return $self;\n    }\n\n    #[Apply]\n    protected function applyProfileRegistered(ProfileRegistered $event): void\n    {\n        $this-&gt;id = $event-&gt;profileId;\n        $this-&gt;name = $event-&gt;name;\n    }\n}\n</code></pre> <p>Tip</p> <p>Prefixing the apply methods with \"apply\" improves readability.</p> <p>In our named constructor <code>register</code> we have now created the event and recorded it with the method <code>recordThat</code>. The aggregate remembers all new recorded events in order to save them later. At the same time, a defined <code>apply</code> method is executed directly so that we can change our state.</p> <p>So that the AggregateRoot also knows which method it should call, we have to mark it with the <code>Apply</code> attribute. We did that in the <code>applyProfileRegistered</code> method. In there we then change the state of the aggregate by filling the properties with the values from the event.</p> <p>Success</p> <p>The aggregate is now ready to be saved!</p>"},{"location":"aggregate/#modify-an-aggregate","title":"Modify an aggregate","text":"<p>In order to change the state of the aggregates afterwards, only further events have to be defined. As example we can add a <code>NameChanged</code> event:</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('profile.name_changed')]\nfinal class NameChanged\n{\n    public function __construct(\n        public readonly string $name,\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>Events should best be written in the past, as they describe a state that has happened.</p> <p>After we have defined the event, we can define a new public method called <code>changeName</code> to change the profile name. This method then creates the event <code>NameChanged</code> and records it:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private string $name;\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n\n    public static function register(Uuid $id, string $name): static\n    {\n        $self = new static();\n        $self-&gt;recordThat(new ProfileRegistered($id, $name));\n\n        return $self;\n    }\n\n    public function changeName(string $name): void\n    {\n        $this-&gt;recordThat(new NameChanged($name));\n    }\n\n    #[Apply]\n    protected function applyProfileRegistered(ProfileRegistered $event): void\n    {\n        $this-&gt;id = $event-&gt;profileId;\n        $this-&gt;name = $event-&gt;name;\n    }\n\n    #[Apply]\n    protected function applyNameChanged(NameChanged $event): void\n    {\n        $this-&gt;name = $event-&gt;name;\n    }\n}\n</code></pre> We have also defined a new <code>apply</code> method named <code>applyNameChanged</code> where we change the name depending on the value in the event.</p> <p>When using it, it can look like this:</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\Repository;\n\nfinal class ChangeNameHandler\n{\n    public function __construct(private Repository $profileRepository)\n    {\n    }\n\n    public function __invoke(ChangeName $command): void\n    {\n        $profile = $this-&gt;profileRepository-&gt;load($command-&gt;id());\n        $profile-&gt;changeName($command-&gt;name());\n\n        $this-&gt;profileRepository-&gt;save($profile);\n    }\n}\n</code></pre> <p>Success</p> <p>Our aggregate can now be changed and saved.</p> <p>Note</p> <p>You can read more about Repository here.</p> <p>Here the aggregate is loaded from the <code>repository</code> by fetching all events from the database. These events are then executed again with the <code>apply</code> methods in order to rebuild the current state. All of this happens automatically in the <code>load</code> method.</p> <p>The method <code>changeName</code> is then executed on the aggregate to change the name. In this method the event <code>NameChanged</code> is generated and recorded. The <code>applyNameChanged</code> method was also called again internally to adjust the state.</p> <p>When the <code>save</code> method is called on the repository, all newly recorded events are then fetched and written to the database. In this specific case only the <code>NameChanged</code> changed event.</p>"},{"location":"aggregate/#multiple-apply-attributes-on-the-same-method","title":"Multiple apply attributes on the same method","text":"<p>You can also define several apply attributes with different events using the same method.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n\n    #[Apply(ProfileCreated::class)]\n    #[Apply(NameChanged::class)]\n    protected function applyProfileCreated(ProfileCreated|NameChanged $event): void\n    {\n        if ($event instanceof ProfileCreated) {\n            $this-&gt;id = $event-&gt;profileId;\n        }\n\n        $this-&gt;name = $event-&gt;name;\n    }\n}\n</code></pre>"},{"location":"aggregate/#suppress-missing-apply-methods","title":"Suppress missing apply methods","text":"<p>Sometimes you have events that do not change the state of the aggregate itself, but are still recorded for the future or to subscribe for processor and projection. So that you are not forced to write an apply method for it, you can suppress the missing apply exceptions these events with the <code>SuppressMissingApply</code> attribute.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply;\n\n#[Aggregate('profile')]\n#[SuppressMissingApply([NameChanged::class])]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n\n    #[Apply]\n    protected function applyProfileCreated(ProfileCreated $event): void\n    {\n        $this-&gt;id = $event-&gt;profileId;\n        $this-&gt;name = $event-&gt;name;\n    }\n}\n</code></pre>"},{"location":"aggregate/#suppress-missing-apply-for-all-methods","title":"Suppress missing apply for all methods","text":"<p>You can also completely deactivate the exceptions for missing apply methods.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply;\n\n#[Aggregate('profile')]\n#[SuppressMissingApply(SuppressMissingApply::ALL)]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n\n    #[Apply]\n    protected function applyProfileCreated(ProfileCreated $event): void\n    {\n        $this-&gt;id = $event-&gt;profileId;\n        $this-&gt;name = $event-&gt;name;\n    }\n}\n</code></pre> <p>Warning</p> <p>When all events are suppressed, debugging becomes more difficult if you forget an apply method.</p>"},{"location":"aggregate/#business-rules","title":"Business rules","text":"<p>Usually, aggregates have business rules that must be observed. Like there may not be more than 10 people in a group.</p> <p>These rules must be checked before an event is recorded. As soon as an event was recorded, the described thing happened and cannot be undone.</p> <p>A further check in the apply method is also not possible because these events have already happened and were then also saved in the database.</p> <p>In the next example we want to make sure that the name is at least 3 characters long:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n\n    public function changeName(string $name): void\n    {\n        if (strlen($name) &lt; 3) {\n            throw new NameIsToShortException($name);\n        }\n\n        $this-&gt;recordThat(new NameChanged($name));\n    }\n\n    #[Apply]\n    protected function applyNameChanged(NameChanged $event): void\n    {\n        $this-&gt;name = $event-&gt;name();\n    }\n}\n</code></pre> <p>Danger</p> <p>Validations during \"apply\" can brake the rebuilding of the aggregate.</p> <p>We have now ensured that this rule takes effect when a name is changed with the method <code>changeName</code>. But when we create a new profile this rule does not currently apply.</p> <p>In order for this to work, we either have to duplicate the rule or outsource it. Here we show how we can do it all with a value object:</p> <p><pre><code>final class Name\n{\n    public function __construct(private string $value)\n    {\n        if (strlen($value) &lt; 3) {\n            throw new NameIsToShortException($value);\n        }\n    }\n\n    public function toString(): string\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> We can now use the value object <code>Name</code> in our aggregate:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private Name $name;\n\n    public static function register(Uuid $id, Name $name): static\n    {\n        $self = new static();\n        $self-&gt;recordThat(new ProfileRegistered($id, $name));\n\n        return $self;\n    }\n\n    // ...\n\n    public function name(): Name\n    {\n        return $this-&gt;name;\n    }\n\n    public function changeName(Name $name): void\n    {\n        $this-&gt;recordThat(new NameChanged($name));\n    }\n\n    #[Apply]\n    protected function applyNameChanged(NameChanged $event): void\n    {\n        $this-&gt;name = $event-&gt;name;\n    }\n}\n</code></pre> In order for the whole thing to work, we still have to adapt our <code>NameChanged</code> event, since we only expected a string before but now passed a <code>Name</code> value object.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('profile.name_changed')]\nfinal class NameChanged\n{\n    public function __construct(\n        #[NameNormalizer]\n        public readonly Name $name,\n    ) {\n    }\n}\n</code></pre> <p>Warning</p> <p>The payload must be serializable and unserializable as json.</p> <p>Note</p> <p>You can find out more about normalizer here.</p> <p>There are also cases where business rules have to be defined depending on the aggregate state. Sometimes also from states, which were changed in the same method. This is not a problem, as the <code>apply</code> methods are always executed immediately.</p> <p>In the next case we throw an exception if the hotel is already overbooked. Besides that, we record another event <code>FullyBooked</code>, if the hotel is fully booked with the last booking. With this event we could notify external systems or fill a projection with fully booked hotels.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\SuppressMissingApply;\n\n#[Aggregate('hotel')]\n#[SuppressMissingApply([FullyBooked::class])]\nfinal class Hotel extends BasicAggregateRoot\n{\n    private const SIZE = 5;\n\n    private int $people;\n\n    // ...\n\n    public function book(string $name): void\n    {\n        if ($this-&gt;people === self::SIZE) {\n            throw new NoPlaceException($name);\n        }\n\n        $this-&gt;recordThat(new RoomBocked($name));\n\n        if ($this-&gt;people !== self::SIZE) {\n            return;\n        }\n\n        $this-&gt;recordThat(new FullyBooked());\n    }\n\n    #[Apply]\n    protected function applyRoomBocked(RoomBocked $event): void\n    {\n        $this-&gt;people++;\n    }\n}\n</code></pre>"},{"location":"aggregate/#working-with-dates","title":"Working with dates","text":"<p>An aggregate should always be deterministic. In other words, whenever I execute methods on the aggregate, I always get the same result. This also makes testing much easier.</p> <p>But that often doesn't seem to be possible, e.g. if you want to save a createAt date. But you can pass this information by yourself.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private Name $name;\n    private DateTimeImmutable $registeredAt;\n\n    public static function register(Uuid $id, string $name, DateTimeImmutable $registeredAt): static\n    {\n        $self = new static();\n        $self-&gt;recordThat(new ProfileRegistered($id, $name, $registeredAt));\n\n        return $self;\n    }\n\n    // ...\n}\n</code></pre> But if you still want to make sure that the time is \"now\" and not in the past or future, you can pass a clock.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\nuse Patchlevel\\EventSourcing\\Clock\\Clock;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private Name $name;\n    private DateTimeImmutable $registeredAt;\n\n    public static function register(Uuid $id, string $name, Clock $clock): static\n    {\n        $self = new static();\n        $self-&gt;recordThat(new ProfileRegistered($id, $name, $clock-&gt;now()));\n\n        return $self;\n    }\n\n    // ...\n}\n</code></pre> Now you can pass the <code>SystemClock</code> to determine the current time. Or for test purposes the <code>FrozenClock</code>, which always returns the same time.</p> <p>Note</p> <p>You can find out more about clock here.</p>"},{"location":"aggregate/#aggregate-root-registry","title":"Aggregate Root Registry","text":"<p>The library needs to know about all aggregates so that the correct aggregate class is used to load from the database. There is an <code>AggregateRootRegistry</code> for this purpose. The registry is a simple hashmap between aggregate name and aggregate class.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry;\n\n$aggregateRegistry = new AggregateRootRegistry([\n    'profile' =&gt; Profile::class,\n]);\n</code></pre> So that you don't have to create it by hand, you can use a factory. By default, the <code>AttributeAggregateRootRegistryFactory</code> is used. There, with the help of paths, all classes with the attribute <code>Aggregate</code> are searched for and the <code>AggregateRootRegistry</code> is built up.</p> <pre><code>$aggregateRegistry = (new AttributeEventRegistryFactory())-&gt;create($paths);\n</code></pre>"},{"location":"aggregate/#learn-more","title":"Learn more","text":"<ul> <li>How to create own aggregate id</li> <li>How to store and load aggregates</li> <li>How to snapshot aggregates</li> <li>How to create Projections</li> <li>How to split streams</li> </ul>"},{"location":"aggregate_id/","title":"Aggregate ID","text":"<p>The <code>aggregate id</code> is a unique identifier for an aggregate. It is used to identify the aggregate in the event store. The <code>aggregate</code> does not care how the id is generated, since only an aggregate-wide unique string is expected in the store.</p> <p>This library provides you with a few options for generating the id.</p>"},{"location":"aggregate_id/#uuid","title":"Uuid","text":"<p>The easiest way is to use an <code>uuid</code> as an aggregate ID. For this, we have the <code>Uuid</code> class, which is a simple wrapper for the ramsey/uuid library.</p> <p>You can use it like this:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    #[IdNormalizer]\n    private Uuid $id;\n}\n</code></pre> <p>Note</p> <p>If you want to use snapshots, then you have to make sure that the aggregate id are normalized.  You can find how to do this here.</p> <p>You have multiple options for generating an uuid:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\n$uuid = Uuid::v6();\n$uuid = Uuid::v7();\n$uuid = Uuid::fromString('d6e8d7a0-4b0b-4e6a-8a9a-3a0b2d9d0e4e');\n</code></pre> <p>Note</p> <p>We offer you the uuid versions 6 and 7, because they are the most suitable for event sourcing. More information about uuid versions can be found here.</p>"},{"location":"aggregate_id/#custom-id","title":"Custom ID","text":"<p>If you don't want to use an uuid, you can also use the custom ID implementation. This is a value object that holds any string.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\CustomId;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    #[IdNormalizer]\n    private CustomId $id;\n}\n</code></pre> <p>Note</p> <p>If you want to use snapshots, then you have to make sure that the aggregate id are normalized.  You can find how to do this here.</p> <p>So you can use any string as an id:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\CustomId;\n\n$id = CustomId::fromString('my-id');\n</code></pre>"},{"location":"aggregate_id/#implement-own-id","title":"Implement own ID","text":"<p>Or even better, you create your own aggregate-specific ID class. This allows you to ensure that the correct id is always used. The whole thing looks like this:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\AggregateRootId;\n\nclass ProfileId implements AggregateRootId\n{\n    private function __construct(\n        private readonly string $id,\n    ) {\n    }\n\n    public function toString(): string\n    {\n        return $this-&gt;id;\n    }\n\n    public static function fromString(string $id): self\n    {\n        return new self($id);\n    }\n}\n</code></pre> So you can use it like this:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Aggregate('profile')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    #[IdNormalizer]\n    private ProfileId $id;\n}\n</code></pre> <p>Note</p> <p>If you want to use snapshots, then you have to make sure that the aggregate id are normalized.  You can find how to do this here.</p> <p>We also offer you some traits, so that you don't have to implement the <code>AggregateRootId</code> interface yourself. Here for the uuid:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\AggregateRootId;\nuse Patchlevel\\EventSourcing\\Aggregate\\RamseyUuidBehaviour;\n\nclass ProfileId implements AggregateRootId\n{\n    use RamseyUuidBehaviour;\n}\n</code></pre> Or for the custom id:</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\AggregateRootId;\nuse Patchlevel\\EventSourcing\\Aggregate\\CustomIdBehaviour;\n\nclass ProfileId implements AggregateRootId\n{\n    use CustomIdBehaviour;\n}\n</code></pre>"},{"location":"aggregate_id/#learn-more","title":"Learn more","text":"<ul> <li>How to create an aggregate</li> <li>How to create an event</li> <li>How to test an aggregate</li> <li>How to normalize value objects</li> </ul>"},{"location":"cli/","title":"CLI","text":"<p>This library provides a <code>cli</code> to manage the <code>event-sourcing</code> functionalities.</p> <p>You can:</p> <ul> <li>Create and delete <code>databases</code></li> <li>Create, update and delete <code>schemas</code></li> <li>Manage <code>subscriptions</code></li> </ul>"},{"location":"cli/#database-commands","title":"Database commands","text":"<p>There are two commands for creating and deleting a database.</p> <ul> <li>DatabaseCreateCommand: <code>event-sourcing:database:create</code></li> <li>DatabaseDropCommand: <code>event-sourcing:database:drop</code></li> </ul>"},{"location":"cli/#schema-commands","title":"Schema commands","text":"<p>The database schema can also be created, updated and dropped.</p> <ul> <li>SchemaCreateCommand: <code>event-sourcing:schema:create</code></li> <li>SchemaUpdateCommand: <code>event-sourcing:schema:update</code></li> <li>SchemaDropCommand: <code>event-sourcing:schema:drop</code></li> </ul> <p>Note</p> <p>You can also register doctrine migration commands.</p>"},{"location":"cli/#subscription-commands","title":"Subscription commands","text":"<p>To manage your subscriptions there are the following cli commands.</p> <ul> <li>SubscriptionBootCommand: <code>event-sourcing:subscription:boot</code></li> <li>SubscriptionPauseCommand: <code>event-sourcing:subscription:pause</code></li> <li>SubscriptionReactiveCommand: <code>event-sourcing:subscription:reactive</code></li> <li>SubscriptionRemoveCommand: <code>event-sourcing:subscription:remove</code></li> <li>SubscriptionRunCommand: <code>event-sourcing:subscription:run</code></li> <li>SubscriptionSetupCommand: <code>event-sourcing:subscription:setup</code></li> <li>SubscriptionStatusCommand: <code>event-sourcing:subscription:status</code></li> <li>SubscriptionTeardownCommand: <code>event-sourcing:subscription:teardown</code></li> </ul> <p>Note</p> <p>You can find out more about subscriptions here.</p>"},{"location":"cli/#inspector-commands","title":"Inspector commands","text":"<p>The inspector is a tool to inspect the event streams.</p> <ul> <li>ShowCommand: <code>event-sourcing:show</code></li> <li>ShowAggregateCommand: <code>event-sourcing:show-aggregate</code></li> <li>WatchCommand: <code>event-sourcing:watch</code></li> </ul>"},{"location":"cli/#cli-example","title":"CLI example","text":"<p>A cli php file can look like this:</p> <pre><code>use Patchlevel\\EventSourcing\\Console\\Command;\nuse Patchlevel\\EventSourcing\\Console\\DoctrineHelper;\nuse Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaManager;\nuse Symfony\\Component\\Console\\Application;\n\n/* define your doctrine store */\n$store;\n\n/* create projectionist */\n$projectionist;\n\n$cli = new Application('Event-Sourcing CLI');\n$cli-&gt;setCatchExceptions(true);\n\n$doctrineHelper = new DoctrineHelper();\n$schemaManager = new DoctrineSchemaManager();\n\n$cli-&gt;addCommands([\n    new Command\\DatabaseCreateCommand($store, $doctrineHelper),\n    new Command\\DatabaseDropCommand($store, $doctrineHelper),\n    new Command\\SubscriptionBootCommand($projectionist),\n    new Command\\SubscriptionPauseCommand($projectionist),\n    new Command\\SubscriptionRunCommand($projectionist),\n    new Command\\SubscriptionTeardownCommand($projectionist),\n    new Command\\SubscriptionRemoveCommand($projectionist),\n    new Command\\SubscriptionReactivateCommand($projectionist),\n    new Command\\SubscriptionRebuildCommand($projectionist),\n    new Command\\SubscriptionSetupCommand($projectionist),\n    new Command\\SubscriptionStatusCommand($projectionist),\n    new Command\\SchemaCreateCommand($store, $schemaManager),\n    new Command\\SchemaDropCommand($store, $schemaManager),\n    new Command\\SchemaUpdateCommand($store, $schemaManager),\n]);\n\n$cli-&gt;run();\n</code></pre>"},{"location":"cli/#doctrine-migrations","title":"Doctrine Migrations","text":"<p>If you want to use doctrine migrations, you can register the commands like this:</p> <pre><code>use Doctrine\\Migrations\\Configuration\\Connection\\ExistingConnection;\nuse Doctrine\\Migrations\\DependencyFactory;\nuse Doctrine\\Migrations\\Tools\\Console\\Command;\nuse Patchlevel\\EventSourcing\\Schema\\DoctrineMigrationSchemaProvider;\nuse Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector;\n\n/* create connection */\n$connection;\n/* define your doctrine store */\n$store;\n\n$schemaDirector = new DoctrineSchemaDirector(\n    $store,\n    $connection,\n);\n\n/* define your migration config */\n$migrationConfig;\n\n\n$dependencyFactory = DependencyFactory::fromConnection(\n    $migrationConfig,\n    new ExistingConnection($connection),\n);\n\n\n$dependencyFactory-&gt;setService(\n    SchemaProvider::class,\n    new DoctrineMigrationSchemaProvider($schemaDirector),\n);\n\n$cli-&gt;addCommands([\n    new Command\\ExecuteCommand($dependencyFactory, 'event-sourcing:migrations:execute'),\n    new Command\\GenerateCommand($dependencyFactory, 'event-sourcing:migrations:generate'),\n    new Command\\LatestCommand($dependencyFactory, 'event-sourcing:migrations:latest'),\n    new Command\\ListCommand($dependencyFactory, 'event-sourcing:migrations:list'),\n    new Command\\MigrateCommand($dependencyFactory, 'event-sourcing:migrations:migrate'),\n    new Command\\DiffCommand($dependencyFactory, 'event-sourcing:migrations:diff'),\n    new Command\\StatusCommand($dependencyFactory, 'event-sourcing:migrations:status'),\n    new Command\\VersionCommand($dependencyFactory, 'event-sourcing:migrations:version'),\n]);\n</code></pre> <p>Note</p> <p>Here you can find more information on how to  configure doctrine migration.</p>"},{"location":"clock/","title":"Clock","text":"<p>We are using the clock to get the current datetime. This is needed to create the <code>recorded_on</code> datetime for the event stream. We have two implementations of the clock, one for the production and one for the tests. But you can also create your own implementation that is PSR-20 compatible. For more information see here.</p>"},{"location":"clock/#systemclock","title":"SystemClock","text":"<p>This uses the native system clock to return the <code>DateTimeImmutable</code> instance.</p> <pre><code>use Patchlevel\\EventSourcing\\Clock\\SystemClock;\n\n$clock = new SystemClock();\n$date = $clock-&gt;now(); // get the actual datetime\n$date2 = $clock-&gt;now();\n\n// $date == $date2 =&gt; false\n// $date === $date2 =&gt; false\n</code></pre>"},{"location":"clock/#frozenclock","title":"FrozenClock","text":"<p>This implementation should only be used for the tests. This enables you to freeze the time and with that to have deterministic tests.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Clock\\FrozenClock;\n\n$date = new DateTimeImmutable();\n\n$clock = new FrozenClock($date);\n$frozenDate = $clock-&gt;now(); // gets the date provided before\n\n// $date == $frozenDate =&gt; true\n// $date === $frozenDate =&gt; false\n</code></pre> The <code>FrozenClock</code> can also be updated with a new date, so you can test a jump in time.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Clock\\FrozenClock;\n\n$firstDate = new DateTimeImmutable();\n$clock = new FrozenClock($firstDate);\n\n$secondDate = new DateTimeImmutable();\n$clock-&gt;update($secondDate);\n\n$frozenDate = $clock-&gt;now();\n\n// $firstDate == $frozenDate =&gt; false\n// $secondDate == $frozenDate =&gt; true\n</code></pre> Or you can use the <code>sleep</code> method to simulate a time jump.</p> <pre><code>use Patchlevel\\EventSourcing\\Clock\\FrozenClock;\n\n$firstDate = new DateTimeImmutable();\n$clock = new FrozenClock($firstDate);\n\n$clock-&gt;sleep(10); // sleep 10 seconds\n</code></pre> <p>Note</p> <p>The instance of the frozen datetime will be cloned internally, so the it's not the same instance but equals.</p>"},{"location":"clock/#learn-more","title":"Learn more","text":"<ul> <li>How to test with datetime</li> <li>How to normalize datetime</li> <li>How to use messages</li> <li>How to decorate messages</li> </ul>"},{"location":"event_bus/","title":"Event Bus","text":"<p>This library uses the core principle called event bus.</p> <p>For all events that are persisted (when the <code>save</code> method has been executed on the repository), the event wrapped in a message will be dispatched to the <code>event bus</code>. All listeners are then called for each event/message.</p>"},{"location":"event_bus/#message","title":"Message","text":"<p>A <code>Message</code> contains the event and related meta information as headers. A <code>Message</code> contains only two properties, first the <code>event</code> and second the <code>headers</code>. Internally we are also using the <code>headers</code> to store meta information for the <code>Message</code> for example:</p> <ul> <li>aggregate name</li> <li>aggregate id</li> <li>playhead</li> <li>recorded on</li> </ul> <p>Each event is packed into a message and dispatched using the event bus.</p> <pre><code>use Patchlevel\\EventSourcing\\Clock\\SystemClock;\nuse Patchlevel\\EventSourcing\\Message\\Message;\n\n$clock = new SystemClock();\n$message = Message::create(new NameChanged('foo'))\n    -&gt;withAggregateName('profile')\n    -&gt;withAggregateId('bca7576c-536f-4428-b694-7b1f00c714b7')\n    -&gt;withPlayhead(2)\n    -&gt;withRecordedOn($clock-&gt;now());\n\n$eventBus-&gt;dispatch($message);\n</code></pre> <p>Note</p> <p>The message object is immutable.</p> <p>You don't have to create the message yourself, it is automatically created, saved and dispatched in the repository.</p>"},{"location":"event_bus/#custom-headers","title":"Custom headers","text":"<p>As already mentioned, you can enrich the <code>Message</code> with your own meta information. This is then accessible in the message object and is also stored in the database.</p> <pre><code>use Patchlevel\\EventSourcing\\Message\\Message;\n\n$message = Message::create(new NameChanged('foo'))\n    // ...\n    -&gt;withHeader('application-id', 'app');\n</code></pre> <p>Note</p> <p>You can read about how to pass additional headers to the message object in the message decorator docs.</p> <p>You can also access your custom headers. For this case there is also a method to only retrieve the headers which are not used internally.</p> <p><pre><code>$message-&gt;header('application-id'); // app\n$message-&gt;customHeaders(); // ['application-id' =&gt; 'app']\n</code></pre> If you want all the headers you can also retrieve them.</p> <pre><code>$headers = $message-&gt;headers();\n/*\n[\n    'aggregateName' =&gt; 'profile',\n    'aggregateId' =&gt; '1',\n    // {...},\n    'application-id' =&gt; 'app'\n]\n*/\n</code></pre> <p>Warning</p> <p>Relying on internal meta data could be dangerous as they could be changed. So be cautios if you want to implement logic on them.</p>"},{"location":"event_bus/#event-bus_1","title":"Event Bus","text":"<p>The event bus is responsible for dispatching the messages to the listeners. The library also delivers a light-weight event bus for which you can register listeners and dispatch events.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus;\n\n$eventBus = DefaultEventBus::create([$mailListener]);\n</code></pre> <p>Note</p> <p>The order in which the listeners are executed is determined by the order in which they are passed to the factory.</p> <p>Internally, the event bus uses the <code>Consumer</code> to consume the messages and call the listeners.</p>"},{"location":"event_bus/#consumer","title":"Consumer","text":"<p>The consumer is responsible for consuming the messages and calling the listeners.</p> <p><pre><code>use Patchlevel\\EventSourcing\\EventBus\\DefaultConsumer;\n\n$consumer = DefaultConsumer::create([$mailListener]);\n\n$consumer-&gt;consume($message);\n</code></pre> Internally, the consumer uses the <code>ListenerProvider</code> to find the listeners for the message.</p>"},{"location":"event_bus/#listener-provider","title":"Listener provider","text":"<p>The listener provider is responsible for finding all listeners for a specific event. The default listener provider uses attributes to find the listeners.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\AttributeListenerProvider;\nuse Patchlevel\\EventSourcing\\EventBus\\DefaultConsumer;\nuse Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus;\n\n$listenerProvider = new AttributeListenerProvider([$mailListener]);\n\n$eventBus = new DefaultEventBus(\n    new DefaultConsumer($listenerProvider),\n);\n</code></pre> <p>Tip</p> <p>The <code>DefaultEventBus::create</code> method uses the <code>DefaultConsumer</code> and <code>AttributeListenerProvider</code> by default.</p>"},{"location":"event_bus/#custom-listener-provider","title":"Custom listener provider","text":"<p>You can also use your own listener provider.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\ListenerDescriptor;\nuse Patchlevel\\EventSourcing\\EventBus\\ListenerProvider;\n\n$listenerProvider = new class implements ListenerProvider {\n    public function listenersForEvent(string $eventClass): iterable\n    {\n        return [\n            new ListenerDescriptor(\n                (new WelcomeSubscriber())-&gt;onProfileCreated(...),\n            ),\n        ];\n    }\n};\n</code></pre> <p>Tip</p> <p>You can use <code>$listenerDiscriptor-&gt;name()</code> to get the name of the listener.</p>"},{"location":"event_bus/#listener","title":"Listener","text":"<p>You can listen for specific events with the attribute <code>Subscribe</code>. This listener is then called for all saved events / messages.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Message\\Message;\n\nfinal class WelcomeSubscriber\n{\n    #[Subscribe(ProfileCreated::class)]\n    public function onProfileCreated(Message $message): void\n    {\n        echo 'Welcome!';\n    }\n}\n</code></pre> <p>Tip</p> <p>If you use psalm, you can use the event sourcing plugin for better type support.</p>"},{"location":"event_bus/#listen-on-all-events","title":"Listen on all events","text":"<p>If you want to listen on all events, you can pass <code>*</code> or <code>Subscribe::ALL</code> instead of the event class.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Message\\Message;\n\nfinal class WelcomeSubscriber\n{\n    #[Subscribe('*')]\n    public function onProfileCreated(Message $message): void\n    {\n        echo 'Welcome!';\n    }\n}\n</code></pre>"},{"location":"event_bus/#psr-14-event-bus","title":"Psr-14 Event Bus","text":"<p>You can also use a psr-14 compatible event bus. In this case, you can't use the <code>Subscribe</code> attribute. You need to use the system of the psr-14 event bus.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\Psr14EventBus;\n\n$eventBus = new Psr14EventBus($psr14EventDispatcher);\n</code></pre> <p>Warning</p> <p>You can't use the <code>Subscribe</code> attribute with the psr-14 event bus.</p>"},{"location":"event_bus/#learn-more","title":"Learn more","text":"<ul> <li>How to decorate messages</li> <li>How to use outbox pattern</li> <li>How to use processor</li> <li>How to use subscriptions</li> </ul>"},{"location":"events/","title":"Events","text":"<p>Events are used to describe things that happened in the application. Since the events already happened, they are also immnutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions.</p> <p>An event has a name and additional information called payload. Such an event can be represented as any class. It is important that the payload can be serialized as JSON at the end. Later it will be explained how to ensure it for all values.</p> <p>To register an event you have to set the <code>Event</code> attribute over the class, otherwise it will not be recognized as an event. There you also have to give the event a name.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event(name: 'profile.created')]\nfinal class ProfileCreated\n{\n    public function __construct(\n        public readonly string $profileId,\n        public readonly string $name,\n    ) {\n    }\n}\n</code></pre> <p>Warning</p> <p>The payload must be serializable and unserializable as json.</p> <p>Tip</p> <p>An event should be named in the past because it has already happened.</p> <p>Best practice is to prefix the event names with the aggregate name, lowercase everything, and replace spaces with underscores. Here are some examples:</p> <ul> <li><code>profile.created</code></li> <li><code>profile.name_changed</code></li> <li><code>hotel.guest_checked_out</code></li> </ul>"},{"location":"events/#serializer","title":"Serializer","text":"<p>So that the events can be saved in the database, they must be serialized and deserialized. That's what the serializer is for. The library comes with a <code>DefaultEventSerializer</code> that can be given further instructions using attributes.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer;\n\n$serializer = DefaultEventSerializer::createFromPaths(['src/Domain']);\n</code></pre> The serializer needs the path information where the event classes are located so that it can instantiate the correct classes. Internally, an EventRegistry is used, which will be described later.</p>"},{"location":"events/#normalizer","title":"Normalizer","text":"<p>Sometimes you also want to add more complex data as a payload. For example DateTime or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Event;\nuse Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\nuse Patchlevel\\Hydrator\\Normalizer\\IdNormalizer;\n\n#[Event('profile.created')]\nfinal class ProfileCreated\n{\n    public function __construct(\n        #[IdNormalizer]\n        public readonly Uuid $id,\n        #[NameNormalizer]\n        public readonly Name $name,\n        #[DateTimeImmutableNormalizer]\n        public readonly DateTimeImmutable $createdAt,\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about normalizer here.    </p>"},{"location":"events/#event-registry","title":"Event Registry","text":"<p>The library needs to know about all events so that the correct event class is used for the serialization and deserialization of an event. There is an EventRegistry for this purpose. The registry is a simple hashmap between event name and event class.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry;\n\n$eventRegistry = new EventRegistry([\n    'profile.created' =&gt; ProfileCreated::class,\n]);\n</code></pre> So that you don't have to create it by hand, you can use a factory. By default, the <code>AttributeEventRegistryFactory</code> is used. There, with the help of paths, all classes with the attribute <code>Event</code> are searched for and the <code>EventRegistry</code> is built up.</p> <pre><code>use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventRegistryFactory;\n\n$eventRegistry = (new AttributeEventRegistryFactory())-&gt;create($paths);\n</code></pre>"},{"location":"events/#learn-more","title":"Learn more","text":"<ul> <li>How to normalize events</li> <li>How to dispatch events</li> <li>How to listen on events</li> <li>How to store events</li> <li>How to split streams</li> <li>How to upcast events</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out.</p>"},{"location":"getting_started/#define-some-events","title":"Define some events","text":"<p>First we define the events that happen in our system.</p> <p>A hotel can be created with a <code>name</code> and a <code>id</code>:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Event('hotel.created')]\nfinal class HotelCreated\n{\n    public function __construct(\n        #[IdNormalizer]\n        public readonly Uuid $hotelId,\n        public readonly string $hotelName,\n    ) {\n    }\n}\n</code></pre> A guest can check in by <code>name</code>:</p> <p><pre><code>#[Event('hotel.guest_checked_in')]\nfinal class GuestIsCheckedIn\n{\n    public function __construct(\n        public readonly string $guestName,\n    ) {\n    }\n}\n</code></pre> And also check out again:</p> <pre><code>#[Event('hotel.guest_checked_out')]\nfinal class GuestIsCheckedOut\n{\n    public function __construct(\n        public readonly string $guestName,\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about events here.    </p>"},{"location":"getting_started/#define-aggregates","title":"Define aggregates","text":"<p>Next we need to define the hotel aggregate. How you can interact with it, which events happen and what the business rules are. For this we create the methods <code>create</code>, <code>checkIn</code> and <code>checkOut</code>. In these methods the business checks are made and the events are recorded. Last but not least, we need the associated apply methods to change the state.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate('hotel')]\nfinal class Hotel extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private string $name;\n\n    /** @var list&lt;string&gt; */\n    private array $guests;\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n\n    public function guests(): int\n    {\n        return $this-&gt;guests;\n    }\n\n    public static function create(Uuid $id, string $hotelName): static\n    {\n        $self = new static();\n        $self-&gt;recordThat(new HotelCreated($id, $hotelName));\n\n        return $self;\n    }\n\n    public function checkIn(string $guestName): void\n    {\n        if (in_array($guestName, $this-&gt;guests, true)) {\n            throw new GuestHasAlreadyCheckedIn($guestName);\n        }\n\n        $this-&gt;recordThat(new GuestIsCheckedIn($guestName));\n    }\n\n    public function checkOut(string $guestName): void\n    {\n        if (!in_array($guestName, $this-&gt;guests, true)) {\n            throw new IsNotAGuest($guestName);\n        }\n\n        $this-&gt;recordThat(new GuestIsCheckedOut($guestName));\n    }\n\n    #[Apply]\n    protected function applyHotelCreated(HotelCreated $event): void\n    {\n        $this-&gt;id = $event-&gt;hotelId;\n        $this-&gt;name = $event-&gt;hotelName;\n        $this-&gt;guests = [];\n    }\n\n    #[Apply]\n    protected function applyGuestIsCheckedIn(GuestIsCheckedIn $event): void\n    {\n        $this-&gt;guests[] = $event-&gt;guestName;\n    }\n\n    #[Apply]\n    protected function applyGuestIsCheckedOut(GuestIsCheckedOut $event): void\n    {\n        $this-&gt;guests = array_values(\n            array_filter(\n                $this-&gt;guests,\n                static fn ($name) =&gt; $name !== $event-&gt;guestName,\n            ),\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about aggregates here.</p>"},{"location":"getting_started/#define-projections","title":"Define projections","text":"<p>So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. To create a projection we need a projector. Each projector is then responsible for a specific projection.</p> <pre><code>use Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Attribute\\Projector;\nuse Patchlevel\\EventSourcing\\Attribute\\Setup;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Attribute\\Teardown;\nuse Patchlevel\\EventSourcing\\Message\\Message;\nuse Patchlevel\\EventSourcing\\Subscription\\Subscriber\\SubscriberUtil;\n\n#[Projector('hotel')]\nfinal class HotelProjector\n{\n    use SubscriberUtil;\n\n    public function __construct(\n        private readonly Connection $db,\n    ) {\n    }\n\n    /** @return list&lt;array{id: string, name: string, guests: int}&gt; */\n    public function getHotels(): array\n    {\n        return $this-&gt;db-&gt;fetchAllAssociative(\"SELECT id, name, guests FROM {$this-&gt;table()};\");\n    }\n\n    #[Subscribe(HotelCreated::class)]\n    public function handleHotelCreated(Message $message): void\n    {\n        $event = $message-&gt;event();\n\n        $this-&gt;db-&gt;insert(\n            $this-&gt;table(),\n            [\n                'id' =&gt; $message-&gt;aggregateId(),\n                'name' =&gt; $event-&gt;hotelName,\n                'guests' =&gt; 0,\n            ],\n        );\n    }\n\n    #[Subscribe(GuestIsCheckedIn::class)]\n    public function handleGuestIsCheckedIn(Message $message): void\n    {\n        $this-&gt;db-&gt;executeStatement(\n            \"UPDATE {$this-&gt;table()} SET guests = guests + 1 WHERE id = ?;\",\n            [$message-&gt;aggregateId()],\n        );\n    }\n\n    #[Subscribe(GuestIsCheckedOut::class)]\n    public function handleGuestIsCheckedOut(Message $message): void\n    {\n        $this-&gt;db-&gt;executeStatement(\n            \"UPDATE {$this-&gt;table()} SET guests = guests - 1 WHERE id = ?;\",\n            [$message-&gt;aggregateId()],\n        );\n    }\n\n    #[Setup]\n    public function create(): void\n    {\n        $this-&gt;db-&gt;executeStatement(\"CREATE TABLE IF NOT EXISTS {$this-&gt;table()} (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);\");\n    }\n\n    #[Teardown]\n    public function drop(): void\n    {\n        $this-&gt;db-&gt;executeStatement(\"DROP TABLE IF EXISTS {$this-&gt;table()};\");\n    }\n\n    private function table(): string\n    {\n        return 'projection_' . $this-&gt;subscriberId();\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about projector here.</p>"},{"location":"getting_started/#processor","title":"Processor","text":"<p>In our example we also want to email the head office as soon as a guest is checked in.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Processor;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Message\\Message;\n\n#[Processor('admin_emails')]\nfinal class SendCheckInEmailProcessor\n{\n    public function __construct(\n        private readonly Mailer $mailer,\n    ) {\n    }\n\n    #[Subscribe(GuestIsCheckedIn::class)]\n    public function onGuestIsCheckedIn(Message $message): void\n    {\n        $this-&gt;mailer-&gt;send(\n            'hq@patchlevel.de',\n            'Guest is checked in',\n            sprintf('A new guest named \"%s\" is checked in', $message-&gt;event()-&gt;guestName),\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about processor here.</p>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>After we have defined everything, we still have to plug the whole thing together:</p> <pre><code>use Doctrine\\DBAL\\DriverManager;\nuse Patchlevel\\EventSourcing\\Projection\\Engine\\DefaultSubscriptionEngine;\nuse Patchlevel\\EventSourcing\\Projection\\Store\\DoctrineSubscriptionStore;\nuse Patchlevel\\EventSourcing\\Projection\\Subscriber\\MetadataSubscriberAccessorRepository;\nuse Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\nuse Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer;\nuse Patchlevel\\EventSourcing\\Store\\DoctrineDbalStore;\n\n$connection = DriverManager::getConnection(['url' =&gt; 'mysql://user:secret@localhost/app']);\n\n$projectionConnection = DriverManager::getConnection(['url' =&gt; 'mysql://user:secret@localhost/projection']);\n\n/* your own mailer */\n$mailer;\n\n$serializer = DefaultEventSerializer::createFromPaths(['src/Domain/Hotel/Event']);\n$aggregateRegistry = (new AttributeAggregateRootRegistryFactory())-&gt;create(['src/Domain/Hotel']);\n\n$eventStore = new DoctrineDbalStore(\n    $connection,\n    $serializer,\n    $aggregateRegistry,\n);\n\n$hotelProjector = new HotelProjector($projectionConnection);\n\n$projectorRepository = new MetadataSubscriberAccessorRepository([\n    $hotelProjector,\n    new SendCheckInEmailProcessor($mailer),\n]);\n\n$projectionStore = new DoctrineSubscriptionStore($connection);\n\n$projectionist = new DefaultSubscriptionEngine(\n    $eventStore,\n    $projectionStore,\n    $projectorRepository,\n);\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRegistry,\n    $eventStore,\n);\n\n$hotelRepository = $repositoryManager-&gt;get(Hotel::class);\n</code></pre> <p>Note</p> <p>You can find out more about stores here.</p>"},{"location":"getting_started/#database-setup","title":"Database setup","text":"<p>So that we can actually write the data to a database, we need the associated schema and databases.</p> <pre><code>use Patchlevel\\EventSourcing\\Schema\\ChainDoctrineSchemaConfigurator;\nuse Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector;\n\n$schemaDirector = new DoctrineSchemaDirector(\n    $connection,\n    new ChainDoctrineSchemaConfigurator([\n        $eventStore,\n        $projectionStore,\n    ]),\n);\n\n$schemaDirector-&gt;create();\n$projectionist-&gt;setup(skipBooting: true);\n</code></pre> <p>Note</p> <p>you can use the predefined cli commands for this.</p>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>We are now ready to use the Event Sourcing System. We can load, change and save aggregates.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\n$hotel1 = Hotel::create(Uuid::v7(), 'HOTEL');\n$hotel1-&gt;checkIn('David');\n$hotel1-&gt;checkIn('Daniel');\n$hotel1-&gt;checkOut('David');\n\n$hotelRepository-&gt;save($hotel1);\n\n$hotel2 = $hotelRepository-&gt;load(Uuid::fromString('d0d0d0d0-d0d0-d0d0-d0d0-d0d0d0d0d0d0'));\n$hotel2-&gt;checkIn('David');\n$hotelRepository-&gt;save($hotel2);\n\n$projectionist-&gt;run();\n\n$hotels = $hotelProjection-&gt;getHotels();\n</code></pre> <p>Warning</p> <p>You need to run the projectionist to update the projections.</p> <p>Note</p> <p>You can also use other forms of IDs such as uuid version 6 or a custom format.  You can find more about this here.</p>"},{"location":"getting_started/#result","title":"Result","text":"<p>Success</p> <p>We have successfully implemented and used event sourcing.</p> <p>Feel free to browse further in the documentation for more detailed information.  If there are still open questions, create a ticket on Github and we will try to help you.</p>"},{"location":"getting_started/#learn-more","title":"Learn more","text":"<ul> <li>How to create an aggregate</li> <li>How to create an event</li> <li>How to store aggregates</li> <li>How to process events</li> <li>How to create a projection</li> <li>How to setup the database</li> </ul>"},{"location":"message_decorator/","title":"Message Decorator","text":"<p>There are use-cases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With <code>MessageDecorator</code> we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on.</p>"},{"location":"message_decorator/#built-in-decorator","title":"Built-in decorator","text":"<p>We offer a few decorators that you can use.</p>"},{"location":"message_decorator/#splitstreamdecorator","title":"SplitStreamDecorator","text":"<p>In order to use the split stream feature, the <code>SplitStreamDecorator</code> must be added.</p> <pre><code>use Patchlevel\\EventSourcing\\Metadata\\Event\\AttributeEventMetadataFactory;\nuse Patchlevel\\EventSourcing\\Repository\\MessageDecorator\\SplitStreamDecorator;\n\n$eventMetadataFactory = new AttributeEventMetadataFactory();\n$decorator = new SplitStreamDecorator($eventMetadataFactory);\n</code></pre>"},{"location":"message_decorator/#chainmessagedecorator","title":"ChainMessageDecorator","text":"<p>To use multiple decorators at the same time, you can use the <code>ChainMessageDecorator</code>.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\MessageDecorator\\ChainMessageDecorator;\n\n$decorator = new ChainMessageDecorator([\n    $decorator1,\n    $decorator2,\n]);\n</code></pre>"},{"location":"message_decorator/#use-decorator","title":"Use decorator","text":"<p>To use the message decorator, you have to pass it to the <code>DefaultRepositoryManager</code>, which will then pass it to all Repositories.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\nuse Patchlevel\\EventSourcing\\Repository\\MessageDecorator\\ChainMessageDecorator;\nuse Patchlevel\\EventSourcing\\Repository\\MessageDecorator\\SplitStreamDecorator;\n\n$decorator = new ChainMessageDecorator([new SplitStreamDecorator($eventMetadataFactory)]);\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n    $eventBus,\n    null,\n    $decorator,\n);\n\n$repository = $repositoryManager-&gt;get(Profile::class);\n</code></pre> <p>Note</p> <p>You can find out more about repository here.</p>"},{"location":"message_decorator/#create-own-decorator","title":"Create own decorator","text":"<p>You can also use this feature to add your own metadata to your events. For this the have an extra methods on <code>Message</code> to add data <code>withHeader</code> and to read this data later on <code>header</code>.</p> <pre><code>use Patchlevel\\EventSourcing\\Message\\Message;\nuse Patchlevel\\EventSourcing\\Repository\\MessageDecorator\\MessageDecorator;\n\nfinal class OnSystemRecordedDecorator implements MessageDecorator\n{\n    public function __invoke(Message $message): Message\n    {\n        return $message-&gt;withHeader('system', 'accounting_system');\n    }\n}\n</code></pre> <p>Note</p> <p>The Message is immutable, for more information look up here.</p> <p>Tip</p> <p>You can also set multiple headers with <code>withHeaders</code> which expects an hashmap.</p>"},{"location":"message_decorator/#learn-more","title":"Learn more","text":"<ul> <li>How to define events</li> <li>How to use the event bus</li> <li>How to configure repositories</li> <li>How to upcast events</li> </ul>"},{"location":"normalizer/","title":"Normalizer","text":"<p>Sometimes you also want to add more complex data in events as payload or in aggregates for the snapshots. For example DateTime, enums or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again.</p> <p>Note</p> <p>The underlying system called hydrator exists as a library.  You can find out more details here.</p>"},{"location":"normalizer/#usage","title":"Usage","text":"<p>You have to set the normalizer to the properties using the specific normalizer class.</p> <p><pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\nfinal class DTO\n{\n    #[DateTimeImmutableNormalizer]\n    public DateTimeImmutable $date;\n}\n</code></pre> The whole thing also works with property promotion and readonly properties.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\nfinal class DTO\n{\n    public function __construct(\n        #[DateTimeImmutableNormalizer]\n        public readonly DateTimeImmutable $date,\n    ) {\n    }\n}\n</code></pre>"},{"location":"normalizer/#event","title":"Event","text":"<p>For the event, the properties are normalized to a payload and saved in the DB at the end. The whole thing is then loaded again from the DB and denormalized in the properties.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Event;\nuse Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\n#[Event('hotel.create')]\nfinal class CreateHotel\n{\n    public function __construct(\n        public readonly string $name,\n        #[DateTimeImmutableNormalizer]\n        public readonly DateTimeImmutable $createAt,\n    ) {\n    }\n}\n</code></pre>"},{"location":"normalizer/#aggregate","title":"Aggregate","text":"<p>For the aggregates it is very similar to the events. However, the normalizer is only used for the snapshots. Here you can determine how the aggregate is saved in the snapshot store at the end.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\nuse Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\n#[Aggregate('hotel')]\n#[Snapshot('default')]\nfinal class Hotel extends BasicAggregateRoot\n{\n    private string $name;\n    #[DateTimeImmutableNormalizer]\n    private DateTimeImmutable $createAt;\n\n    // ...\n}\n</code></pre> <p>Note</p> <p>You can learn more about snapshots here.</p>"},{"location":"normalizer/#built-in-normalizer","title":"Built-in Normalizer","text":"<p>For some the standard cases we already offer built-in normalizers.</p>"},{"location":"normalizer/#array","title":"Array","text":"<p>If you have a list of objects that you want to normalize, then you must normalize each object individually. That's what the <code>ArrayNormalizer</code> does for you. In order to use the <code>ArrayNormaliser</code>, you still have to specify which normaliser should be applied to the individual objects. Internally, it basically does an <code>array_map</code> and then runs the specified normalizer on each element.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\ArrayNormalizer;\nuse Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\nfinal class DTO\n{\n    #[ArrayNormalizer(new DateTimeImmutableNormalizer())]\n    public array $dates;\n}\n</code></pre> <p>Note</p> <p>The keys from the arrays are taken over here.</p>"},{"location":"normalizer/#datetimeimmutable","title":"DateTimeImmutable","text":"<p>With the <code>DateTimeImmutable</code> Normalizer, as the name suggests, you can convert DateTimeImmutable objects to a String and back again.</p> <p><pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\nfinal class DTO\n{\n    #[DateTimeImmutableNormalizer]\n    public DateTimeImmutable $date;\n}\n</code></pre> You can also define the format. Either describe it yourself as a string or use one of the existing constants. The default is <code>DateTimeImmutable::ATOM</code>.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeImmutableNormalizer;\n\nfinal class DTO\n{\n    #[DateTimeImmutableNormalizer(format: DateTimeImmutable::RFC3339_EXTENDED)]\n    public DateTimeImmutable $date;\n}\n</code></pre> <p>Note</p> <p>You can read about how the format is structured in the php docs.</p>"},{"location":"normalizer/#datetime","title":"DateTime","text":"<p>The <code>DateTime</code> Normalizer works exactly like the DateTimeNormalizer. Only for DateTime objects.</p> <p><pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeNormalizer;\n\nfinal class DTO\n{\n    #[DateTimeNormalizer]\n    public DateTime $date;\n}\n</code></pre> You can also specify the format here. The default is <code>DateTime::ATOM</code>.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeNormalizer;\n\nfinal class DTO\n{\n    #[DateTimeNormalizer(format: DateTime::RFC3339_EXTENDED)]\n    public DateTime $date;\n}\n</code></pre> <p>Warning</p> <p>It is highly recommended to only ever use DateTimeImmutable objects and the DateTimeImmutableNormalizer.  This prevents you from accidentally changing the state of the DateTime and thereby causing bugs.</p> <p>Note</p> <p>You can read about how the format is structured in the php docs.</p>"},{"location":"normalizer/#datetimezone","title":"DateTimeZone","text":"<p>To normalize a <code>DateTimeZone</code> one can use the <code>DateTimeZoneNormalizer</code>.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\DateTimeZoneNormalizer;\n\nfinal class DTO\n{\n    #[DateTimeZoneNormalizer]\n    public DateTimeZone $timeZone;\n}\n</code></pre>"},{"location":"normalizer/#enum","title":"Enum","text":"<p>Backed enums can also be normalized.</p> <p><pre><code>use Patchlevel\\Hydrator\\Normalizer\\EnumNormalizer;\n\nfinal class DTO\n{\n    #[EnumNormalizer]\n    public Status $status;\n}\n</code></pre> You can also specify the enum class.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\EnumNormalizer;\n\nfinal class DTO\n{\n    #[EnumNormalizer(Status::class)]\n    public Status $status;\n}\n</code></pre>"},{"location":"normalizer/#id","title":"Id","text":"<p>If you have your own AggregateRootId, you can use the <code>IdNormalizer</code>.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\Hydrator\\Normalizer\\IdNormalizer;\n\nfinal class DTO\n{\n    #[IdNormalizer]\n    public Uuid $id;\n}\n</code></pre> Optional you can also define the type of the id.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\Hydrator\\Normalizer\\IdNormalizer;\n\nfinal class DTO\n{\n    #[IdNormalizer(Uuid::class)]\n    public Uuid $id;\n}\n</code></pre>"},{"location":"normalizer/#object","title":"Object","text":"<p>If you have a complex object that you want to normalize, you can use the <code>ObjectNormalizer</code>. Internally, it uses the <code>Hydrator</code> to normalize and denormalize the object.</p> <p><pre><code>use Patchlevel\\Hydrator\\Normalizer\\ObjectNormalizer;\n\nfinal class DTO\n{\n    #[ObjectNormalizer]\n    public ComplexObject $object;\n}\n</code></pre> Optional you can also define the type of the object.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\ObjectNormalizer;\n\nfinal class DTO\n{\n    #[ObjectNormalizer(ComplexObject::class)]\n    public object $object;\n}\n</code></pre>"},{"location":"normalizer/#custom-normalizer","title":"Custom Normalizer","text":"<p>Since we only offer normalizers for PHP native things, you have to write your own normalizers for your own structures, such as value objects.</p> <p>In our example we have built a value object that should hold a name.</p> <p><pre><code>final class Name\n{\n    public function __construct(private string $value)\n    {\n        if (strlen($value) &lt; 3) {\n            throw new NameIsToShortException($value);\n        }\n    }\n\n    public function toString(): string\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> For this we now need a custom normalizer. This normalizer must implement the <code>Normalizer</code> interface. You also need to implement a <code>normalize</code> and <code>denormalize</code> method. Finally, you have to allow the normalizer to be used as an attribute.</p> <pre><code>use Patchlevel\\Hydrator\\Normalizer\\InvalidArgument;\nuse Patchlevel\\Hydrator\\Normalizer\\Normalizer;\n\n#[Attribute(Attribute::TARGET_PROPERTY)]\nclass NameNormalizer implements Normalizer\n{\n    public function normalize(mixed $value): string\n    {\n        if (!$value instanceof Name) {\n            throw InvalidArgument::withWrongType(Name::class, $value);\n        }\n\n        return $value-&gt;toString();\n    }\n\n    public function denormalize(mixed $value): Name|null\n    {\n        if ($value === null) {\n            return null;\n        }\n\n        if (!is_string($value)) {\n            throw InvalidArgument::withWrongType('string', $value);\n        }\n\n        return new Name($value);\n    }\n}\n</code></pre> <p>Warning</p> <p>The important thing is that the result of Normalize is serializable!</p> <p>Now we can also use the normalizer directly.</p> <pre><code>final class DTO\n{\n    #[NameNormalizer]\n    public Name $name;\n}\n</code></pre> <p>Tip</p> <p>Every normalizer, including the custom normalizer, can be used both for the events and for the snapshots.</p>"},{"location":"normalizer/#normalized-name","title":"Normalized Name","text":"<p>By default, the property name is used to name the field in the normalized result. This can be customized with the <code>NormalizedName</code> attribute.</p> <p><pre><code>use Patchlevel\\Hydrator\\Attribute\\NormalizedName;\n\nfinal class DTO\n{\n    #[NormalizedName('profile_name')]\n    public string $name;\n}\n</code></pre> The whole thing looks like this</p> <pre><code>{\n  \"profile_name\": \"David\"\n}\n</code></pre> <p>Tip</p> <p>You can also rename properties to events without having a backwards compatibility break by keeping the serialized name.</p> <p>Note</p> <p>NormalizedName also works for snapshots.  But since a snapshot is just a cache, you can also just invalidate it,  if you have backwards compatibility break in the property name</p>"},{"location":"normalizer/#ignore","title":"Ignore","text":"<p>You can also ignore properties with the <code>Ignore</code> attribute.</p> <pre><code>use Patchlevel\\Hydrator\\Attribute\\Ignore;\n\nfinal class DTO\n{\n    #[Ignore]\n    public string $name;\n}\n</code></pre>"},{"location":"normalizer/#learn-more","title":"Learn more","text":"<ul> <li>How to use the Hydrator</li> <li>How to define aggregates</li> <li>How to snapshot aggregates</li> <li>How to create own aggregate id</li> <li>How to define events</li> </ul>"},{"location":"outbox/","title":"Outbox","text":"<p>There is the problem that errors can occur when saving an aggregate or in the individual event listeners. This means that you either saved an aggregate, but an error occurred in the email listener, so that no email went out. Or that an email was sent but the aggregate could not be saved.</p> <p>Both cases are very bad and can only be solved if both the saving of an aggregate and the dispatching of the events are in a transaction.</p> <p>The best way to ensure this is to store the events to be dispatched together with the aggregate in a transaction in the same database.</p> <p>After the transaction becomes successful, the events can be loaded from the outbox table with a worker and then dispatched into the correct event bus. As soon as the events have been dispatched, they are deleted from the outbox table. If an error occurs when dispatching, the whole thing will be retrieved later.</p>"},{"location":"outbox/#configuration","title":"Configuration","text":"<p>First you have to replace the correct event bus with an outbox event bus. This stores the events to be dispatched in the database.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Outbox\\OutboxEventBus;\nuse Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\n\n$eventBus = new OutboxEventBus($store);\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n    $eventBus,\n);\n</code></pre> And then you have to define the consumer. This gets the right event bus. It is used to load the events to be dispatched from the database, dispatch the events and then empty the outbox table.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\DefaultConsumer;\nuse Patchlevel\\EventSourcing\\Outbox\\EventBusPublisher;\nuse Patchlevel\\EventSourcing\\Outbox\\StoreOutboxProcessor;\n\n$consumer = DefaultConsumer::create([$mailListener]);\n\n$processor = new StoreOutboxProcessor(\n    $store,\n    new EventBusPublisher($consumer),\n);\n\n$processor-&gt;process();\n</code></pre>"},{"location":"outbox/#using-outbox","title":"Using outbox","text":"<p>So that this is also executed in a transaction, you have to make sure that a transaction has also been started.</p> <pre><code>$store-&gt;transactional(static function () use ($command, $profileRepository): void {\n    $profile = Profile::register(\n        $command-&gt;id(),\n        $command-&gt;email(),\n    );\n\n    $profileRepository-&gt;save($profile);\n});\n</code></pre> <p>Note</p> <p>You can find out more about transaction here.</p> <p>You can also interact directly with the outbox store.</p> <pre><code>$store-&gt;saveOutboxMessage($message);\n$store-&gt;markOutboxMessageConsumed($message);\n\n$store-&gt;retrieveOutboxMessages();\n$store-&gt;countOutboxMessages();\n</code></pre> <p>Note</p> <p>Both single table store and multi table store implement the outbox store.</p> <p>Tip</p> <p>Interacting with the outbox store is also possible via the cli.</p>"},{"location":"pipeline/","title":"Pipeline","text":"<p>A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them.</p> <p>Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked.</p> <p>In this example the event <code>PrivacyAdded</code> is removed and the event <code>OldVisited</code> is replaced by <code>NewVisited</code>:</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Pipeline;\nuse Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource;\nuse Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget;\n\n$pipeline = new Pipeline(\n    new StoreSource($oldStore),\n    new StoreTarget($newStore),\n    [\n        new ExcludeEventMiddleware([PrivacyAdded::class]),\n        new ReplaceEventMiddleware(OldVisited::class, static function (OldVisited $oldVisited) {\n            return new NewVisited($oldVisited-&gt;profileId());\n        }),\n        new RecalculatePlayheadMiddleware(),\n    ],\n);\n</code></pre> <p>Danger</p> <p>Under no circumstances may the same store be used that is used for the source. Otherwise the store will be broken afterwards!</p> <p>The pipeline can also be used to create or rebuild a projection:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Pipeline;\nuse Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource;\nuse Patchlevel\\EventSourcing\\Pipeline\\Target\\ConsumerTarget;\n\n$pipeline = new Pipeline(\n    new StoreSource($store),\n    ConsumerTarget::create([$projection]),\n);\n</code></pre> The principle remains the same. There is a source where the data comes from. A target where the data should flow. And any number of middlewares to do something with the data beforehand.</p>"},{"location":"pipeline/#source","title":"Source","text":"<p>The first thing you need is a source of where the data should come from.</p>"},{"location":"pipeline/#store","title":"Store","text":"<p>The <code>StoreSource</code> is the standard source to load all events from the database.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource;\n\n$source = new StoreSource($store);\n</code></pre>"},{"location":"pipeline/#in-memory","title":"In Memory","text":"<p>There is an <code>InMemorySource</code> that receives the messages in an array. This source can be used to write pipeline tests.</p> <pre><code>use Patchlevel\\EventSourcing\\Message\\Message;\nuse Patchlevel\\EventSourcing\\Pipeline\\Source\\InMemorySource;\n\n$source = new InMemorySource([\n    new Message(\n        Profile::class,\n        '1',\n        1,\n        new ProfileCreated(Email::fromString('david.badura@patchlevel.de')),\n    ),\n    // ...\n]);\n</code></pre>"},{"location":"pipeline/#custom-source","title":"Custom Source","text":"<p>You can also create your own source class. It has to inherit from <code>Source</code>. Here you can, for example, create a migration from another event sourcing system or similar system.</p> <pre><code>use Patchlevel\\EventSourcing\\Message\\Message;\nuse Patchlevel\\EventSourcing\\Pipeline\\Source\\Source;\n\n$source = new class implements Source {\n    /** @return Generator&lt;Message&gt; */\n    public function load(): Generator\n    {\n        yield new Message(\n            Profile::class,\n            '1',\n            0,\n            new ProfileCreated('1', ['name' =&gt; 'David']),\n        );\n    }\n\n    public function count(): int\n    {\n        return 1;\n    }\n};\n</code></pre>"},{"location":"pipeline/#target","title":"Target","text":"<p>After you have a source, you still need the destination of the pipeline.</p>"},{"location":"pipeline/#store_1","title":"Store","text":"<p>You can use a store to save the final result.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget;\n\n$target = new StoreTarget($store);\n</code></pre> <p>Danger</p> <p>Under no circumstances may the same store be used that is used for the source.  Otherwise the store will be broken afterwards!</p> <p>Note</p> <p>It does not matter whether the previous store was a SingleTable or a MultiTable. You can switch back and forth between both store types using the pipeline.</p>"},{"location":"pipeline/#consumer","title":"Consumer","text":"<p>A consumer can also be used as a target.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Target\\ConsumerTarget;\n\n$target = new ConsumerTarget($consumer);\n</code></pre> <p>Tip</p> <p>You can also use it to build a new projection from scratch.</p> <p>Note</p> <p>More about the consumer can be found here.</p>"},{"location":"pipeline/#in-memory_1","title":"In Memory","text":"<p>There is also an in-memory variant for the target. This target can also be used for tests. With the <code>messages</code> method you get all <code>Messages</code> that have reached the target.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Target\\InMemoryTarget;\n\n$target = new InMemoryTarget();\n\n// run pipeline\n\n$messages = $target-&gt;messages();\n</code></pre>"},{"location":"pipeline/#custom-target","title":"Custom Target","text":"<p>You can also define your own target. To do this, you need to implement the <code>Target</code> interface.</p> <pre><code>use Patchlevel\\EventSourcing\\Message\\Message;\n\nfinal class OtherStoreTarget implements Target\n{\n    public function __construct(private OtherStore $store)\n    {\n    }\n\n    public function save(Message $message): void\n    {\n        $this-&gt;store-&gt;save($message);\n    }\n}\n</code></pre>"},{"location":"pipeline/#middlewares","title":"Middlewares","text":"<p>Middelwares can be used to manipulate, delete or expand messages or events during the process.</p> <p>Warning</p> <p>It is important to know that some middlewares require recalculation from the playhead, if the target is a store. This is a numbering of the events that must be in ascending order. A corresponding note is supplied with every middleware.</p>"},{"location":"pipeline/#exclude","title":"Exclude","text":"<p>With this middleware you can exclude certain events.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware;\n\n$middleware = new ExcludeEventMiddleware([EmailChanged::class]);\n</code></pre> <p>Warning</p> <p>After this middleware, the playhead must be recalculated!</p>"},{"location":"pipeline/#include","title":"Include","text":"<p>With this middleware you can only allow certain events.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\IncludeEventMiddleware;\n\n$middleware = new IncludeEventMiddleware([ProfileCreated::class]);\n</code></pre> <p>Warning</p> <p>After this middleware, the playhead must be recalculated!</p>"},{"location":"pipeline/#filter","title":"Filter","text":"<p>If the middlewares <code>ExcludeEventMiddleware</code> and <code>IncludeEventMiddleware</code> are not sufficient, you can also write your own filter. This middleware expects a callback that returns either true to allow events or false to not allow them.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\FilterEventMiddleware;\n\n$middleware = new FilterEventMiddleware(static function (AggregateChanged $event) {\n    if (!$event instanceof ProfileCreated) {\n        return true;\n    }\n\n    return $event-&gt;allowNewsletter();\n});\n</code></pre> <p>Warning</p> <p>After this middleware, the playhead must be recalculated!</p>"},{"location":"pipeline/#exclude-archived-events","title":"Exclude Archived Events","text":"<p>With this middleware you can exclude archived events.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeArchivedEventMiddleware;\n\n$middleware = new ExcludeArchivedEventMiddleware();\n</code></pre> <p>Warning</p> <p>After this middleware, the playhead must be recalculated!</p>"},{"location":"pipeline/#only-archived-events","title":"Only Archived Events","text":"<p>With this middleware you can only allow archived events.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\OnlyArchivedEventMiddleware;\n\n$middleware = new OnlyArchivedEventMiddleware();\n</code></pre> <p>Warning</p> <p>After this middleware, the playhead must be recalculated!</p>"},{"location":"pipeline/#replace","title":"Replace","text":"<p>If you want to replace an event, you can use the <code>ReplaceEventMiddleware</code>. The first parameter you have to define is the event class that you want to replace. And as a second parameter a callback, that the old event awaits and a new event returns.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware;\n\n$middleware = new ReplaceEventMiddleware(OldVisited::class, static function (OldVisited $oldVisited) {\n    return new NewVisited($oldVisited-&gt;profileId());\n});\n</code></pre> <p>Note</p> <p>The middleware takes over the playhead and recordedAt information.</p>"},{"location":"pipeline/#until","title":"Until","text":"<p>A use case could also be that you want to look at the projection from a previous point in time. You can use the <code>UntilEventMiddleware</code> to only allow events that were <code>recorded</code> before this point in time.</p> <pre><code>$middleware = new UntilEventMiddleware(new DateTimeImmutable('2020-01-01 12:00:00'));\n</code></pre> <p>Warning</p> <p>After this middleware, the playhead must be recalculated!</p>"},{"location":"pipeline/#recalculate-playhead","title":"Recalculate playhead","text":"<p>This middleware can be used to recalculate the playhead. The playhead must always be in ascending order so that the data is valid. Some middleware can break this order and the middleware <code>RecalculatePlayheadMiddleware</code> can fix this problem.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware;\n\n$middleware = new RecalculatePlayheadMiddleware();\n</code></pre> <p>Note</p> <p>You only need to add this middleware once at the end of the pipeline.</p>"},{"location":"pipeline/#chain","title":"Chain","text":"<p>If you want to group your middleware, you can use one or more <code>ChainMiddleware</code>.</p> <pre><code>use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ChainMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware;\n\n$middleware = new ChainMiddleware([\n    new ExcludeEventMiddleware([EmailChanged::class]),\n    new RecalculatePlayheadMiddleware(),\n]);\n</code></pre>"},{"location":"pipeline/#custom-middleware","title":"Custom middleware","text":"<p>You can also write a custom middleware. The middleware gets a message and can return <code>N</code> messages. There are the following possibilities:</p> <ul> <li>Return only the message to an array to leave it unchanged.</li> <li>Put another message in the array to swap the message.</li> <li>Return an empty array to remove the message.</li> <li>Or return multiple messages to enrich the stream.</li> </ul> <p>In our case, the domain has changed a bit. In the beginning we had a <code>ProfileCreated</code> event that just created a profile. Now we have a <code>ProfileRegistered</code> and a <code>ProfileActivated</code> event, which should replace the <code>ProfileCreated</code> event.</p> <pre><code>use Patchlevel\\EventSourcing\\Message\\Message;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\Middleware;\n\nfinal class SplitProfileCreatedMiddleware implements Middleware\n{\n    public function __invoke(Message $message): array\n    {\n        $event = $message-&gt;event();\n\n        if (!$event instanceof ProfileCreated) {\n            return [$message];\n        }\n\n        $profileRegisteredMessage = Message::createWithHeaders(\n            new ProfileRegistered($event-&gt;id(), $event-&gt;name()),\n            $message-&gt;headers(),\n        );\n\n        $profileActivatedMessage = Message::createWithHeaders(\n            new ProfileActivated($event-&gt;id()),\n            $message-&gt;headers(),\n        );\n\n        return [$profileRegisteredMessage, $profileActivatedMessage];\n    }\n}\n</code></pre> <p>Warning</p> <p>Since we changed the number of messages, we have to recalculate the playhead.</p> <p>Note</p> <p>You can find more about messages here.</p>"},{"location":"repository/","title":"Repository","text":"<p>A <code>repository</code> takes care of storing and loading the <code>aggregates</code>. He is also responsible for building messages from the events and optionally dispatching them to the event bus.</p>"},{"location":"repository/#create-a-repository","title":"Create a repository","text":"<p>The best way to create a repository is to use the <code>DefaultRepositoryManager</code>. This helps to build the repository correctly.</p> <p>The <code>DefaultRepositoryManager</code> needs some services to work. For one, it needs AggregateRootRegistry so that it knows which aggregates exist. And the store, which is then given to the repository so that it can save and load the events at the end.</p> <p>After plugging the <code>DefaultRepositoryManager</code> together, you can create the repository associated with the aggregate.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n);\n\n$repository = $repositoryManager-&gt;get(Profile::class);\n</code></pre> <p>Note</p> <p>The same repository instance is always returned for a specific aggregate.</p>"},{"location":"repository/#event-bus","title":"Event Bus","text":"<p>You can pass an event bus to the <code>DefaultRepositoryManager</code> to dispatch events synchronously. This is useful if you want to react to events in the same transaction.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\DefaultEventBus;\nuse Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\n\n$eventBus = DefaultEventBus::create([/* listeners */]);\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n    $eventBus,\n);\n\n$repository = $repositoryManager-&gt;get(Profile::class);\n</code></pre> <p>Warning</p> <p>If you use the event bus, you should be aware that the events are dispatched synchronously. You may encounter \"at least once\" problems.</p> <p>Note</p> <p>You can find out more about event bus here.</p> <p>Tip</p> <p>In most cases it is better to react to events asynchronously,  that's why we recommend the subscription engine. More information can be found here.</p>"},{"location":"repository/#snapshots","title":"Snapshots","text":"<p>Loading events for an aggregate is superfast. You can have thousands of events in the database that load in a few milliseconds and build the corresponding aggregate.</p> <p>But at some point you realize that it takes time. To counteract this there is a snapshot store.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\nuse Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter;\nuse Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore;\n\n$adapter = new Psr16SnapshotAdapter($cache);\n$snapshotStore = new DefaultSnapshotStore(['default' =&gt; $adapter]);\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n    null,\n    $snapshotStore,\n);\n\n$repository = $repositoryManager-&gt;get(Profile::class);\n</code></pre> <p>Note</p> <p>You can find out more about snapshots here.</p>"},{"location":"repository/#decorator","title":"Decorator","text":"<p>If you want to add more metadata to the message, like e.g. an application id, then you can use decorators.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\n\n$decorator = new ApplicationIdDecorator();\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n    null,\n    null,\n    $decorator,\n);\n\n$repository = $repositoryManager-&gt;get(Profile::class);\n</code></pre> <p>Note</p> <p>You can find out more about message decorator here.</p>"},{"location":"repository/#use-the-repository","title":"Use the repository","text":"<p>Each <code>repository</code> has three methods that are responsible for loading an <code>aggregate</code>, saving it or checking whether it exists.</p>"},{"location":"repository/#save-an-aggregate","title":"Save an aggregate","text":"<p>An <code>aggregate</code> can be <code>saved</code>. All new events that have not yet been written to the database are fetched from the aggregate. These events are then also append to the database.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\n$id = Uuid::v7();\n$profile = Profile::create($id, 'david.badura@patchlevel.de');\n\n$repository-&gt;save($profile);\n</code></pre> <p>Note</p> <p>All events are written to the database with one transaction in order to ensure data consistency.</p>"},{"location":"repository/#load-an-aggregate","title":"Load an aggregate","text":"<p>An <code>aggregate</code> can be loaded using the <code>load</code> method. All events for the aggregate are loaded from the database and the current state is rebuilt.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\n$id = Uuid::fromString('229286ff-6f95-4df6-bc72-0a239fe7b284');\n$profile = $repository-&gt;load($id);\n</code></pre> <p>Warning</p> <p>When the method is called, the aggregate is always reloaded and rebuilt from the database.</p> <p>Note</p> <p>You can only fetch one aggregate at a time and don't do any complex queries either.  Projections are used for this purpose.</p>"},{"location":"repository/#has-an-aggregate","title":"Has an aggregate","text":"<p>You can also check whether an <code>aggregate</code> with a certain id exists. It is checked whether any event with this id exists in the database.</p> <pre><code>$id = Uuid::fromString('229286ff-6f95-4df6-bc72-0a239fe7b284');\n\nif ($repository-&gt;has($id)) {\n    // ...\n}\n</code></pre> <p>Note</p> <p>The query is fast and does not load any event.  This means that the state of the aggregate is not rebuild either.</p>"},{"location":"repository/#custom-repository","title":"Custom Repository","text":"<p>In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\Repository;\nuse Patchlevel\\EventSourcing\\Repository\\RepositoryManager;\n\nclass ProfileRepository\n{\n    /** @var Repository&lt;Profile&gt;  */\n    private Repository $repository;\n\n    public function __construct(RepositoryManager $repositoryManager)\n    {\n        $this-&gt;repository = $repositoryManager-&gt;get(Profile::class);\n    }\n\n    public function load(ProfileId $id): Profile\n    {\n        return $this-&gt;repository-&gt;load($id);\n    }\n\n    public function save(Profile $profile): void\n    {\n        $this-&gt;repository-&gt;save($profile);\n    }\n\n    public function has(ProfileId $id): bool\n    {\n        return $this-&gt;repository-&gt;has($id);\n    }\n}\n</code></pre>"},{"location":"snapshots/","title":"Snapshots","text":"<p>Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The <code>snapshot</code> system can be used to control this.</p> <p>Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a <code>snapshot</code>, we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all.</p>"},{"location":"snapshots/#configuration","title":"Configuration","text":"<p>First of all you have to define a snapshot store. This store may have multiple adapters for different caches. These caches also need a name so that you can determine which aggregates should be stored in which cache.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter;\nuse Patchlevel\\EventSourcing\\Snapshot\\DefaultSnapshotStore;\n\n$snapshotStore = new DefaultSnapshotStore([\n    'default' =&gt; new Psr16SnapshotAdapter($defaultCache),\n    'other_cache' =&gt; new Psr16SnapshotAdapter($otherCache),\n]);\n</code></pre> After creating the snapshot store, you need to pass that store to the DefaultRepositoryManager.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\DefaultRepositoryManager;\n\n$snapshotStore = // ...\n\n$repositoryManager = new DefaultRepositoryManager(\n    $aggregateRootRegistry,\n    $store,\n    $eventBus,\n    $snapshotStore,\n);\n</code></pre> <p>Note</p> <p>You can read more about Repository here.</p> <p>Next we need to tell the Aggregate to take a snapshot of it. We do this using the snapshot attribute. There we also specify where it should be saved.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\n\n#[Aggregate('profile')]\n#[Snapshot('default')]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n}\n</code></pre> When taking a snapshot, all properties are extracted and saved. When loading, this data is written back to the properties. In other words, in the end everything has to be serializable. To ensure this, the same system is used as for the events. You can define normalizers to bring the properties into the correct format.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Aggregate('profile')]\n#[Snapshot('default')]\nfinal class Profile extends BasicAggregateRoot\n{\n    #[Id]\n    #[IdNormalizer]\n    public Uuid $id;\n    public string $name;\n    #[Normalize(new DateTimeImmutableNormalizer())]\n    public DateTimeImmutable $createdAt;\n\n    // ...\n}\n</code></pre> <p>Danger</p> <p>If anything changes in the properties of the aggregate, then the cache must be cleared. Or the snapshot version needs to be changed so that the previous snapshot is invalid.</p> <p>Warning</p> <p>In the end it the complete aggregate must be serializeable as json, also the aggregate Id.</p> <p>Note</p> <p>You can find more about normalizer here.</p>"},{"location":"snapshots/#snapshot-batching","title":"Snapshot batching","text":"<p>Since the loading of events in itself is quite fast and only becomes noticeably slower with thousands of events, we do not need to create a snapshot after each event. That would also have a negative impact on performance. Instead, we can also create a snapshot after <code>N</code> events. The remaining events that are not in the snapshot are then loaded from store.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\n\n#[Aggregate('profile')]\n#[Snapshot('default', batch: 1000)]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n}\n</code></pre>"},{"location":"snapshots/#snapshot-versioning","title":"Snapshot versioning","text":"<p>Whenever something changes on the aggregate, the previous snapshot must be discarded. You can do this by removing the entire snapshot cache when deploying. But that can be quickly forgotten. It is much easier to specify a snapshot version. This snapshot version is also saved. When loading, the versions are compared and if they do not match, the snapshot is discarded and the aggregate is rebuilt from scratch. The new aggregate is then saved again as a snapshot.</p> <pre><code>use Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\n\n#[Aggregate('profile')]\n#[Snapshot('default', version: '2')]\nfinal class Profile extends BasicAggregateRoot\n{\n    // ...\n}\n</code></pre> <p>Warning</p> <p>If the snapshots are discarded, a load peak can occur since the aggregates have to be rebuilt.</p> <p>Tip</p> <p>You can also use uuids for the snapshot version.</p>"},{"location":"snapshots/#adapter","title":"Adapter","text":"<p>We offer a few <code>SnapshotAdapter</code> implementations that you can use. But not a direct implementation of a cache. There are many good libraries out there that address this problem, and before we reinvent the wheel, choose one of them. Since there is a psr-6 and psr-16 standard, there are plenty of libraries. Here are a few listed:</p> <ul> <li>symfony cache</li> <li>laminas cache</li> <li>scrapbook</li> </ul>"},{"location":"snapshots/#psr6","title":"psr6","text":"<p>A <code>Psr6SnapshotAdapter</code>, the associated documentation can be found here.</p> <pre><code>use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr6SnapshotAdapter;\n\n$adapter = new Psr6SnapshotAdapter($cache);\n</code></pre>"},{"location":"snapshots/#psr16","title":"psr16","text":"<p>A <code>Psr16SnapshotAdapter</code>, the associated documentation can be found here.</p> <pre><code>use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\Psr16SnapshotAdapter;\n\n$adapter = new Psr16SnapshotAdapter($cache);\n</code></pre>"},{"location":"snapshots/#in-memory","title":"in memory","text":"<p>A <code>InMemorySnapshotAdapter</code> that can be used for test purposes.</p> <pre><code>use Patchlevel\\EventSourcing\\Snapshot\\Adapter\\InMemorySnapshotAdapter;\n\n$adapter = new InMemorySnapshotAdapter();\n</code></pre>"},{"location":"snapshots/#usage","title":"Usage","text":"<p>The snapshot store is automatically used by the repository and takes care of saving and loading. But you can also use the snapshot store yourself.</p>"},{"location":"snapshots/#save","title":"Save","text":"<p>This allows you to save the aggregate as a snapshot:</p> <pre><code>$snapshotStore-&gt;save($aggregate);\n</code></pre> <p>Danger</p> <p>If the state of an aggregate is saved as a snapshot without being saved to the event store (database),  it can lead to data loss or broken aggregates!</p>"},{"location":"snapshots/#load","title":"Load","text":"<p>You can also load an aggregate from the snapshot store:</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\n$id = Uuid::fromString('229286ff-6f95-4df6-bc72-0a239fe7b284');\n$aggregate = $snapshotStore-&gt;load(Profile::class, $id);\n</code></pre> The method returns the Aggregate if it was loaded successfully. If the aggregate was not found, then a <code>SnapshotNotFound</code> is thrown. And if the version is no longer correct and the snapshot is therefore invalid, then a <code>SnapshotVersionInvalid</code> is thrown.</p> <p>Warning</p> <p>The aggregate may be in an old state as the snapshot may lag behind.  You still have to bring the aggregate up to date by loading the missing events from the event store.</p>"},{"location":"split_stream/","title":"Splitting the eventstream","text":"<p>In some cases the business has rules which implies an restart of the event stream for an aggregate since the past events are not relevant for the current state. For example a user decides to end his active subscription and the business rules says if the user start a new subscription all past events should not be considered anymore. Another case could be a banking scenario. There the business decides to save the current state every quarter for each banking account.</p> <p>Not only that some businesses requires such an action it also increases the performance for aggregate which would have a really long event stream.</p>"},{"location":"split_stream/#flagging-an-event-to-split-the-stream","title":"Flagging an event to split the stream","text":"<p>To use this feature you need to add the <code>SplitStreamDecorator</code>. You will also need events which will trigger this action. For that you can use the <code>#[SplitStream]</code> attribute. We decided that we are not literallty splitting the stream, instead we are marking all past events as archived as soon as this event is saved. Then the past events will not be loaded anymore for building the aggregate. This means that all needed data has to be present in these events which should trigger the event split.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Event;\nuse Patchlevel\\EventSourcing\\Attribute\\SplitStream;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Event('bank_account.month_passed')]\n#[SplitStream]\nfinal class MonthPassed\n{\n    public function __construct(\n        #[IdNormalizer]\n        public AccountId $accountId,\n        public string $name,\n        public int $balanceInCents,\n    ) {\n    }\n}\n</code></pre> <p>Warning</p> <p>The event needs all data which is relevant the aggregate to be used since all past event will not be loaded! Keep  this in mind if you want to use this feature.</p> <p>Note</p> <p>This archive flag only impacts the Store::load method which is used the build the aggregate from the stream.</p>"},{"location":"store/","title":"Store","text":"<p>In the end, the messages have to be saved somewhere. Each message contains an event and the associated headers.</p> <p>Note</p> <p>More information about the message can be found here.</p> <p>The store is optimized to efficiently store and load events for aggregates. We currently only offer one doctrine dbal store.</p>"},{"location":"store/#create-dbal-connection","title":"Create DBAL connection","text":"<p>The first thing we need for our store is a DBAL connection:</p> <pre><code>use Doctrine\\DBAL\\DriverManager;\n\n$connection = DriverManager::getConnection(['url' =&gt; 'mysql://user:secret@localhost/app']);\n</code></pre> <p>Note</p> <p>You can find out more about how to create a connection  here</p>"},{"location":"store/#configure-store","title":"Configure Store","text":"<p>You can create a store with the <code>DoctrineDbalStore</code> class. The store needs a dbal connection, an event serializer, an aggregate registry and a table name.</p> <pre><code>use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry;\nuse Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer;\nuse Patchlevel\\EventSourcing\\Store\\DoctrineDbalStore;\n\n$store = new DoctrineDbalStore(\n    $connection,\n    DefaultEventSerializer::createFromPaths(['src/Event']),\n    new AggregateRootRegistry([\n        'profile' =&gt; Profile::class,\n    ]),\n    'eventstore',\n);\n</code></pre>"},{"location":"store/#schema","title":"Schema","text":"<p>The table structure of the <code>DoctrineDbalStore</code> looks like this:</p> Column Type Description id bigint The index of the whole stream (autoincrement) aggregate string The name of the aggregate aggregate_id string The id of the aggregate playhead int The current playhead of the aggregate event string The name of the event payload json The payload of the event recorded_on datetime The date when the event was recorded new_stream_start bool If the event is the first event of the aggregate archived bool If the event is archived custom_headers json Custom headers for the event <p>With the help of the <code>SchemaDirector</code>, the database structure can be created, updated and deleted.</p> <p>Tip</p> <p>You can also use doctrine migration to create and keep your schema in sync.</p>"},{"location":"store/#schema-director","title":"Schema Director","text":"<p>The <code>SchemaDirector</code> is responsible for creating, updating and deleting the database schema. The <code>DoctrineSchemaDirector</code> is a concrete implementation of the <code>SchemaDirector</code> for doctrine dbal. Additionally, it implements the <code>DryRunSchemaDirector</code> interface, to show the sql statements that would be executed.</p> <pre><code>use Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector;\n\n$schemaDirector = new DoctrineSchemaDirector(\n    $connection,\n    $store,\n);\n</code></pre> <p>Note</p> <p>How to setup cli commands for schema director can be found here.</p>"},{"location":"store/#create-schema","title":"Create schema","text":"<p>You can create the table from scratch using the <code>create</code> method.</p> <p><pre><code>$schemaDirector-&gt;create();\n</code></pre> Or can give you back which SQL statements would be necessary for this. Either for a dry run, or to define your own migrations.</p> <pre><code>$sql = $schemaDirector-&gt;dryRunCreate();\n</code></pre>"},{"location":"store/#update-schema","title":"Update schema","text":"<p>The update method compares the current state in the database and how the table should be structured. As a result, the diff is executed to bring the table to the desired state.</p> <p><pre><code>$schemaDirector-&gt;update();\n</code></pre> Or can give you back which SQL statements would be necessary for this.</p> <pre><code>$sql = $schemaDirector-&gt;dryRunUpdate();\n</code></pre>"},{"location":"store/#drop-schema","title":"Drop schema","text":"<p>You can also delete the table with the <code>drop</code> method.</p> <p><pre><code>$schemaDirector-&gt;drop();\n</code></pre> Or can give you back which SQL statements would be necessary for this.</p> <pre><code>$sql = $schemaDirector-&gt;dryRunDrop();\n</code></pre>"},{"location":"store/#doctrine-migrations","title":"Doctrine Migrations","text":"<p>You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. We have added a <code>DoctrineMigrationSchemaProvider</code> for doctrine migrations so that you just have to plug the whole thing together.</p> <pre><code>use Patchlevel\\EventSourcing\\Schema\\DoctrineMigrationSchemaProvider;\nuse Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector;\n\n// event sourcing schema director configuration\n\n$schemaDirector = new DoctrineSchemaDirector(\n    $store,\n    $connection,\n);\n\n$schemaProvider = new DoctrineMigrationSchemaProvider($schemaDirector);\n\n// doctrine migration configuration\n\n$dependencyFactory = DependencyFactory::fromConnection(\n    $config,\n    new ExistingConnection($connection),\n);\n\n$dependencyFactory-&gt;setService(\n    SchemaProvider::class,\n    $schemaProvider,\n);\n</code></pre> <p>Note</p> <p>Here you can find more information on how to  configure doctrine migration.</p> <p>Note</p> <p>How to setup cli commands for doctrine migration can be found here.</p>"},{"location":"store/#usage","title":"Usage","text":"<p>The store has a few methods to interact with the database.</p>"},{"location":"store/#load","title":"Load","text":"<p>You can load all events from an aggregate with the <code>load</code> method. This method returns a <code>Stream</code> object, which is a collection of events.</p> <p><pre><code>$stream = $store-&gt;load();\n</code></pre> The load method also has a few parameters to filter, limit and sort the events.</p> <pre><code>use Patchlevel\\EventSourcing\\Store\\Criteria;\n\n$stream = $store-&gt;load(\n    new Criteria(), // filter criteria\n    100, // limit\n    50, // offset\n    true,  // latest first\n);\n</code></pre>"},{"location":"store/#criteria","title":"Criteria","text":"<p>The <code>Criteria</code> object is used to filter the events.</p> <pre><code>use Patchlevel\\EventSourcing\\Store\\Criteria;\n\n$criteria = new Criteria(\n    aggregateName: 'profile',\n    aggregateId: 'e3e3e3e3-3e3e-3e3e-3e3e-3e3e3e3e3e3e',\n    fromIndex: 100,\n    fromPlayhead: 2,\n    archived: true,\n);\n</code></pre> <p>Note</p> <p>The individual criteria must all apply, but not all of them have to be set.</p>"},{"location":"store/#stream","title":"Stream","text":"<p>The load method returns a <code>Stream</code> object and is a generator. This means that the messages are only loaded when they are needed.</p> <pre><code>use Patchlevel\\EventSourcing\\Store\\Stream;\n\n/** @var Stream $stream */\n$stream-&gt;index(); // get the index of the stream\n$stream-&gt;position(); // get the current position of the stream\n$stream-&gt;current(); // get the current event\n$stream-&gt;next(); // move to the next event\n$stream-&gt;end(); // check if the stream is at the end\n\nforeach ($stream as $message) {\n    $message-&gt;event(); // get the event\n}\n</code></pre> <p>Note</p> <p>You can find more information about the <code>Message</code> object here.</p> <p>Warning</p> <p>The stream cannot rewind, so you can only iterate over it once. If you want to iterate over it again, you have to call the <code>load</code> method again.</p>"},{"location":"store/#count","title":"Count","text":"<p>You can count the number of events in the store with the <code>count</code> method.</p> <p><pre><code>$count = $store-&gt;count();\n</code></pre> The count method also has the possibility to filter the events.</p> <pre><code>use Patchlevel\\EventSourcing\\Store\\Criteria;\n\n$count = $store-&gt;count(\n    new Criteria(), // filter criteria\n);\n</code></pre>"},{"location":"store/#save","title":"Save","text":"<p>You can save a message with the <code>save</code> method.</p> <pre><code>$store-&gt;save($message);\n$store-&gt;save($message1, $message2, $message3);\n$store-&gt;save(...$messages);\n</code></pre> <p>Note</p> <p>The saving happens in a transaction, so all messages are saved or none.    </p>"},{"location":"store/#delete-update","title":"Delete &amp; Update","text":"<p>It is not possible to delete or update events. In event sourcing, the events are immutable.</p>"},{"location":"store/#transaction","title":"Transaction","text":"<p>There is also the possibility of executing a function in a transaction. Then dbal takes care of starting a transaction, committing it and then possibly rollback it again.</p> <pre><code>$store-&gt;transactional(static function () use ($command, $bankAccountRepository): void {\n    $accountFrom = $bankAccountRepository-&gt;get($command-&gt;from());\n    $accountTo = $bankAccountRepository-&gt;get($command-&gt;to());\n\n    $accountFrom-&gt;transferMoney($command-&gt;to(), $command-&gt;amount());\n    $accountTo-&gt;receiveMoney($command-&gt;from(), $command-&gt;amount());\n\n    $bankAccountRepository-&gt;save($accountFrom);\n    $bankAccountRepository-&gt;save($accountTo);\n});\n</code></pre>"},{"location":"subscription/","title":"Subscriptions","text":"<p>One core concept of event sourcing is the ability to react and process events in a different way. This is where subscriptions and the subscription engine come into play.</p> <p>There are different types of subscriptions. In most cases, we are talking about projector and processor. But you can use it for anything like migration, report or something else.</p> <p>For this, we use the event store to get the events and process them. The event store remains untouched and everything can always be reproduced from the events.</p> <p>The subscription engine manages individual subscribers and keeps the subscriptions running. Internally, the subscription engine does this by tracking where each subscriber is in the event stream.</p>"},{"location":"subscription/#subscriber","title":"Subscriber","text":"<p>If you want to react to events, you have to create a subscriber. Each subscriber need a unique ID and a run mode.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Subscription\\RunMode;\n\n#[Subscriber('do_stuff', RunMode::Once)]\nfinal class DoStuffSubscriber\n{\n}\n</code></pre> <p>Note</p> <p>For each subsciber ID, the engine will create a subscription. If the subscriber ID changes, a new subscription will be created. In some cases like projections, you want to change the subscriber ID to rebuild the projection.</p> <p>Tip</p> <p>You can use specific attributes for specific subscribers like <code>Projector</code> or <code>Processor</code>. So you don't have to define the group and run mode every time.</p>"},{"location":"subscription/#projector","title":"Projector","text":"<p>You can create projections and read models with a subscriber. We named this type of subscriber <code>projector</code>. But in the end it's the same.</p> <p><pre><code>use Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Subscription\\RunMode;\n\n#[Subscriber('profile_1', RunMode::FromBeginning)]\nfinal class ProfileProjector\n{\n    public function __construct(\n        private readonly Connection $connection,\n    ) {\n    }\n}\n</code></pre> Mostly you want process the events from the beginning. For this reason, it is also possible to use the <code>Projector</code> attribute. It extends the <code>Subscriber</code> attribute with a default group and run mode.</p> <pre><code>use Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Attribute\\Projector;\n\n#[Projector('profile_1')]\nfinal class ProfileProjector\n{\n    public function __construct(\n        private readonly Connection $connection,\n    ) {\n    }\n}\n</code></pre> <p>Warning</p> <p>MySQL and MariaDB don't support transactions for DDL statements. So you must use a different database connection for your subscriptions.</p> <p>Note</p> <p>More about the projector and projections can be found here.</p> <p>Tip</p> <p>Add a version as suffix to the subscriber id so you can increment it when the subscription changes. Like <code>profile_1</code> to <code>profile_2</code>.</p>"},{"location":"subscription/#processor","title":"Processor","text":"<p>The other way to react to events is to take actions like sending an email, dispatch commands or change other aggregates. We named this type of subscriber <code>processor</code>.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Subscription\\RunMode;\n\n#[Subscriber('welcome_email', RunMode::FromNow)]\nfinal class WelcomeEmailProcessor\n{\n    public function __construct(\n        private readonly Mailer $mailer,\n    ) {\n    }\n}\n</code></pre> Mostly you want process the events from now, because you don't want to email users who already have an account since a long time.</p> <p>For this reason, it is also possible to use the <code>Processor</code> attribute. It extends the <code>Subscriber</code> attribute with a default group and run mode.</p> <pre><code>use Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Attribute\\Processor;\n\n#[Processor('welcome_email')]\nfinal class WelcomeEmailProcessor\n{\n    public function __construct(\n        private readonly Connection $connection,\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>More about the processor can be found here.</p>"},{"location":"subscription/#subscribe","title":"Subscribe","text":"<p>A subscriber (projector/processor) can subscribe any number of events. In order to say which method is responsible for which event, you need the <code>Subscribe</code> attribute. There you can pass the event class to which the reaction should then take place. The method itself must expect a <code>Message</code>, which then contains the event. The method name itself doesn't matter.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Message\\Message;\n\n#[Subscriber('do_stuff', RunMode::Once)]\nfinal class DoStuffSubscriber\n{\n    #[Subscribe(ProfileCreated::class)]\n    public function onProfileCreated(Message $message): void\n    {\n        $profileCreated = $message-&gt;event();\n\n        // do something\n    }\n}\n</code></pre> <p>Note</p> <p>You can subscribe to multiple events on the same method or you can use \"*\" to subscribe to all events. More about this can be found here.</p> <p>Tip</p> <p>If you are using psalm then you can install the event sourcing plugin  to make the event method return the correct type.</p>"},{"location":"subscription/#setup-and-teardown","title":"Setup and Teardown","text":"<p>Subscribers can have one <code>setup</code> and <code>teardown</code> method that is executed when the subscription is created or deleted. For this there are the attributes <code>Setup</code> and <code>Teardown</code>. The method name itself doesn't matter. This is especially helpful for projectors, as they can create the necessary structures for the projection here.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Projector;\nuse Patchlevel\\EventSourcing\\Attribute\\Setup;\nuse Patchlevel\\EventSourcing\\Attribute\\Teardown;\nuse Patchlevel\\EventSourcing\\Subscription\\Subscriber\\SubscriberUtil;\n\n#[Projector('profile_1')]\nfinal class ProfileProjector\n{\n    use SubscriberUtil;\n\n    // ...\n\n    #[Setup]\n    public function create(): void\n    {\n        $this-&gt;connection-&gt;executeStatement(\n            \"CREATE TABLE IF NOT EXISTS {$this-&gt;table()} (id VARCHAR PRIMARY KEY, name VARCHAR NOT NULL);\",\n        );\n    }\n\n    #[Teardown]\n    public function drop(): void\n    {\n        $this-&gt;connection-&gt;executeStatement(\"DROP TABLE IF EXISTS {$this-&gt;table()};\");\n    }\n\n    private function table(): string\n    {\n        return 'projection_' . $this-&gt;subscriberId();\n    }\n}\n</code></pre> <p>Danger</p> <p>MySQL and MariaDB don't support transactions for DDL statements. So you must use a different database connection in your projectors,  otherwise you will get an error when the subscription tries to create the table.</p> <p>Warning</p> <p>If you change the subscriber id, you must also change the table/collection name. The subscription engine will create a new subscription with the new subscriber id. That means the setup method will be called again and the table/collection will conflict with the old existing projection. You can use the <code>SubscriberUtil</code> to build the table/collection name.</p> <p>Note</p> <p>Most databases have a limit on the length of the table/collection name. The limit is usually 64 characters.</p>"},{"location":"subscription/#versioning","title":"Versioning","text":"<p>As soon as the structure of a projection changes, or you need other events from the past, you can change the subscriber ID to rebuild the projection. This will trigger the subscription engine to create a new subscription and boot the projection from the beginning.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Projector;\n\n#[Projector('profile_2')]\nfinal class ProfileSubscriber\n{\n   // ...\n}\n</code></pre> <p>Warning</p> <p>If you change the <code>subscriberID</code>, you must also change the table/collection name. Otherwise the table/collection will conflict with the old subscription.</p> <p>Tip</p> <p>Add a version as suffix to the subscriber id so you can increment it when the subscription changes. Like <code>profile_1</code> to <code>profile_2</code>.</p>"},{"location":"subscription/#grouping","title":"Grouping","text":"<p>You can also group subscribers together and filter them in the subscription engine. This is useful if you want to run subscribers in different processes or on different servers.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscriber;\n\n#[Subscriber('profile_1', group: 'a')]\nfinal class ProfileSubscriber\n{\n   // ...\n}\n</code></pre> <p>Note</p> <p>The different attributes has different default group.</p> <ul> <li><code>Subscriber</code> - <code>default</code></li> <li><code>Projector</code> - <code>projector</code></li> <li><code>Processor</code> - <code>processor</code></li> </ul>"},{"location":"subscription/#run-mode","title":"Run Mode","text":"<p>The run mode determines how the subscriber should behave. There are three different modes:</p>"},{"location":"subscription/#from-beginning","title":"From Beginning","text":"<p>The subscriber will start from the beginning of the event stream and process all events. This is useful for subscribers that need to build up a projection from scratch.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Subscription\\RunMode;\n\n#[Subscriber('welcome_email', RunMode::FromBeginning)]\nfinal class WelcomeEmailSubscriber\n{\n   // ...\n}\n</code></pre> <p>Tip</p> <p>If you want create projections and run from the beginning, you can use the <code>Projector</code> attribute.</p>"},{"location":"subscription/#from-now","title":"From Now","text":"<p>Certain subscribers operate exclusively on post-release events, disregarding historical data. This is useful for subscribers that are only interested in events that occur after a certain point in time. As example, a welcome email subscriber that only wants to send emails to new users.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Subscription\\RunMode;\n\n#[Subscriber('welcome_email', RunMode::FromNow)]\nfinal class WelcomeEmailSubscriber\n{\n   // ...\n}\n</code></pre> <p>Tip</p> <p>If you want process events from now, you can use the <code>Processor</code> attribute.</p>"},{"location":"subscription/#once","title":"Once","text":"<p>This mode is useful for subscribers that only need to run once. This is useful for subscribers to create reports or to migrate data.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Subscriber;\nuse Patchlevel\\EventSourcing\\Subscription\\RunMode;\n\n#[Subscriber('migration', RunMode::Once)]\nfinal class MigrationSubscriber\n{\n   // ...\n}\n</code></pre>"},{"location":"subscription/#subscription-engine","title":"Subscription Engine","text":"<p>The subscription engine manages individual subscribers and keeps the subscriptions running. Internally, the subscription engine does this by tracking where each subscriber is in the event stream and keeping all subscriptions up to date.</p> <p>He also takes care that new subscribers are booted and old ones are removed again. If something breaks, the subscription engine marks the individual subscriptions as faulty and retries them.</p> <p>Tip</p> <p>The Subscription Engine was inspired by the following two blog posts:</p> <ul> <li>Projection Building Blocks: What you'll need to build projections</li> <li>Managing projectors is harder than you think</li> </ul>"},{"location":"subscription/#subscription-id","title":"Subscription ID","text":"<p>The subscription ID is taken from the associated subscriber and corresponds to the subscriber ID. Unlike the subscriber ID, the subscription ID can no longer change. If the Subscriber ID is changed, a new subscription will be created with this new subscriber ID. So there are two subscriptions, one with the old subscriber ID and one with the new subscriber ID.</p>"},{"location":"subscription/#subscription-position","title":"Subscription Position","text":"<p>Furthermore, the position in the event stream is stored for each subscription. So that the subscription engine knows where the subscription stopped and must continue.</p>"},{"location":"subscription/#subscription-status","title":"Subscription Status","text":"<p>There is a lifecycle for each subscription. This cycle is tracked by the subscription engine.</p> <pre><code>stateDiagram-v2\n    direction LR\n    [*] --&gt; New\n    New --&gt; Booting\n    New --&gt; Active\n    New --&gt; Error\n    Booting --&gt; Active\n    Booting --&gt; Paused\n    Booting --&gt; Finished\n    Booting --&gt; Error\n    Active --&gt; Paused\n    Active --&gt; Finished\n    Active --&gt; Detached\n    Active --&gt; Error\n    Paused --&gt; Booting\n    Paused --&gt; Active\n    Paused --&gt; Detached\n    Finished --&gt; Active\n    Finished --&gt; Detached\n    Error --&gt; New\n    Error --&gt; Booting\n    Error --&gt; Active\n    Error --&gt; Paused\n    Error --&gt; [*]\n    Detached --&gt; Active\n    Detached --&gt; [*]</code></pre>"},{"location":"subscription/#new","title":"New","text":"<p>A subscription is created and \"new\" if a subscriber exists with an ID that is not yet tracked. This can happen when either a new subscriber has been added, the subscriber ID has changed or the subscription has been manually deleted from the subscription store. You can then set up the subscription so that it is booting or active. In this step, the subscription engine also tries to call the <code>setup</code> method if available.</p>"},{"location":"subscription/#booting","title":"Booting","text":"<p>Booting status is reached when the setup process is finished. In this step the subscription engine tries to catch up to the current event stream. When the process is finished, the subscription is set to active or finished.</p>"},{"location":"subscription/#active","title":"Active","text":"<p>The active status describes the subscriptions currently being actively managed by the subscription engine. These subscriptions have a subscriber, follow the event stream and should be up-to-date.</p>"},{"location":"subscription/#paused","title":"Paused","text":"<p>A subscription can manually be paused. It will then no longer be updated by the subscription engine. This can be useful if you want to pause a subscription for a certain period of time. You can also reactivate the subscription if you want so that it continues.</p>"},{"location":"subscription/#finished","title":"Finished","text":"<p>A subscription is finished if the subscriber has the mode <code>RunMode::Once</code>. This means that the subscription is only run once and then set to finished if it reaches the end of the event stream. You can also reactivate the subscription if you want so that it continues.</p>"},{"location":"subscription/#detached","title":"Detached","text":"<p>If an active or finished subscription exists in the subscription store that does not have a subscriber in the source code with a corresponding subscriber ID, then this subscription is marked as detached. This happens when either the subscriber has been deleted or the subscriber ID of a subscriber has changed. In the last case there should be a new subscription with the new subscriber ID.</p> <p>A detached subscription does not automatically become active again when the subscriber exists again. This happens, for example, when an old version was deployed again during a rollback.</p> <p>There are two options to reactivate the subscription:</p> <ul> <li>Reactivate the subscription, so that the subscription is active again.</li> <li>Remove the subscription and rebuild it from scratch.</li> </ul>"},{"location":"subscription/#error","title":"Error","text":"<p>If an error occurs in a subscriber, then the subscription is set to Error. This can happen in the create process, in the boot process or in the run process. This subscription will then no longer boot/run until the subscription is reactivate or retried.</p> <p>The subscription engine has a retry strategy to retry subscriptions that have failed. It tries to reactivate the subscription after a certain time and a certain number of attempts. If this does not work, the subscription is set to error and must be manually reactivated.</p> <p>There are two options here:</p> <ul> <li>Reactivate the subscription, so that the subscription is in the previous state again.</li> <li>Remove the subscription and rebuild it from scratch.</li> </ul>"},{"location":"subscription/#setup","title":"Setup","text":"<p>In order for the subscription engine to be able to do its work, you have to assemble it beforehand.</p>"},{"location":"subscription/#subscription-store","title":"Subscription Store","text":"<p>The Subscription Engine uses a subscription store to store the status of each subscription. We provide a Doctrine implementation of this by default.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Subscription\\Store\\DoctrineSubscriptionStore;\n\n$subscriptionStore = new DoctrineSubscriptionStore($connection);\n</code></pre> So that the schema for the subscription store can also be created, we have to tell the <code>DoctrineSchemaDirector</code> our schema configuration. Using <code>ChainDoctrineSchemaConfigurator</code> we can add multiple schema configurators. In our case they need the <code>DoctrineSchemaDirector</code> from the event store and subscription store.</p> <pre><code>use Patchlevel\\EventSourcing\\Schema\\ChainDoctrineSchemaConfigurator;\nuse Patchlevel\\EventSourcing\\Schema\\DoctrineSchemaDirector;\n\n$schemaDirector = new DoctrineSchemaDirector(\n    $connection,\n    new ChainDoctrineSchemaConfigurator([\n        $eventStore,\n        $subscriptionStore,\n    ]),\n);\n</code></pre> <p>Note</p> <p>You can find more about schema configurator here </p>"},{"location":"subscription/#retry-strategy","title":"Retry Strategy","text":"<p>The subscription engine uses a retry strategy to retry subscriptions that have failed. Our default strategy can be configured with the following parameters:</p> <ul> <li><code>baseDelay</code> - The base delay in seconds.</li> <li><code>delayFactor</code> - The factor by which the delay is multiplied after each attempt.</li> <li><code>maxAttempts</code> - The maximum number of attempts.</li> </ul> <pre><code>use Patchlevel\\EventSourcing\\Subscription\\RetryStrategy\\ClockBasedRetryStrategy;\n\n$retryStrategy = new ClockBasedRetryStrategy(\n    baseDelay: 5,\n    delayFactor: 2,\n    maxAttempts: 5,\n);\n</code></pre> <p>Tip</p> <p>You can reactivate the subscription manually or remove it and rebuild it from scratch.</p>"},{"location":"subscription/#subscriber-accessor","title":"Subscriber Accessor","text":"<p>The subscriber accessor repository is responsible for providing the subscribers to the subscription engine. We provide a metadata subscriber accessor repository by default.</p> <pre><code>use Patchlevel\\EventSourcing\\Subscription\\Subscriber\\MetadataSubscriberAccessorRepository;\n\n$subscriberAccessorRepository = new MetadataSubscriberAccessorRepository([$subscriber1, $subscriber2, $subscriber3]);\n</code></pre>"},{"location":"subscription/#subscription-engine_1","title":"Subscription Engine","text":"<p>Now we can create the subscription engine and plug together the necessary services. The event store is needed to load the events, the Subscription Store to store the subscription state and we need the subscriber accessor repository. Optionally, we can also pass a retry strategy.</p> <pre><code>use Patchlevel\\EventSourcing\\Subscription\\Engine\\DefaultSubscriptionEngine;\n\n$subscriptionEngine = new DefaultSubscriptionEngine(\n    $eventStore,\n    $subscriptionStore,\n    $subscriberAccessorRepository,\n    $retryStrategy,\n);\n</code></pre>"},{"location":"subscription/#usage","title":"Usage","text":"<p>The Subscription Engine has a few methods needed to use it effectively. A <code>SubscriptionEngineCriteria</code> can be passed to all of these methods to filter the respective subscriptions.</p> <pre><code>use Patchlevel\\EventSourcing\\Subscription\\Engine\\SubscriptionEngineCriteria;\n\n$criteria = new SubscriptionEngineCriteria(\n    ids: ['profile_1', 'welcome_email'],\n    groups: ['default'],\n);\n</code></pre> <p>Note</p> <p>An <code>OR</code> check is made for the respective criteria and all criteria are checked with an <code>AND</code>.</p>"},{"location":"subscription/#setup_1","title":"Setup","text":"<p>New subscriptions need to be set up before they can be used. In this step, the subscription engine also tries to call the <code>setup</code> method if available. After the setup process, the subscription is set to booting or active.</p> <pre><code>$subscriptionEngine-&gt;setup($criteria);\n</code></pre> <p>Tip</p> <p>You can skip the booting step with the second boolean parameter named <code>skipBooting</code>.</p>"},{"location":"subscription/#boot","title":"Boot","text":"<p>You can boot the subscriptions with the <code>boot</code> method. All booting subscriptions will catch up to the current event stream. After the boot process, the subscription is set to active or finished.</p> <pre><code>$subscriptionEngine-&gt;boot($criteria);\n</code></pre>"},{"location":"subscription/#run","title":"Run","text":"<p>All active subscriptions are continued and updated here.</p> <pre><code>$subscriptionEngine-&gt;run($criteria);\n</code></pre>"},{"location":"subscription/#teardown","title":"Teardown","text":"<p>If subscriptions are detached, they can be cleaned up here. The subscription engine also tries to call the <code>teardown</code> method if available.</p> <pre><code>$subscriptionEngine-&gt;teardown($criteria);\n</code></pre>"},{"location":"subscription/#remove","title":"Remove","text":"<p>You can also directly remove a subscription regardless of its status. An attempt is made to call the <code>teardown</code> method if available. But the entry will still be removed if it doesn't work.</p> <pre><code>$subscriptionEngine-&gt;remove($criteria);\n</code></pre>"},{"location":"subscription/#reactivate","title":"Reactivate","text":"<p>If a subscription had an error or is outdated, you can reactivate it. As a result, the subscription gets in the last status again.</p> <pre><code>$subscriptionEngine-&gt;reactivate($criteria);\n</code></pre>"},{"location":"subscription/#pause","title":"Pause","text":"<p>Pausing a subscription is also possible. The subscription will then no longer be managed by the subscription engine. You can reactivate the subscription if you want so that it continues.</p> <pre><code>$subscriptionEngine-&gt;pause($criteria);\n</code></pre>"},{"location":"subscription/#status","title":"Status","text":"<p>To get the current status of all subscriptions, you can get them using the <code>subscriptions</code> method.</p> <pre><code>$subscriptions = $subscriptionEngine-&gt;subscriptions($criteria);\n\nforeach ($subscriptions as $subscription) {\n    echo $subscription-&gt;status();\n}\n</code></pre>"},{"location":"subscription/#learn-more","title":"Learn more","text":"<ul> <li>How to use CLI commands</li> <li>How to use Pipeline</li> <li>How to use Event Bus</li> <li>How to Test</li> </ul>"},{"location":"testing/","title":"Tests","text":"<p>The aggregates can also be tested very well. You can test whether certain events have been thrown or whether the state is set up correctly when the aggregate is set up again via the events.</p> <pre><code>use PHPUnit\\Framework\\TestCase;\n\nfinal class ProfileTest extends TestCase\n{\n    public function testCreateProfile(): void\n    {\n        $id = ProfileId::generate();\n        $profile = Profile::createProfile($id, Email::fromString('foo@email.com'));\n\n        self::assertEquals(\n            $profile-&gt;releaseEvents(),\n            [\n                new ProfileCreated($id, Email::fromString('foo@email.com')),\n            ],\n        );\n\n        self::assertEquals('foo@email.com', $profile-&gt;email()-&gt;toString());\n    }\n\n    public function testChangeName(): void\n    {\n        $id = ProfileId::generate();\n\n        $profile = Profile::createFromEvents([\n            new ProfileCreated($id, Email::fromString('foo@email.com')),\n        ]);\n\n        $profile-&gt;changeEmail(Email::fromString('bar@email.com'));\n\n        self::assertEquals(\n            $profile-&gt;releaseEvents(),\n            [\n                new EmailChanged(Email::fromString('bar@email.com')),\n            ],\n        );\n\n        self::assertEquals('bar@email.com', $profile-&gt;email()-&gt;toString());\n    }\n}\n</code></pre>"},{"location":"upcasting/","title":"Upcasting","text":"<p>There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer <code>Upcaster</code>, which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event.</p>"},{"location":"upcasting/#adjust-payload","title":"Adjust payload","text":"<p>Let's assume we have an <code>ProfileCreated</code> event which holds an email. Now the business needs to have all emails to be in lower case. For that we could adjust the aggregate and the projections to take care of that. Or we can do this beforehand so we don't need to maintain two different places.</p> <pre><code>use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast;\nuse Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster;\n\nfinal class ProfileCreatedEmailLowerCastUpcaster implements Upcaster\n{\n    public function __invoke(Upcast $upcast): Upcast\n    {\n        // ignore if other event is processed\n        if ($upcast-&gt;eventName !== 'profile_created') {\n            return $upcast;\n        }\n\n        return $upcast-&gt;replacePayloadByKey('email', strtolower($upcast-&gt;payload['email']));\n    }\n}\n</code></pre> <p>Warning</p> <p>You need to consider that other events are passed to the Upcaster. So and early out is here endorsed.</p>"},{"location":"upcasting/#adjust-event-name","title":"Adjust event name","text":"<p>For the upgrade to 2.0.0 this feature is also really handy since we adjusted the event value from FQCN to an unique name which the user needs to choose. This opens up for moving or renaming the events at code level. Here an example for the upgrade path.</p> <pre><code>use Patchlevel\\EventSourcing\\Metadata\\Event\\EventRegistry;\nuse Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast;\nuse Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster;\n\nfinal class LegacyEventNameUpaster implements Upcaster\n{\n    public function __construct(\n        private readonly EventRegistry $eventRegistry,\n    ) {\n    }\n\n    public function __invoke(Upcast $upcast): Upcast\n    {\n        return $upcast-&gt;replaceEventName(\n            $this-&gt;eventRegistry-&gt;eventName($upcast-&gt;eventName),\n        );\n    }\n}\n</code></pre>"},{"location":"upcasting/#use-upcasting","title":"Use upcasting","text":"<p>After we have defined the upcasting rules, we also have to pass the whole thing to the serializer. Since we have multiple upcasters, we use a chain here.</p> <pre><code>use Patchlevel\\EventSourcing\\Serializer\\DefaultEventSerializer;\nuse Patchlevel\\EventSourcing\\Serializer\\Upcast\\UpcasterChain;\n\n$upcaster = new UpcasterChain([\n    new ProfileCreatedEmailLowerCastUpcaster(),\n    new LegacyEventNameUpaster($eventRegistry),\n]);\n\n$serializer = DefaultEventSerializer::createFromPaths(\n    ['src/Domain'],\n    $upcaster,\n);\n</code></pre>"},{"location":"upcasting/#update-event-stream","title":"Update event stream","text":"<p>But what if we need it also in our stream because some other applications has also access on it? Or want to cleanup our Upcasters since we have collected alot of them over the time? Then we can use our pipeline feature without any middlewares to achive a complete rebuild of our stream with adjusted event data.</p> <pre><code>final class EventStreamCleanupCommand extends Command\n{\n    protected static $defaultName = 'event-stream:cleanup';\n    protected static $defaultDescription = 'rebuild event stream';\n\n    public function __construct(\n        private readonly Store $sourceStore,\n        private readonly Store $targetStore,\n    ) {\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $pipeline = new Pipeline(\n            new StoreSource($sourceStore),\n            new StoreTarget($targetStore),\n        );\n\n        $pipeline-&gt;run();\n\n        return Command::SUCCESS;\n    }\n}\n</code></pre> <p>Danger</p> <p>Under no circumstances may the same store be used that is used for the source.  Otherwise the store will be broken afterwards!</p> <p>Note</p> <p>You can find out more about the pipeline here.</p>"}]}